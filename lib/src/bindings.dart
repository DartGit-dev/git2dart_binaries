// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to libgit2
class Libgit2 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Libgit2(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Libgit2.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) => _tzname.value = value;

  late final ffi.Pointer<ffi.Int> _getdate_err =
      _lookup<ffi.Int>('getdate_err');

  int get getdate_err => _getdate_err.value;

  set getdate_err(int value) => _getdate_err.value = value;

  late final ffi.Pointer<ffi.Long> _timezone = _lookup<ffi.Long>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  late final ffi.Pointer<ffi.Int> _daylight = _lookup<ffi.Int>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  ffi.Pointer<ffi.Char> asctime(
    ffi.Pointer<tm> arg0,
  ) {
    return _asctime(
      arg0,
    );
  }

  late final _asctimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>>(
      'asctime');
  late final _asctime =
      _asctimePtr.asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>();

  int clock() {
    return _clock();
  }

  late final _clockPtr =
      _lookup<ffi.NativeFunction<clock_t Function()>>('clock');
  late final _clock = _clockPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> ctime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _ctime(
      arg0,
    );
  }

  late final _ctimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>>('ctime');
  late final _ctime = _ctimePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>();

  double difftime(
    int arg0,
    int arg1,
  ) {
    return _difftime(
      arg0,
      arg1,
    );
  }

  late final _difftimePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(time_t, time_t)>>(
          'difftime');
  late final _difftime = _difftimePtr.asFunction<double Function(int, int)>();

  ffi.Pointer<tm> getdate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getdate(
      arg0,
    );
  }

  late final _getdatePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<ffi.Char>)>>(
      'getdate');
  late final _getdate =
      _getdatePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<tm> gmtime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _gmtime(
      arg0,
    );
  }

  late final _gmtimePtr = _lookup<
      ffi
      .NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>('gmtime');
  late final _gmtime =
      _gmtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<tm> localtime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _localtime(
      arg0,
    );
  }

  late final _localtimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>(
      'localtime');
  late final _localtime =
      _localtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  int mktime(
    ffi.Pointer<tm> arg0,
  ) {
    return _mktime(
      arg0,
    );
  }

  late final _mktimePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('mktime');
  late final _mktime = _mktimePtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int strftime(
    ffi.Pointer<ffi.Char> arg0,
    int __maxsize,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<tm> arg3,
  ) {
    return _strftime(
      arg0,
      __maxsize,
      arg2,
      arg3,
    );
  }

  late final _strftimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strftime');
  late final _strftime = _strftimePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tm>)>();

  ffi.Pointer<ffi.Char> strptime(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<tm> arg2,
  ) {
    return _strptime(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strptimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strptime');
  late final _strptime = _strptimePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>();

  int time(
    ffi.Pointer<time_t> arg0,
  ) {
    return _time(
      arg0,
    );
  }

  late final _timePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<time_t>)>>('time');
  late final _time = _timePtr.asFunction<int Function(ffi.Pointer<time_t>)>();

  void tzset() {
    return _tzset();
  }

  late final _tzsetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzset');
  late final _tzset = _tzsetPtr.asFunction<void Function()>();

  /// [TSF] Thread safe functions
  ffi.Pointer<ffi.Char> asctime_r(
    ffi.Pointer<tm> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _asctime_r(
      arg0,
      arg1,
    );
  }

  late final _asctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>>('asctime_r');
  late final _asctime_r = _asctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _ctime_r(
      arg0,
      arg1,
    );
  }

  late final _ctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>>('ctime_r');
  late final _ctime_r = _ctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<tm> gmtime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<tm> arg1,
  ) {
    return _gmtime_r(
      arg0,
      arg1,
    );
  }

  late final _gmtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('gmtime_r');
  late final _gmtime_r = _gmtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  ffi.Pointer<tm> localtime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<tm> arg1,
  ) {
    return _localtime_r(
      arg0,
      arg1,
    );
  }

  late final _localtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('localtime_r');
  late final _localtime_r = _localtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  int posix2time(
    int arg0,
  ) {
    return _posix2time(
      arg0,
    );
  }

  late final _posix2timePtr =
      _lookup<ffi.NativeFunction<time_t Function(time_t)>>('posix2time');
  late final _posix2time = _posix2timePtr.asFunction<int Function(int)>();

  void tzsetwall() {
    return _tzsetwall();
  }

  late final _tzsetwallPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzsetwall');
  late final _tzsetwall = _tzsetwallPtr.asFunction<void Function()>();

  int time2posix(
    int arg0,
  ) {
    return _time2posix(
      arg0,
    );
  }

  late final _time2posixPtr =
      _lookup<ffi.NativeFunction<time_t Function(time_t)>>('time2posix');
  late final _time2posix = _time2posixPtr.asFunction<int Function(int)>();

  int timelocal(
    ffi.Pointer<tm> arg0,
  ) {
    return _timelocal(
      arg0,
    );
  }

  late final _timelocalPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>(
          'timelocal');
  late final _timelocal =
      _timelocalPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int timegm(
    ffi.Pointer<tm> arg0,
  ) {
    return _timegm(
      arg0,
    );
  }

  late final _timegmPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('timegm');
  late final _timegm = _timegmPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int nanosleep(
    ffi.Pointer<timespec> __rqtp,
    ffi.Pointer<timespec> __rmtp,
  ) {
    return _nanosleep(
      __rqtp,
      __rmtp,
    );
  }

  late final _nanosleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<timespec>, ffi.Pointer<timespec>)>>('nanosleep');
  late final _nanosleep = _nanosleepPtr
      .asFunction<int Function(ffi.Pointer<timespec>, ffi.Pointer<timespec>)>();

  int clock_getres(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __res,
  ) {
    return _clock_getres(
      __clock_id.value,
      __res,
    );
  }

  late final _clock_getresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_getres');
  late final _clock_getres =
      _clock_getresPtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_gettime(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_gettime(
      __clock_id.value,
      __tp,
    );
  }

  late final _clock_gettimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_gettime');
  late final _clock_gettime =
      _clock_gettimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  Dart__uint64_t clock_gettime_nsec_np(
    clockid_t __clock_id,
  ) {
    return _clock_gettime_nsec_np(
      __clock_id.value,
    );
  }

  late final _clock_gettime_nsec_npPtr =
      _lookup<ffi.NativeFunction<__uint64_t Function(ffi.UnsignedInt)>>(
          'clock_gettime_nsec_np');
  late final _clock_gettime_nsec_np =
      _clock_gettime_nsec_npPtr.asFunction<int Function(int)>();

  int clock_settime(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_settime(
      __clock_id.value,
      __tp,
    );
  }

  late final _clock_settimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_settime');
  late final _clock_settime =
      _clock_settimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int timespec_get(
    ffi.Pointer<timespec> ts,
    int base,
  ) {
    return _timespec_get(
      ts,
      base,
    );
  }

  late final _timespec_getPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<timespec>, ffi.Int)>>(
      'timespec_get');
  late final _timespec_get =
      _timespec_getPtr.asFunction<int Function(ffi.Pointer<timespec>, int)>();

  /// For historical reasons; programs expect signal's return value to be
  /// defined by <sys/signal.h>.
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait$1(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait$1(
      arg0,
    );
  }

  late final _wait$1Ptr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait$1 =
      _wait$1Ptr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    idtype_t arg0,
    Dart__uint32_t arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0.value,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, id_t, ffi.Pointer<siginfo_t>,
              ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
    ffi.Pointer<rusage> arg2,
  ) {
    return _wait3(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wait3Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>>('wait3');
  late final _wait3 = _wait3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _wait4Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Pointer<rusage>)>>('wait4');
  late final _wait4 = _wait4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  /// <malloc/_malloc.h>
  ffi.Pointer<ffi.Void> malloc_type_malloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_malloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_malloc');
  late final _malloc_type_malloc = _malloc_type_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_calloc(
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size, malloc_type_id_t)>>('malloc_type_calloc');
  late final _malloc_type_calloc = _malloc_type_callocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_free(
      ptr,
      type_id,
    );
  }

  late final _malloc_type_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, malloc_type_id_t)>>('malloc_type_free');
  late final _malloc_type_free = _malloc_type_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_realloc');
  late final _malloc_type_realloc = _malloc_type_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_valloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_valloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_valloc');
  late final _malloc_type_valloc = _malloc_type_vallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size,
              malloc_type_id_t)>>('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc = _malloc_type_aligned_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  /// rdar://120689514
  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(
      memptr,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc = _malloc_type_zone_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(
      zone,
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc = _malloc_type_zone_callocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<malloc_zone_t>, int, int, int)>();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(
      zone,
      ptr,
      type_id,
    );
  }

  late final _malloc_type_zone_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
              malloc_type_id_t)>>('malloc_type_zone_free');
  late final _malloc_type_zone_free = _malloc_type_zone_freePtr.asFunction<
      void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(
      zone,
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc = _malloc_type_zone_vallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(
      zone,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> reallocf(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _reallocf(
      __ptr,
      __size,
    );
  }

  late final _reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('reallocf');
  late final _reallocf = _reallocfPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  /// rdar://120689514
  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _at_quick_exit(
      arg0,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  /// calloc is now declared in _malloc.h
  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  /// free is now declared in _malloc.h
  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  /// malloc is now declared in _malloc.h
  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __n,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __n,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  /// posix_memalign is now declared in _malloc.h
  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void quick_exit(
    int arg0,
  ) {
    return _quick_exit(
      arg0,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  /// realloc is now declared in _malloc.h
  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int __n,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __size,
  ) {
    return _initstate(
      arg0,
      arg1,
      __size,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(
    int fildes,
    ffi.Pointer<ffi.Char> buffer,
    int buflen,
  ) {
    return _ptsname_r(
      fildes,
      buffer,
      buflen,
    );
  }

  late final _ptsname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    int __datlen,
  ) {
    return _arc4random_addrandom(
      arg0,
      __datlen,
    );
  }

  late final _arc4random_addrandomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('arc4random_addrandom');
  late final _arc4random_addrandom = _arc4random_addrandomPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _arc4random_buf(
      __buf,
      __nbytes,
    );
  }

  late final _arc4random_bufPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  /// getcap(3) functions
  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('cgetcap');
  late final _cgetcap = _cgetcapPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('cgetclose');
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('cgetent');
  late final _cgetent = _cgetentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(
      arg0,
      arg1,
    );
  }

  late final _cgetfirstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetfirst');
  late final _cgetfirst = _cgetfirstPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetmatch(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _cgetmatch(
      arg0,
      arg1,
    );
  }

  late final _cgetmatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('cgetmatch');
  late final _cgetmatch = _cgetmatchPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(
      arg0,
      arg1,
    );
  }

  late final _cgetnextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetnext');
  late final _cgetnext = _cgetnextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetnumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>)>>('cgetnum');
  late final _cgetnum = _cgetnumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Long>)>();

  int cgetset(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _cgetset(
      arg0,
    );
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'cgetset');
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetstr');
  late final _cgetstr = _cgetstrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetustrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetustr');
  late final _cgetustr = _cgetustrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int daemon(
    int arg0,
    int arg1,
  ) {
    return _daemon(
      arg0,
      arg1,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(
    int arg0,
    int arg1,
  ) {
    return _devname(
      arg0,
      arg1,
    );
  }

  late final _devnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>>(
      'devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(
      arg0,
      arg1,
      buf,
      len,
    );
  }

  late final _devname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              dev_t, mode_t, ffi.Pointer<ffi.Char>, ffi.Int)>>('devname_r');
  late final _devname_r = _devname_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(
      arg0,
      arg1,
    );
  }

  late final _getbsizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>>('getbsize');
  late final _getbsize = _getbsizePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> arg0,
    int __nelem,
  ) {
    return _getloadavg(
      arg0,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getprogname');
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setprogname(
      arg0,
    );
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setprogname');
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _heapsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _heapsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('heapsort');
  late final _heapsort = _heapsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _mergesort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _mergesortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('mergesort');
  late final _mergesort = _mergesortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _psortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort');
  late final _psort = _psortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _psort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort_r');
  late final _psort_r = _psort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _qsort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort_r');
  late final _qsort_r = _qsort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _radixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('radixsort');
  late final _radixsort = _radixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rpmatch(
      arg0,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _sradixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('sradixsort');
  late final _sradixsort = _sradixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sranddev');
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('srandomdev');
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  /// reallocf is now declared in _malloc.h
  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(
      __numstr,
      __minval,
      __maxval,
      __errstrp,
    );
  }

  late final _strtonumPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong,
              ffi.LongLong, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtonum');
  late final _strtonum = _strtonumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// getsubopt(3) external variable
  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  /// 7.8.2.1
  int imaxabs(
    int j,
  ) {
    return _imaxabs(
      j,
    );
  }

  late final _imaxabsPtr =
      _lookup<ffi.NativeFunction<intmax_t Function(intmax_t)>>('imaxabs');
  late final _imaxabs = _imaxabsPtr.asFunction<int Function(int)>();

  imaxdiv_t imaxdiv(
    int __numer,
    int __denom,
  ) {
    return _imaxdiv(
      __numer,
      __denom,
    );
  }

  late final _imaxdivPtr =
      _lookup<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>(
          'imaxdiv');
  late final _imaxdiv = _imaxdivPtr.asFunction<imaxdiv_t Function(int, int)>();

  /// 7.8.2.3
  int strtoimax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoimax');
  late final _strtoimax = _strtoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoumax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoumax');
  late final _strtoumax = _strtoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// 7.8.2.4
  int wcstoimax(
    ffi.Pointer<ffi.WChar> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> __endptr,
    int __base,
  ) {
    return _wcstoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoimax');
  late final _wcstoimax = _wcstoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  int wcstoumax(
    ffi.Pointer<ffi.WChar> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> __endptr,
    int __base,
  ) {
    return _wcstoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoumax');
  late final _wcstoumax = _wcstoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  /// Return the version of the libgit2 library
  /// being currently used.
  ///
  /// @param major Store the major version number
  /// @param minor Store the minor version number
  /// @param rev Store the revision (patch) number
  /// @return 0 on success or an error code on failure
  int git_libgit2_version(
    ffi.Pointer<ffi.Int> major,
    ffi.Pointer<ffi.Int> minor,
    ffi.Pointer<ffi.Int> rev,
  ) {
    return _git_libgit2_version(
      major,
      minor,
      rev,
    );
  }

  late final _git_libgit2_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('git_libgit2_version');
  late final _git_libgit2_version = _git_libgit2_versionPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Return the prerelease state of the libgit2 library currently being
  /// used.  For nightly builds during active development, this will be
  /// "alpha".  Releases may have a "beta" or release candidate ("rc1",
  /// "rc2", etc) prerelease.  For a final release, this function returns
  /// NULL.
  ///
  /// @return the name of the prerelease state or NULL
  ffi.Pointer<ffi.Char> git_libgit2_prerelease() {
    return _git_libgit2_prerelease();
  }

  late final _git_libgit2_prereleasePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'git_libgit2_prerelease');
  late final _git_libgit2_prerelease =
      _git_libgit2_prereleasePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Query compile time options for libgit2.
  ///
  /// @return A combination of GIT_FEATURE_* values.
  int git_libgit2_features() {
    return _git_libgit2_features();
  }

  late final _git_libgit2_featuresPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('git_libgit2_features');
  late final _git_libgit2_features =
      _git_libgit2_featuresPtr.asFunction<int Function()>();

  /// Query the backend details for the compile-time feature in libgit2.
  ///
  /// This will return the "backend" for the feature, which is useful for
  /// things like HTTPS or SSH support, that can have multiple backends
  /// that could be compiled in.
  ///
  /// For example, when libgit2 is compiled with dynamic OpenSSL support,
  /// the feature backend will be `openssl-dynamic`. The feature backend
  /// names reflect the compilation options specified to the build system
  /// (though in all lower case). The backend _may_ be "builtin" for
  /// features that are provided by libgit2 itself.
  ///
  /// If the feature is not supported by the library, this API returns
  /// `NULL`.
  ///
  /// @param feature the feature to query details for
  /// @return the provider details, or NULL if the feature is not supported
  ffi.Pointer<ffi.Char> git_libgit2_feature_backend(
    git_feature_t feature,
  ) {
    return _git_libgit2_feature_backend(
      feature.value,
    );
  }

  late final _git_libgit2_feature_backendPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'git_libgit2_feature_backend');
  late final _git_libgit2_feature_backend = _git_libgit2_feature_backendPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Set or query a library global option
  ///
  /// Available options:
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_SIZE, size_t *):
  ///
  /// > Get the maximum mmap window size
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_SIZE, size_t):
  ///
  /// > Set the maximum mmap window size
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_MAPPED_LIMIT, size_t *):
  ///
  /// > Get the maximum memory that will be mapped in total by the library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_MAPPED_LIMIT, size_t):
  ///
  /// > Set the maximum amount of memory that can be mapped at any time
  /// > by the library
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_FILE_LIMIT, size_t *):
  ///
  /// > Get the maximum number of files that will be mapped at any time by the
  /// > library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_FILE_LIMIT, size_t):
  ///
  /// > Set the maximum number of files that can be mapped at any time
  /// > by the library. The default (0) is unlimited.
  ///
  /// * opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
  ///
  /// > Get the search path for a given level of config data.  "level" must
  /// > be one of `GIT_CONFIG_LEVEL_SYSTEM`, `GIT_CONFIG_LEVEL_GLOBAL`,
  /// > `GIT_CONFIG_LEVEL_XDG`, or `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  /// > The search path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
  ///
  /// > Set the search path for a level of config data.  The search path
  /// > applied to shared attributes and ignore files, too.
  /// >
  /// > - `path` lists directories delimited by GIT_PATH_LIST_SEPARATOR.
  /// >   Pass NULL to reset to the default (generally based on environment
  /// >   variables).  Use magic path `$PATH` to include the old value
  /// >   of the path (if you want to prepend or append, for instance).
  /// >
  /// > - `level` must be `GIT_CONFIG_LEVEL_SYSTEM`,
  /// >   `GIT_CONFIG_LEVEL_GLOBAL`, `GIT_CONFIG_LEVEL_XDG`, or
  /// >   `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  ///
  /// * opts(GIT_OPT_SET_CACHE_OBJECT_LIMIT, git_object_t type, size_t size)
  ///
  /// > Set the maximum data size for the given type of object to be
  /// > considered eligible for caching in memory.  Setting to value to
  /// > zero means that that type of object will not be cached.
  /// > Defaults to 0 for GIT_OBJECT_BLOB (i.e. won't cache blobs) and 4k
  /// > for GIT_OBJECT_COMMIT, GIT_OBJECT_TREE, and GIT_OBJECT_TAG.
  ///
  /// * opts(GIT_OPT_SET_CACHE_MAX_SIZE, ssize_t max_storage_bytes)
  ///
  /// > Set the maximum total data size that will be cached in memory
  /// > across all repositories before libgit2 starts evicting objects
  /// > from the cache.  This is a soft limit, in that the library might
  /// > briefly exceed it, but will start aggressively evicting objects
  /// > from cache when that happens.  The default cache size is 256MB.
  ///
  /// * opts(GIT_OPT_ENABLE_CACHING, int enabled)
  ///
  /// > Enable or disable caching completely.
  /// >
  /// > Because caches are repository-specific, disabling the cache
  /// > cannot immediately clear all cached objects, but each cache will
  /// > be cleared on the next attempt to update anything in it.
  ///
  /// * opts(GIT_OPT_GET_CACHED_MEMORY, ssize_t *current, ssize_t *allowed)
  ///
  /// > Get the current bytes in cache and the maximum that would be
  /// > allowed in the cache.
  ///
  /// * opts(GIT_OPT_GET_TEMPLATE_PATH, git_buf *out)
  ///
  /// > Get the default template path.
  /// > The path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_TEMPLATE_PATH, const char *path)
  ///
  /// > Set the default template path.
  /// >
  /// > - `path` directory of template.
  ///
  /// * opts(GIT_OPT_SET_SSL_CERT_LOCATIONS, const char *file, const char *path)
  ///
  /// > Set the SSL certificate-authority locations.
  /// >
  /// > - `file` is the location of a file containing several
  /// >   certificates concatenated together.
  /// > - `path` is the location of a directory holding several
  /// >   certificates, one per file.
  /// >
  /// > Calling `GIT_OPT_ADD_SSL_X509_CERT` may override the
  /// > data in `path`.
  /// >
  /// > Either parameter may be `NULL`, but not both.
  ///
  /// * opts(GIT_OPT_ADD_SSL_X509_CERT, const X509 *cert)
  ///
  /// > Add a raw X509 certificate into the SSL certs store.
  /// > This certificate is only used by libgit2 invocations
  /// > during the application lifetime and is not persisted
  /// > to disk. This certificate cannot be removed from the
  /// > application once is has been added.
  /// >
  /// > - `cert` is the raw X509 cert will be added to cert store.
  ///
  /// * opts(GIT_OPT_SET_USER_AGENT, const char *user_agent)
  ///
  /// > Set the value of the comment section of the User-Agent header.
  /// > This can be information about your product and its version.
  /// > By default this is "libgit2" followed by the libgit2 version.
  /// >
  /// > This value will be appended to User-Agent _product_, which
  /// > is typically set to "git/2.0".
  /// >
  /// > Set to the empty string ("") to not send any information in the
  /// > comment section, or set to NULL to restore the default.
  ///
  /// * opts(GIT_OPT_GET_USER_AGENT, git_buf *out)
  ///
  /// > Get the value of the User-Agent header.
  /// > The User-Agent is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_USER_AGENT_PRODUCT, const char *user_agent_product)
  ///
  /// > Set the value of the product portion of the User-Agent header.
  /// > This defaults to "git/2.0", for compatibility with other git
  /// > clients. It is recommended to keep this as git/<version> for
  /// > compatibility with servers that do user-agent detection.
  /// >
  /// > Set to the empty string ("") to not send any user-agent string,
  /// > or set to NULL to restore the default.
  ///
  /// * opts(GIT_OPT_GET_USER_AGENT_PRODUCT, git_buf *out)
  ///
  /// > Get the value of the User-Agent product header.
  /// > The User-Agent product is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_WINDOWS_SHAREMODE, unsigned long value)
  ///
  /// > Set the share mode used when opening files on Windows.
  /// > For more information, see the documentation for CreateFile.
  /// > The default is: FILE_SHARE_READ | FILE_SHARE_WRITE.  This is
  /// > ignored and unused on non-Windows platforms.
  ///
  /// * opts(GIT_OPT_GET_WINDOWS_SHAREMODE, unsigned long *value)
  ///
  /// > Get the share mode used when opening files on Windows.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_OBJECT_CREATION, int enabled)
  ///
  /// > Enable strict input validation when creating new objects
  /// > to ensure that all inputs to the new objects are valid.  For
  /// > example, when this is enabled, the parent(s) and tree inputs
  /// > will be validated when creating a new commit.  This defaults
  /// > to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION, int enabled)
  ///
  /// > Validate the target of a symbolic ref when creating it.  For
  /// > example, `foobar` is not a valid ref, therefore `foobar` is
  /// > not a valid target for a symbolic ref by default, whereas
  /// > `refs/heads/foobar` is.  Disabling this bypasses validation
  /// > so that an arbitrary strings such as `foobar` can be used
  /// > for a symbolic ref target.  This defaults to enabled.
  ///
  /// * opts(GIT_OPT_SET_SSL_CIPHERS, const char *ciphers)
  ///
  /// > Set the SSL ciphers use for HTTPS connections.
  /// >
  /// > - `ciphers` is the list of ciphers that are eanbled.
  ///
  /// * opts(GIT_OPT_ENABLE_OFS_DELTA, int enabled)
  ///
  /// > Enable or disable the use of "offset deltas" when creating packfiles,
  /// > and the negotiation of them when talking to a remote server.
  /// > Offset deltas store a delta base location as an offset into the
  /// > packfile from the current location, which provides a shorter encoding
  /// > and thus smaller resultant packfiles.
  /// > Packfiles containing offset deltas can still be read.
  /// > This defaults to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_FSYNC_GITDIR, int enabled)
  ///
  /// > Enable synchronized writes of files in the gitdir using `fsync`
  /// > (or the platform equivalent) to ensure that new object data
  /// > is written to permanent storage, not simply cached.  This
  /// > defaults to disabled.
  ///
  /// opts(GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION, int enabled)
  ///
  /// > Enable strict verification of object hashsums when reading
  /// > objects from disk. This may impact performance due to an
  /// > additional checksum calculation on each object. This defaults
  /// > to enabled.
  ///
  /// opts(GIT_OPT_SET_ALLOCATOR, git_allocator *allocator)
  ///
  /// > Set the memory allocator to a different memory allocator. This
  /// > allocator will then be used to make all memory allocations for
  /// > libgit2 operations.  If the given `allocator` is NULL, then the
  /// > system default will be restored.
  ///
  /// opts(GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY, int enabled)
  ///
  /// > Ensure that there are no unsaved changes in the index before
  /// > beginning any operation that reloads the index from disk (eg,
  /// > checkout).  If there are unsaved changes, the instruction will
  /// > fail.  (Using the FORCE flag to checkout will still overwrite
  /// > these changes.)
  ///
  /// opts(GIT_OPT_GET_PACK_MAX_OBJECTS, size_t *out)
  ///
  /// > Get the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote. This can be
  /// > used to limit maximum memory usage when fetching from an untrusted
  /// > remote.
  ///
  /// opts(GIT_OPT_SET_PACK_MAX_OBJECTS, size_t objects)
  ///
  /// > Set the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote.
  ///
  /// opts(GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS, int enabled)
  /// > This will cause .keep file existence checks to be skipped when
  /// > accessing packfiles, which can help performance with remote filesystems.
  ///
  /// opts(GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE, int enabled)
  /// > When connecting to a server using NTLM or Negotiate
  /// > authentication, use expect/continue when POSTing data.
  /// > This option is not available on Windows.
  ///
  /// opts(GIT_OPT_SET_ODB_PACKED_PRIORITY, int priority)
  /// > Override the default priority of the packed ODB backend which
  /// > is added when default backends are assigned to a repository
  ///
  /// opts(GIT_OPT_SET_ODB_LOOSE_PRIORITY, int priority)
  /// > Override the default priority of the loose ODB backend which
  /// > is added when default backends are assigned to a repository
  ///
  /// opts(GIT_OPT_GET_EXTENSIONS, git_strarray *out)
  /// > Returns the list of git extensions that are supported.  This
  /// > is the list of built-in extensions supported by libgit2 and
  /// > custom extensions that have been added with
  /// > `GIT_OPT_SET_EXTENSIONS`.  Extensions that have been negated
  /// > will not be returned.  The returned list should be released
  /// > with `git_strarray_dispose`.
  ///
  /// opts(GIT_OPT_SET_EXTENSIONS, const char **extensions, size_t len)
  /// > Set that the given git extensions are supported by the caller.
  /// > Extensions supported by libgit2 may be negated by prefixing
  /// > them with a `!`.  For example: setting extensions to
  /// > { "!noop", "newext" } indicates that the caller does not want
  /// > to support repositories with the `noop` extension but does want
  /// > to support repositories with the `newext` extension.
  ///
  /// opts(GIT_OPT_GET_OWNER_VALIDATION, int *enabled)
  /// > Gets the owner validation setting for repository
  /// > directories.
  ///
  /// opts(GIT_OPT_SET_OWNER_VALIDATION, int enabled)
  /// > Set that repository directories should be owned by the current
  /// > user. The default is to validate ownership.
  ///
  /// opts(GIT_OPT_GET_HOMEDIR, git_buf *out)
  /// > Gets the current user's home directory, as it will be used
  /// > for file lookups. The path is written to the `out` buffer.
  ///
  /// opts(GIT_OPT_SET_HOMEDIR, const char *path)
  /// > Sets the directory used as the current user's home directory,
  /// > for file lookups.
  /// >
  /// > - `path` directory of home directory.
  ///
  /// opts(GIT_OPT_GET_SERVER_CONNECT_TIMEOUT, int *timeout)
  /// > Gets the timeout (in milliseconds) to attempt connections to
  /// > a remote server.
  ///
  /// opts(GIT_OPT_SET_SERVER_CONNECT_TIMEOUT, int timeout)
  /// > Sets the timeout (in milliseconds) to attempt connections to
  /// > a remote server. Set to 0 to use the system default. Note that
  /// > this may not be able to be configured longer than the system
  /// > default, typically 75 seconds.
  ///
  /// opts(GIT_OPT_GET_SERVER_TIMEOUT, int *timeout)
  /// > Gets the timeout (in milliseconds) for reading from and writing
  /// > to a remote server.
  ///
  /// opts(GIT_OPT_SET_SERVER_TIMEOUT, int timeout)
  /// > Sets the timeout (in milliseconds) for reading from and writing
  /// > to a remote server. Set to 0 to use the system default.
  ///
  /// @param option Option key
  /// @return 0 on success, <0 on failure
  int git_libgit2_opts(
    int option,
  ) {
    return _git_libgit2_opts(
      option,
    );
  }

  late final _git_libgit2_optsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'git_libgit2_opts');
  late final _git_libgit2_opts =
      _git_libgit2_optsPtr.asFunction<int Function(int)>();

  int __darwin_check_fd_set_overflow(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return ___darwin_check_fd_set_overflow(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___darwin_check_fd_set_overflowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('__darwin_check_fd_set_overflow');
  late final ___darwin_check_fd_set_overflow =
      ___darwin_check_fd_set_overflowPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Free the memory referred to by the git_buf.
  ///
  /// Note that this does not free the `git_buf` itself, just the memory
  /// pointed to by `buffer->ptr`.
  ///
  /// @param buffer The buffer to deallocate
  void git_buf_dispose(
    ffi.Pointer<git_buf> buffer,
  ) {
    return _git_buf_dispose(
      buffer,
    );
  }

  late final _git_buf_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_buf>)>>(
          'git_buf_dispose');
  late final _git_buf_dispose =
      _git_buf_disposePtr.asFunction<void Function(ffi.Pointer<git_buf>)>();

  int git_oid_fromstr(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Char> str,
    git_oid_t type,
  ) {
    return _git_oid_fromstr(
      out,
      str,
      type.value,
    );
  }

  late final _git_oid_fromstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_oid_fromstr');
  late final _git_oid_fromstr = _git_oid_fromstrPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>, int)>();

  int git_oid_fromstrp(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Char> str,
    git_oid_t type,
  ) {
    return _git_oid_fromstrp(
      out,
      str,
      type.value,
    );
  }

  late final _git_oid_fromstrpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_oid_fromstrp');
  late final _git_oid_fromstrp = _git_oid_fromstrpPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>, int)>();

  int git_oid_fromstrn(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Char> str,
    int length,
    git_oid_t type,
  ) {
    return _git_oid_fromstrn(
      out,
      str,
      length,
      type.value,
    );
  }

  late final _git_oid_fromstrnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>,
              ffi.Size, ffi.UnsignedInt)>>('git_oid_fromstrn');
  late final _git_oid_fromstrn = _git_oid_fromstrnPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>, int, int)>();

  int git_oid_fromraw(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.UnsignedChar> raw,
    git_oid_t type,
  ) {
    return _git_oid_fromraw(
      out,
      raw,
      type.value,
    );
  }

  late final _git_oid_fromrawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('git_oid_fromraw');
  late final _git_oid_fromraw = _git_oid_fromrawPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Format a git_oid into a hex string.
  ///
  /// @param out output hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (40 bytes for SHA1,
  /// 64 bytes for SHA256). Only the oid digits are written;
  /// a '\\0' terminator must be added by the caller if it is
  /// required.
  /// @param id oid structure to format.
  /// @return 0 on success or error code
  int git_oid_fmt(
    ffi.Pointer<ffi.Char> out,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_fmt(
      out,
      id,
    );
  }

  late final _git_oid_fmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>>('git_oid_fmt');
  late final _git_oid_fmt = _git_oid_fmtPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a partial hex string.
  ///
  /// @param out output hex string; you say how many bytes to write.
  /// If the number of bytes is > GIT_OID_SHA1_HEXSIZE, extra bytes
  /// will be zeroed; if not, a '\0' terminator is NOT added.
  /// @param n number of characters to write into out string
  /// @param id oid structure to format.
  /// @return 0 on success or error code
  int git_oid_nfmt(
    ffi.Pointer<ffi.Char> out,
    int n,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_nfmt(
      out,
      n,
      id,
    );
  }

  late final _git_oid_nfmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<git_oid>)>>('git_oid_nfmt');
  late final _git_oid_nfmt = _git_oid_nfmtPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a loose-object path string.
  ///
  /// The resulting string is "aa/...", where "aa" is the first two
  /// hex digits of the oid and "..." is the remaining 38 digits.
  ///
  /// @param out output hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (41 bytes for SHA1,
  /// 65 bytes for SHA256). Only the oid digits are written;
  /// a '\\0' terminator must be added by the caller if it
  /// is required.
  /// @param id oid structure to format.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_oid_pathfmt(
    ffi.Pointer<ffi.Char> out,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_pathfmt(
      out,
      id,
    );
  }

  late final _git_oid_pathfmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>>('git_oid_pathfmt');
  late final _git_oid_pathfmt = _git_oid_pathfmtPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a statically allocated c-string.
  ///
  /// The c-string is owned by the library and should not be freed
  /// by the user. If libgit2 is built with thread support, the string
  /// will be stored in TLS (i.e. one buffer per thread) to allow for
  /// concurrent calls of the function.
  ///
  /// @param oid The oid structure to format
  /// @return the c-string or NULL on failure
  ffi.Pointer<ffi.Char> git_oid_tostr_s(
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_oid_tostr_s(
      oid,
    );
  }

  late final _git_oid_tostr_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_oid>)>>('git_oid_tostr_s');
  late final _git_oid_tostr_s = _git_oid_tostr_sPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a buffer as a hex format c-string.
  ///
  /// If the buffer is smaller than the size of a hex-formatted oid string
  /// plus an additional byte (GIT_OID_SHA_HEXSIZE + 1 for SHA1 or
  /// GIT_OID_SHA256_HEXSIZE + 1 for SHA256), then the resulting
  /// oid c-string will be truncated to n-1 characters (but will still be
  /// NUL-byte terminated).
  ///
  /// If there are any input parameter errors (out == NULL, n == 0, oid ==
  /// NULL), then a pointer to an empty string is returned, so that the
  /// return value can always be printed.
  ///
  /// @param out the buffer into which the oid string is output.
  /// @param n the size of the out buffer.
  /// @param id the oid structure to format.
  /// @return the out buffer pointer, assuming no input parameter
  /// errors, otherwise a pointer to an empty string.
  ffi.Pointer<ffi.Char> git_oid_tostr(
    ffi.Pointer<ffi.Char> out,
    int n,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_tostr(
      out,
      n,
      id,
    );
  }

  late final _git_oid_tostrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<git_oid>)>>('git_oid_tostr');
  late final _git_oid_tostr = _git_oid_tostrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<git_oid>)>();

  /// Copy an oid from one structure to another.
  ///
  /// @param out oid structure the result is written into.
  /// @param src oid structure to copy from.
  /// @return 0 on success or error code
  int git_oid_cpy(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_oid> src,
  ) {
    return _git_oid_cpy(
      out,
      src,
    );
  }

  late final _git_oid_cpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_oid_cpy');
  late final _git_oid_cpy = _git_oid_cpyPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Compare two oid structures.
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @return <0, 0, >0 if a < b, a == b, a > b.
  int git_oid_cmp(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
  ) {
    return _git_oid_cmp(
      a,
      b,
    );
  }

  late final _git_oid_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_oid_cmp');
  late final _git_oid_cmp = _git_oid_cmpPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Compare two oid structures for equality
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @return true if equal, false otherwise
  int git_oid_equal(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
  ) {
    return _git_oid_equal(
      a,
      b,
    );
  }

  late final _git_oid_equalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_oid_equal');
  late final _git_oid_equal = _git_oid_equalPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Compare the first 'len' hexadecimal characters (packets of 4 bits)
  /// of two oid structures.
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @param len the number of hex chars to compare
  /// @return 0 in case of a match
  int git_oid_ncmp(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
    int len,
  ) {
    return _git_oid_ncmp(
      a,
      b,
      len,
    );
  }

  late final _git_oid_ncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>,
              ffi.Size)>>('git_oid_ncmp');
  late final _git_oid_ncmp = _git_oid_ncmpPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>, int)>();

  /// Check if an oid equals an hex formatted object id.
  ///
  /// @param id oid structure.
  /// @param str input hex string of an object id.
  /// @return 0 in case of a match, -1 otherwise.
  int git_oid_streq(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _git_oid_streq(
      id,
      str,
    );
  }

  late final _git_oid_streqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>>('git_oid_streq');
  late final _git_oid_streq = _git_oid_streqPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>();

  /// Compare an oid to an hex formatted object id.
  ///
  /// @param id oid structure.
  /// @param str input hex string of an object id.
  /// @return -1 if str is not valid, <0 if id sorts before str,
  /// 0 if id matches str, >0 if id sorts after str.
  int git_oid_strcmp(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _git_oid_strcmp(
      id,
      str,
    );
  }

  late final _git_oid_strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>>('git_oid_strcmp');
  late final _git_oid_strcmp = _git_oid_strcmpPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>();

  /// Check is an oid is all zeros.
  ///
  /// @param id the object ID to check
  /// @return 1 if all zeros, 0 otherwise.
  int git_oid_is_zero(
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_is_zero(
      id,
    );
  }

  late final _git_oid_is_zeroPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid>)>>(
          'git_oid_is_zero');
  late final _git_oid_is_zero =
      _git_oid_is_zeroPtr.asFunction<int Function(ffi.Pointer<git_oid>)>();

  /// Create a new OID shortener.
  ///
  /// The OID shortener is used to process a list of OIDs
  /// in text form and return the shortest length that would
  /// uniquely identify all of them.
  ///
  /// E.g. look at the result of `git log --abbrev`.
  ///
  /// @param min_length The minimal length for all identifiers,
  /// which will be used even if shorter OIDs would still
  /// be unique.
  /// @return a `git_oid_shorten` instance, NULL if OOM
  ffi.Pointer<git_oid_shorten> git_oid_shorten_new(
    int min_length,
  ) {
    return _git_oid_shorten_new(
      min_length,
    );
  }

  late final _git_oid_shorten_newPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<git_oid_shorten> Function(ffi.Size)>>(
      'git_oid_shorten_new');
  late final _git_oid_shorten_new = _git_oid_shorten_newPtr
      .asFunction<ffi.Pointer<git_oid_shorten> Function(int)>();

  /// Add a new OID to set of shortened OIDs and calculate
  /// the minimal length to uniquely identify all the OIDs in
  /// the set.
  ///
  /// The OID is expected to be a 40-char hexadecimal string.
  /// The OID is owned by the user and will not be modified
  /// or freed.
  ///
  /// For performance reasons, there is a hard-limit of how many
  /// OIDs can be added to a single set (around ~32000, assuming
  /// a mostly randomized distribution), which should be enough
  /// for any kind of program, and keeps the algorithm fast and
  /// memory-efficient.
  ///
  /// Attempting to add more than those OIDs will result in a
  /// GIT_ERROR_INVALID error
  ///
  /// @param os a `git_oid_shorten` instance
  /// @param text_id an OID in text form
  /// @return the minimal length to uniquely identify all OIDs
  /// added so far to the set; or an error code (<0) if an
  /// error occurs.
  int git_oid_shorten_add(
    ffi.Pointer<git_oid_shorten> os,
    ffi.Pointer<ffi.Char> text_id,
  ) {
    return _git_oid_shorten_add(
      os,
      text_id,
    );
  }

  late final _git_oid_shorten_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid_shorten>,
              ffi.Pointer<ffi.Char>)>>('git_oid_shorten_add');
  late final _git_oid_shorten_add = _git_oid_shorten_addPtr.asFunction<
      int Function(ffi.Pointer<git_oid_shorten>, ffi.Pointer<ffi.Char>)>();

  /// Free an OID shortener instance
  ///
  /// @param os a `git_oid_shorten` instance
  void git_oid_shorten_free(
    ffi.Pointer<git_oid_shorten> os,
  ) {
    return _git_oid_shorten_free(
      os,
    );
  }

  late final _git_oid_shorten_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_oid_shorten>)>>(
      'git_oid_shorten_free');
  late final _git_oid_shorten_free = _git_oid_shorten_freePtr
      .asFunction<void Function(ffi.Pointer<git_oid_shorten>)>();

  /// Free the object IDs contained in an oid_array.  This method should
  /// be called on `git_oidarray` objects that were provided by the
  /// library.  Not doing so will result in a memory leak.
  ///
  /// This does not free the `git_oidarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array git_oidarray from which to free oid data
  void git_oidarray_dispose(
    ffi.Pointer<git_oidarray> array,
  ) {
    return _git_oidarray_dispose(
      array,
    );
  }

  late final _git_oidarray_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_oidarray>)>>(
          'git_oidarray_dispose');
  late final _git_oidarray_dispose = _git_oidarray_disposePtr
      .asFunction<void Function(ffi.Pointer<git_oidarray>)>();

  /// Initializes a `git_indexer_options` with default values. Equivalent to
  /// creating an instance with GIT_INDEXER_OPTIONS_INIT.
  ///
  /// @param opts the `git_indexer_options` struct to initialize.
  /// @param version Version of struct; pass `GIT_INDEXER_OPTIONS_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_indexer_options_init(
    ffi.Pointer<git_indexer_options> opts,
    int version,
  ) {
    return _git_indexer_options_init(
      opts,
      version,
    );
  }

  late final _git_indexer_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_indexer_options>,
              ffi.UnsignedInt)>>('git_indexer_options_init');
  late final _git_indexer_options_init = _git_indexer_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_indexer_options>, int)>();

  /// Create a new indexer instance
  ///
  /// @param out where to store the indexer instance
  /// @param path to the directory where the packfile should be stored
  /// @param opts the options to create the indexer with
  /// @return 0 or an error code.
  int git_indexer_new(
    ffi.Pointer<ffi.Pointer<git_indexer>> out,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_indexer_options> opts,
  ) {
    return _git_indexer_new(
      out,
      path,
      opts,
    );
  }

  late final _git_indexer_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_indexer>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_indexer_options>)>>('git_indexer_new');
  late final _git_indexer_new = _git_indexer_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_indexer>>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_indexer_options>)>();

  /// Add data to the indexer
  ///
  /// @param idx the indexer
  /// @param data the data to add
  /// @param size the size of the data in bytes
  /// @param stats stat storage
  /// @return 0 or an error code.
  int git_indexer_append(
    ffi.Pointer<git_indexer> idx,
    ffi.Pointer<ffi.Void> data,
    int size,
    ffi.Pointer<git_indexer_progress> stats,
  ) {
    return _git_indexer_append(
      idx,
      data,
      size,
      stats,
    );
  }

  late final _git_indexer_appendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_indexer>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<git_indexer_progress>)>>('git_indexer_append');
  late final _git_indexer_append = _git_indexer_appendPtr.asFunction<
      int Function(ffi.Pointer<git_indexer>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<git_indexer_progress>)>();

  /// Finalize the pack and index
  ///
  /// Resolve any pending deltas and write out the index file
  ///
  /// @param idx the indexer
  /// @param stats Stat storage.
  /// @return 0 or an error code.
  int git_indexer_commit(
    ffi.Pointer<git_indexer> idx,
    ffi.Pointer<git_indexer_progress> stats,
  ) {
    return _git_indexer_commit(
      idx,
      stats,
    );
  }

  late final _git_indexer_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_indexer>,
              ffi.Pointer<git_indexer_progress>)>>('git_indexer_commit');
  late final _git_indexer_commit = _git_indexer_commitPtr.asFunction<
      int Function(
          ffi.Pointer<git_indexer>, ffi.Pointer<git_indexer_progress>)>();

  /// Get the packfile's hash
  ///
  /// A packfile's name is derived from the sorted hashing of all object
  /// names. This is only correct after the index has been finalized.
  ///
  /// @deprecated use git_indexer_name
  /// @param idx the indexer instance
  /// @return the packfile's hash
  ffi.Pointer<git_oid> git_indexer_hash(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_hash(
      idx,
    );
  }

  late final _git_indexer_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_indexer>)>>('git_indexer_hash');
  late final _git_indexer_hash = _git_indexer_hashPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_indexer>)>();

  /// Get the unique name for the resulting packfile.
  ///
  /// The packfile's name is derived from the packfile's content.
  /// This is only correct after the index has been finalized.
  ///
  /// @param idx the indexer instance
  /// @return a NUL terminated string for the packfile name
  ffi.Pointer<ffi.Char> git_indexer_name(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_name(
      idx,
    );
  }

  late final _git_indexer_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_indexer>)>>('git_indexer_name');
  late final _git_indexer_name = _git_indexer_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_indexer>)>();

  /// Free the indexer and its resources
  ///
  /// @param idx the indexer to free
  void git_indexer_free(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_free(
      idx,
    );
  }

  late final _git_indexer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_indexer>)>>(
          'git_indexer_free');
  late final _git_indexer_free = _git_indexer_freePtr
      .asFunction<void Function(ffi.Pointer<git_indexer>)>();

  /// Create a new object database with no backends.
  ///
  /// @param[out] odb location to store the database pointer, if opened.
  /// @param opts the options for this object database or NULL for defaults
  /// @return 0 or an error code
  int git_odb_new(
    ffi.Pointer<ffi.Pointer<git_odb>> odb,
    ffi.Pointer<git_odb_options> opts,
  ) {
    return _git_odb_new(
      odb,
      opts,
    );
  }

  late final _git_odb_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>>,
              ffi.Pointer<git_odb_options>)>>('git_odb_new');
  late final _git_odb_new = _git_odb_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb>>, ffi.Pointer<git_odb_options>)>();

  /// Create a new object database and automatically add loose and packed
  /// backends.
  ///
  /// @param[out] odb_out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param objects_dir path of the backends' "objects" directory.
  /// @param opts the options for this object database or NULL for defaults
  /// @return 0 or an error code
  int git_odb_open(
    ffi.Pointer<ffi.Pointer<git_odb>> odb_out,
    ffi.Pointer<ffi.Char> objects_dir,
    ffi.Pointer<git_odb_options> opts,
  ) {
    return _git_odb_open(
      odb_out,
      objects_dir,
      opts,
    );
  }

  late final _git_odb_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_odb_options>)>>('git_odb_open');
  late final _git_odb_open = _git_odb_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb>>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_odb_options>)>();

  /// Add an on-disk alternate to an existing Object DB.
  ///
  /// Note that the added path must point to an `objects`, not
  /// to a full repository, to use it as an alternate store.
  ///
  /// Alternate backends are always checked for objects *after*
  /// all the main backends have been exhausted.
  ///
  /// Writing is disabled on alternate backends.
  ///
  /// @param odb database to add the backend to
  /// @param path path to the objects folder for the alternate
  /// @return 0 on success, error code otherwise
  int git_odb_add_disk_alternate(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_odb_add_disk_alternate(
      odb,
      path,
    );
  }

  late final _git_odb_add_disk_alternatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>,
              ffi.Pointer<ffi.Char>)>>('git_odb_add_disk_alternate');
  late final _git_odb_add_disk_alternate = _git_odb_add_disk_alternatePtr
      .asFunction<int Function(ffi.Pointer<git_odb>, ffi.Pointer<ffi.Char>)>();

  /// Close an open object database.
  ///
  /// @param db database pointer to close. If NULL no action is taken.
  void git_odb_free(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_free(
      db,
    );
  }

  late final _git_odb_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb>)>>(
          'git_odb_free');
  late final _git_odb_free =
      _git_odb_freePtr.asFunction<void Function(ffi.Pointer<git_odb>)>();

  /// Read an object from the database.
  ///
  /// This method queries all available ODB backends
  /// trying to read the given OID.
  ///
  /// The returned object is reference counted and
  /// internally cached, so it should be closed
  /// by the user once it's no longer in use.
  ///
  /// @param[out] obj pointer where to store the read object
  /// @param db database to search for the object in.
  /// @param id identity of the object to read.
  /// @return 0 if the object was read, GIT_ENOTFOUND if the object is
  /// not in the database.
  int git_odb_read(
    ffi.Pointer<ffi.Pointer<git_odb_object>> obj,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_read(
      obj,
      db,
      id,
    );
  }

  late final _git_odb_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
              ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>>('git_odb_read');
  late final _git_odb_read = _git_odb_readPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
          ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>();

  /// Read an object from the database, given a prefix
  /// of its identifier.
  ///
  /// This method queries all available ODB backends
  /// trying to match the 'len' first hexadecimal
  /// characters of the 'short_id'.
  /// The remaining (GIT_OID_SHA1_HEXSIZE-len)*4 bits of
  /// 'short_id' must be 0s.
  /// 'len' must be at least GIT_OID_MINPREFIXLEN,
  /// and the prefix must be long enough to identify
  /// a unique object in all the backends; the
  /// method will fail otherwise.
  ///
  /// The returned object is reference counted and
  /// internally cached, so it should be closed
  /// by the user once it's no longer in use.
  ///
  /// @param[out] obj pointer where to store the read object
  /// @param db database to search for the object in.
  /// @param short_id a prefix of the id of the object to read.
  /// @param len the length of the prefix
  /// @return 0 if the object was read, GIT_ENOTFOUND if the object is not in the
  /// database. GIT_EAMBIGUOUS if the prefix is ambiguous
  /// (several objects match the prefix)
  int git_odb_read_prefix(
    ffi.Pointer<ffi.Pointer<git_odb_object>> obj,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> short_id,
    int len,
  ) {
    return _git_odb_read_prefix(
      obj,
      db,
      short_id,
      len,
    );
  }

  late final _git_odb_read_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_object>>,
              ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_odb_read_prefix');
  late final _git_odb_read_prefix = _git_odb_read_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
          ffi.Pointer<git_odb>, ffi.Pointer<git_oid>, int)>();

  /// Read the header of an object from the database, without
  /// reading its full contents.
  ///
  /// The header includes the length and the type of an object.
  ///
  /// Note that most backends do not support reading only the header
  /// of an object, so the whole object will be read and then the
  /// header will be returned.
  ///
  /// @param[out] len_out pointer where to store the length
  /// @param[out] type_out pointer where to store the type
  /// @param db database to search for the object in.
  /// @param id identity of the object to read.
  /// @return 0 if the object was read, GIT_ENOTFOUND if the object is not
  /// in the database.
  int git_odb_read_header(
    ffi.Pointer<ffi.Size> len_out,
    ffi.Pointer<ffi.Int> type_out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_read_header(
      len_out,
      type_out,
      db,
      id,
    );
  }

  late final _git_odb_read_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>)>>('git_odb_read_header');
  late final _git_odb_read_header = _git_odb_read_headerPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>();

  /// Determine if the given object can be found in the object database.
  ///
  /// @param db database to be searched for the given object.
  /// @param id the object to search for.
  /// @return 1 if the object was found, 0 otherwise
  int git_odb_exists(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_exists(
      db,
      id,
    );
  }

  late final _git_odb_existsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>>('git_odb_exists');
  late final _git_odb_exists = _git_odb_existsPtr
      .asFunction<int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>();

  /// Determine if the given object can be found in the object database, with
  /// extended options.
  ///
  /// @param db database to be searched for the given object.
  /// @param id the object to search for.
  /// @param flags flags affecting the lookup (see `git_odb_lookup_flags_t`)
  /// @return 1 if the object was found, 0 otherwise
  int git_odb_exists_ext(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
    int flags,
  ) {
    return _git_odb_exists_ext(
      db,
      id,
      flags,
    );
  }

  late final _git_odb_exists_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_oid>,
              ffi.UnsignedInt)>>('git_odb_exists_ext');
  late final _git_odb_exists_ext = _git_odb_exists_extPtr.asFunction<
      int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_oid>, int)>();

  /// Determine if an object can be found in the object database by an
  /// abbreviated object ID.
  ///
  /// @param out The full OID of the found object if just one is found.
  /// @param db The database to be searched for the given object.
  /// @param short_id A prefix of the id of the object to read.
  /// @param len The length of the prefix.
  /// @return 0 if found, GIT_ENOTFOUND if not found, GIT_EAMBIGUOUS if multiple
  /// matches were found, other value < 0 if there was a read error.
  int git_odb_exists_prefix(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> short_id,
    int len,
  ) {
    return _git_odb_exists_prefix(
      out,
      db,
      short_id,
      len,
    );
  }

  late final _git_odb_exists_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>, ffi.Size)>>('git_odb_exists_prefix');
  late final _git_odb_exists_prefix = _git_odb_exists_prefixPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
          ffi.Pointer<git_oid>, int)>();

  /// Determine if one or more objects can be found in the object database
  /// by their abbreviated object ID and type.
  ///
  /// The given array will be updated in place: for each abbreviated ID that is
  /// unique in the database, and of the given type (if specified),
  /// the full object ID, object ID length (`GIT_OID_SHA1_HEXSIZE`) and type will be
  /// written back to the array. For IDs that are not found (or are ambiguous),
  /// the array entry will be zeroed.
  ///
  /// Note that since this function operates on multiple objects, the
  /// underlying database will not be asked to be reloaded if an object is
  /// not found (which is unlike other object database operations.)
  ///
  /// @param db The database to be searched for the given objects.
  /// @param ids An array of short object IDs to search for
  /// @param count The length of the `ids` array
  /// @return 0 on success or an error code on failure
  int git_odb_expand_ids(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_odb_expand_id> ids,
    int count,
  ) {
    return _git_odb_expand_ids(
      db,
      ids,
      count,
    );
  }

  late final _git_odb_expand_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_expand_id>,
              ffi.Size)>>('git_odb_expand_ids');
  late final _git_odb_expand_ids = _git_odb_expand_idsPtr.asFunction<
      int Function(
          ffi.Pointer<git_odb>, ffi.Pointer<git_odb_expand_id>, int)>();

  /// Refresh the object database to load newly added files.
  ///
  /// If the object databases have changed on disk while the library
  /// is running, this function will force a reload of the underlying
  /// indexes.
  ///
  /// Use this function when you're confident that an external
  /// application has tampered with the ODB.
  ///
  /// NOTE that it is not necessary to call this function at all. The
  /// library will automatically attempt to refresh the ODB
  /// when a lookup fails, to see if the looked up object exists
  /// on disk but hasn't been loaded yet.
  ///
  /// @param db database to refresh
  /// @return 0 on success, error code otherwise
  int git_odb_refresh(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_refresh(
      db,
    );
  }

  late final _git_odb_refreshPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb>)>>(
          'git_odb_refresh');
  late final _git_odb_refresh =
      _git_odb_refreshPtr.asFunction<int Function(ffi.Pointer<git_odb>)>();

  /// List all objects available in the database
  ///
  /// The callback will be called for each object available in the
  /// database. Note that the objects are likely to be returned in the index
  /// order, which would make accessing the objects in that order inefficient.
  /// Return a non-zero value from the callback to stop looping.
  ///
  /// @param db database to use
  /// @param cb the callback to call for each object
  /// @param payload data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_odb_foreach(
    ffi.Pointer<git_odb> db,
    git_odb_foreach_cb cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_odb_foreach(
      db,
      cb,
      payload,
    );
  }

  late final _git_odb_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, git_odb_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_odb_foreach');
  late final _git_odb_foreach = _git_odb_foreachPtr.asFunction<
      int Function(
          ffi.Pointer<git_odb>, git_odb_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Write an object directly into the ODB
  ///
  /// This method writes a full object straight into the ODB.
  /// For most cases, it is preferred to write objects through a write
  /// stream, which is both faster and less memory intensive, specially
  /// for big objects.
  ///
  /// This method is provided for compatibility with custom backends
  /// which are not able to support streaming writes
  ///
  /// @param out pointer to store the OID result of the write
  /// @param odb object database where to store the object
  /// @param data @type `const unsigned char *` buffer with the data to store
  /// @param len size of the buffer
  /// @param type type of the data to store
  /// @return 0 or an error code
  int git_odb_write(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<ffi.Void> data,
    int len,
    git_object_t type,
  ) {
    return _git_odb_write(
      out,
      odb,
      data,
      len,
      type.value,
    );
  }

  late final _git_odb_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('git_odb_write');
  late final _git_odb_write = _git_odb_writePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
          ffi.Pointer<ffi.Void>, int, int)>();

  /// Open a stream to write an object into the ODB
  ///
  /// The type and final length of the object must be specified
  /// when opening the stream.
  ///
  /// The returned stream will be of type `GIT_STREAM_WRONLY`, and it
  /// won't be effective until `git_odb_stream_finalize_write` is called
  /// and returns without an error
  ///
  /// The stream must always be freed when done with `git_odb_stream_free` or
  /// will leak memory.
  ///
  /// @see git_odb_stream
  ///
  /// @param out pointer where to store the stream
  /// @param db object database where the stream will write
  /// @param size final size of the object that will be written
  /// @param type type of the object that will be written
  /// @return 0 if the stream was created; error code otherwise
  int git_odb_open_wstream(
    ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
    ffi.Pointer<git_odb> db,
    Dartgit_object_size_t size,
    git_object_t type,
  ) {
    return _git_odb_open_wstream(
      out,
      db,
      size,
      type.value,
    );
  }

  late final _git_odb_open_wstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_stream>>,
              ffi.Pointer<git_odb>,
              git_object_size_t,
              ffi.Int)>>('git_odb_open_wstream');
  late final _git_odb_open_wstream = _git_odb_open_wstreamPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_stream>>,
          ffi.Pointer<git_odb>, int, int)>();

  /// Write to an odb stream
  ///
  /// This method will fail if the total number of received bytes exceeds the
  /// size declared with `git_odb_open_wstream()`
  ///
  /// @param stream the stream
  /// @param buffer the data to write
  /// @param len the buffer's length
  /// @return 0 if the write succeeded, error code otherwise
  int git_odb_stream_write(
    ffi.Pointer<git_odb_stream> stream,
    ffi.Pointer<ffi.Char> buffer,
    int len,
  ) {
    return _git_odb_stream_write(
      stream,
      buffer,
      len,
    );
  }

  late final _git_odb_stream_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_odb_stream_write');
  late final _git_odb_stream_write = _git_odb_stream_writePtr.asFunction<
      int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>, int)>();

  /// Finish writing to an odb stream
  ///
  /// The object will take its final name and will be available to the
  /// odb.
  ///
  /// This method will fail if the total number of received bytes
  /// differs from the size declared with `git_odb_open_wstream()`
  ///
  /// @param out pointer to store the resulting object's id
  /// @param stream the stream
  /// @return 0 on success, an error code otherwise
  int git_odb_stream_finalize_write(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb_stream> stream,
  ) {
    return _git_odb_stream_finalize_write(
      out,
      stream,
    );
  }

  late final _git_odb_stream_finalize_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_odb_stream>)>>('git_odb_stream_finalize_write');
  late final _git_odb_stream_finalize_write =
      _git_odb_stream_finalize_writePtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb_stream>)>();

  /// Read from an odb stream
  ///
  /// Most backends don't implement streaming reads
  ///
  /// @param stream the stream
  /// @param buffer a user-allocated buffer to store the data in.
  /// @param len the buffer's length
  /// @return the number of bytes read if succeeded, error code otherwise
  int git_odb_stream_read(
    ffi.Pointer<git_odb_stream> stream,
    ffi.Pointer<ffi.Char> buffer,
    int len,
  ) {
    return _git_odb_stream_read(
      stream,
      buffer,
      len,
    );
  }

  late final _git_odb_stream_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_odb_stream_read');
  late final _git_odb_stream_read = _git_odb_stream_readPtr.asFunction<
      int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>, int)>();

  /// Free an odb stream
  ///
  /// @param stream the stream to free
  void git_odb_stream_free(
    ffi.Pointer<git_odb_stream> stream,
  ) {
    return _git_odb_stream_free(
      stream,
    );
  }

  late final _git_odb_stream_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_stream>)>>(
      'git_odb_stream_free');
  late final _git_odb_stream_free = _git_odb_stream_freePtr
      .asFunction<void Function(ffi.Pointer<git_odb_stream>)>();

  /// Open a stream to read an object from the ODB
  ///
  /// Note that most backends do *not* support streaming reads
  /// because they store their objects as compressed/delta'ed blobs.
  ///
  /// It's recommended to use `git_odb_read` instead, which is
  /// assured to work on all backends.
  ///
  /// The returned stream will be of type `GIT_STREAM_RDONLY` and
  /// will have the following methods:
  ///
  /// - stream->read: read `n` bytes from the stream
  /// - stream->free: free the stream
  ///
  /// The stream must always be free'd or will leak memory.
  ///
  /// @see git_odb_stream
  ///
  /// @param out pointer where to store the stream
  /// @param len pointer where to store the length of the object
  /// @param type pointer where to store the type of the object
  /// @param db object database where the stream will read from
  /// @param oid oid of the object the stream will read from
  /// @return 0 if the stream was created, error code otherwise
  int git_odb_open_rstream(
    ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
    ffi.Pointer<ffi.Size> len,
    ffi.Pointer<ffi.Int> type,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_odb_open_rstream(
      out,
      len,
      type,
      db,
      oid,
    );
  }

  late final _git_odb_open_rstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_stream>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>)>>('git_odb_open_rstream');
  late final _git_odb_open_rstream = _git_odb_open_rstreamPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb_stream>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<git_odb>,
          ffi.Pointer<git_oid>)>();

  /// Open a stream for writing a pack file to the ODB.
  ///
  /// If the ODB layer understands pack files, then the given
  /// packfile will likely be streamed directly to disk (and a
  /// corresponding index created).  If the ODB layer does not
  /// understand pack files, the objects will be stored in whatever
  /// format the ODB layer uses.
  ///
  /// @see git_odb_writepack
  ///
  /// @param out pointer to the writepack functions
  /// @param db object database where the stream will read from
  /// @param progress_cb function to call with progress information.
  /// Be aware that this is called inline with network and indexing operations,
  /// so performance may be affected.
  /// @param progress_payload payload for the progress callback
  /// @return 0 or an error code.
  int git_odb_write_pack(
    ffi.Pointer<ffi.Pointer<git_odb_writepack>> out,
    ffi.Pointer<git_odb> db,
    git_indexer_progress_cb progress_cb,
    ffi.Pointer<ffi.Void> progress_payload,
  ) {
    return _git_odb_write_pack(
      out,
      db,
      progress_cb,
      progress_payload,
    );
  }

  late final _git_odb_write_packPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_writepack>>,
              ffi.Pointer<git_odb>,
              git_indexer_progress_cb,
              ffi.Pointer<ffi.Void>)>>('git_odb_write_pack');
  late final _git_odb_write_pack = _git_odb_write_packPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb_writepack>>,
          ffi.Pointer<git_odb>,
          git_indexer_progress_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Write a `multi-pack-index` file from all the `.pack` files in the ODB.
  ///
  /// If the ODB layer understands pack files, then this will create a file called
  /// `multi-pack-index` next to the `.pack` and `.idx` files, which will contain
  /// an index of all objects stored in `.pack` files. This will allow for
  /// O(log n) lookup for n objects (regardless of how many packfiles there
  /// exist).
  ///
  /// @param db object database where the `multi-pack-index` file will be written.
  /// @return 0 or an error code.
  int git_odb_write_multi_pack_index(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_write_multi_pack_index(
      db,
    );
  }

  late final _git_odb_write_multi_pack_indexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb>)>>(
          'git_odb_write_multi_pack_index');
  late final _git_odb_write_multi_pack_index =
      _git_odb_write_multi_pack_indexPtr
          .asFunction<int Function(ffi.Pointer<git_odb>)>();

  /// Generate the object ID (in SHA1 or SHA256 format) for a given data buffer.
  ///
  /// @param[out] oid the resulting object ID.
  /// @param data data to hash
  /// @param len size of the data
  /// @param object_type of the data to hash
  /// @param oid_type the oid type to hash to
  /// @return 0 or an error code
  int git_odb_hash(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Void> data,
    int len,
    git_object_t object_type,
    git_oid_t oid_type,
  ) {
    return _git_odb_hash(
      oid,
      data,
      len,
      object_type.value,
      oid_type.value,
    );
  }

  late final _git_odb_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Int, ffi.UnsignedInt)>>('git_odb_hash');
  late final _git_odb_hash = _git_odb_hashPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// Determine the object ID of a file on disk.
  ///
  /// @param[out] oid oid structure the result is written into.
  /// @param path file to read and determine object id for
  /// @param object_type of the data to hash
  /// @param oid_type the oid type to hash to
  /// @return 0 or an error code
  int git_odb_hashfile(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Char> path,
    git_object_t object_type,
    git_oid_t oid_type,
  ) {
    return _git_odb_hashfile(
      oid,
      path,
      object_type.value,
      oid_type.value,
    );
  }

  late final _git_odb_hashfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.UnsignedInt)>>('git_odb_hashfile');
  late final _git_odb_hashfile = _git_odb_hashfilePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Create a copy of an odb_object
  ///
  /// The returned copy must be manually freed with `git_odb_object_free`.
  /// Note that because of an implementation detail, the returned copy will be
  /// the same pointer as `source`: the object is internally refcounted, so the
  /// copy still needs to be freed twice.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_odb_object_dup(
    ffi.Pointer<ffi.Pointer<git_odb_object>> dest,
    ffi.Pointer<git_odb_object> source,
  ) {
    return _git_odb_object_dup(
      dest,
      source,
    );
  }

  late final _git_odb_object_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
              ffi.Pointer<git_odb_object>)>>('git_odb_object_dup');
  late final _git_odb_object_dup = _git_odb_object_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
          ffi.Pointer<git_odb_object>)>();

  /// Close an ODB object
  ///
  /// This method must always be called once a `git_odb_object` is no
  /// longer needed, otherwise memory will leak.
  ///
  /// @param object object to close
  void git_odb_object_free(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_free(
      object,
    );
  }

  late final _git_odb_object_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_object>)>>(
      'git_odb_object_free');
  late final _git_odb_object_free = _git_odb_object_freePtr
      .asFunction<void Function(ffi.Pointer<git_odb_object>)>();

  /// Return the OID of an ODB object
  ///
  /// This is the OID from which the object was read from
  ///
  /// @param object the object
  /// @return a pointer to the OID
  ffi.Pointer<git_oid> git_odb_object_id(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_id(
      object,
    );
  }

  late final _git_odb_object_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_odb_object>)>>('git_odb_object_id');
  late final _git_odb_object_id = _git_odb_object_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_odb_object>)>();

  /// Return the data of an ODB object
  ///
  /// This is the uncompressed, raw data as read from the ODB,
  /// without the leading header.
  ///
  /// This pointer is owned by the object and shall not be free'd.
  ///
  /// @param object the object
  /// @return @type `const unsigned char *` a pointer to the data
  ffi.Pointer<ffi.Void> git_odb_object_data(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_data(
      object,
    );
  }

  late final _git_odb_object_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<git_odb_object>)>>('git_odb_object_data');
  late final _git_odb_object_data = _git_odb_object_dataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_odb_object>)>();

  /// Return the size of an ODB object
  ///
  /// This is the real size of the `data` buffer, not the
  /// actual size of the object.
  ///
  /// @param object the object
  /// @return the size
  int git_odb_object_size(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_size(
      object,
    );
  }

  late final _git_odb_object_sizePtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_odb_object>)>>(
      'git_odb_object_size');
  late final _git_odb_object_size = _git_odb_object_sizePtr
      .asFunction<int Function(ffi.Pointer<git_odb_object>)>();

  /// Return the type of an ODB object
  ///
  /// @param object the object
  /// @return the type
  git_object_t git_odb_object_type(
    ffi.Pointer<git_odb_object> object,
  ) {
    return git_object_t.fromValue(_git_odb_object_type(
      object,
    ));
  }

  late final _git_odb_object_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_object>)>>(
      'git_odb_object_type');
  late final _git_odb_object_type = _git_odb_object_typePtr
      .asFunction<int Function(ffi.Pointer<git_odb_object>)>();

  /// Add a custom backend to an existing Object DB
  ///
  /// The backends are checked in relative ordering, based on the
  /// value of the `priority` parameter.
  ///
  /// Read <sys/odb_backend.h> for more information.
  ///
  /// @param odb database to add the backend to
  /// @param backend pointer to a git_odb_backend instance
  /// @param priority Value for ordering the backends queue
  /// @return 0 on success, error code otherwise
  int git_odb_add_backend(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_odb_backend> backend,
    int priority,
  ) {
    return _git_odb_add_backend(
      odb,
      backend,
      priority,
    );
  }

  late final _git_odb_add_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>,
              ffi.Int)>>('git_odb_add_backend');
  late final _git_odb_add_backend = _git_odb_add_backendPtr.asFunction<
      int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>, int)>();

  /// Add a custom backend to an existing Object DB; this
  /// backend will work as an alternate.
  ///
  /// Alternate backends are always checked for objects *after*
  /// all the main backends have been exhausted.
  ///
  /// The backends are checked in relative ordering, based on the
  /// value of the `priority` parameter.
  ///
  /// Writing is disabled on alternate backends.
  ///
  /// Read <sys/odb_backend.h> for more information.
  ///
  /// @param odb database to add the backend to
  /// @param backend pointer to a git_odb_backend instance
  /// @param priority Value for ordering the backends queue
  /// @return 0 on success, error code otherwise
  int git_odb_add_alternate(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_odb_backend> backend,
    int priority,
  ) {
    return _git_odb_add_alternate(
      odb,
      backend,
      priority,
    );
  }

  late final _git_odb_add_alternatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>,
              ffi.Int)>>('git_odb_add_alternate');
  late final _git_odb_add_alternate = _git_odb_add_alternatePtr.asFunction<
      int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>, int)>();

  /// Get the number of ODB backend objects
  ///
  /// @param odb object database
  /// @return number of backends in the ODB
  int git_odb_num_backends(
    ffi.Pointer<git_odb> odb,
  ) {
    return _git_odb_num_backends(
      odb,
    );
  }

  late final _git_odb_num_backendsPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_odb>)>>(
          'git_odb_num_backends');
  late final _git_odb_num_backends =
      _git_odb_num_backendsPtr.asFunction<int Function(ffi.Pointer<git_odb>)>();

  /// Lookup an ODB backend object by index
  ///
  /// @param out output pointer to ODB backend at pos
  /// @param odb object database
  /// @param pos index into object database backend list
  /// @return 0 on success, GIT_ENOTFOUND if pos is invalid, other errors < 0
  int git_odb_get_backend(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<git_odb> odb,
    int pos,
  ) {
    return _git_odb_get_backend(
      out,
      odb,
      pos,
    );
  }

  late final _git_odb_get_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
              ffi.Pointer<git_odb>, ffi.Size)>>('git_odb_get_backend');
  late final _git_odb_get_backend = _git_odb_get_backendPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
          ffi.Pointer<git_odb>, int)>();

  /// Set the git commit-graph for the ODB.
  ///
  /// After a successful call, the ownership of the cgraph parameter will be
  /// transferred to libgit2, and the caller should not free it.
  ///
  /// The commit-graph can also be unset by explicitly passing NULL as the cgraph
  /// parameter.
  ///
  /// @param odb object database
  /// @param cgraph the git commit-graph
  /// @return 0 on success; error code otherwise
  int git_odb_set_commit_graph(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_commit_graph> cgraph,
  ) {
    return _git_odb_set_commit_graph(
      odb,
      cgraph,
    );
  }

  late final _git_odb_set_commit_graphPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>,
              ffi.Pointer<git_commit_graph>)>>('git_odb_set_commit_graph');
  late final _git_odb_set_commit_graph =
      _git_odb_set_commit_graphPtr.asFunction<
          int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_commit_graph>)>();

  /// Lookup a reference to one of the objects in a repository.
  ///
  /// The generated reference is owned by the repository and
  /// should be closed with the `git_object_free` method
  /// instead of free'd manually.
  ///
  /// The 'type' parameter must match the type of the object
  /// in the odb; the method will fail otherwise.
  /// The special value 'GIT_OBJECT_ANY' may be passed to let
  /// the method guess the object's type.
  ///
  /// @param object pointer to the looked-up object
  /// @param repo the repository to look up the object
  /// @param id the unique identifier for the object
  /// @param type the type of the object
  /// @return 0 or an error code
  int git_object_lookup(
    ffi.Pointer<ffi.Pointer<git_object>> object,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    git_object_t type,
  ) {
    return _git_object_lookup(
      object,
      repo,
      id,
      type.value,
    );
  }

  late final _git_object_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Int)>>('git_object_lookup');
  late final _git_object_lookup = _git_object_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Lookup a reference to one of the objects in a repository,
  /// given a prefix of its identifier (short id).
  ///
  /// The object obtained will be so that its identifier
  /// matches the first 'len' hexadecimal characters
  /// (packets of 4 bits) of the given `id`. `len` must be
  /// at least `GIT_OID_MINPREFIXLEN`, and long enough to
  /// identify a unique object matching the prefix; otherwise
  /// the method will fail.
  ///
  /// The generated reference is owned by the repository and
  /// should be closed with the `git_object_free` method
  /// instead of free'd manually.
  ///
  /// The `type` parameter must match the type of the object
  /// in the odb; the method will fail otherwise.
  /// The special value `GIT_OBJECT_ANY` may be passed to let
  /// the method guess the object's type.
  ///
  /// @param object_out pointer where to store the looked-up object
  /// @param repo the repository to look up the object
  /// @param id a short identifier for the object
  /// @param len the length of the short identifier
  /// @param type the type of the object
  /// @return 0 or an error code
  int git_object_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
    git_object_t type,
  ) {
    return _git_object_lookup_prefix(
      object_out,
      repo,
      id,
      len,
      type.value,
    );
  }

  late final _git_object_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size,
              ffi.Int)>>('git_object_lookup_prefix');
  late final _git_object_lookup_prefix =
      _git_object_lookup_prefixPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int, int)>();

  /// Lookup an object that represents a tree entry.
  ///
  /// @param out buffer that receives a pointer to the object (which must be freed
  /// by the caller)
  /// @param treeish root object that can be peeled to a tree
  /// @param path relative path from the root object to the desired object
  /// @param type type of object desired
  /// @return 0 on success, or an error code
  int git_object_lookup_bypath(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<ffi.Char> path,
    git_object_t type,
  ) {
    return _git_object_lookup_bypath(
      out,
      treeish,
      path,
      type.value,
    );
  }

  late final _git_object_lookup_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_object_lookup_bypath');
  late final _git_object_lookup_bypath =
      _git_object_lookup_bypathPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the id (SHA1) of a repository object
  ///
  /// @param obj the repository object
  /// @return the SHA1 id
  ffi.Pointer<git_oid> git_object_id(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_id(
      obj,
    );
  }

  late final _git_object_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_object>)>>('git_object_id');
  late final _git_object_id = _git_object_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_object>)>();

  /// Get a short abbreviated OID string for the object
  ///
  /// This starts at the "core.abbrev" length (default 7 characters) and
  /// iteratively extends to a longer string if that length is ambiguous.
  /// The result will be unambiguous (at least until new objects are added to
  /// the repository).
  ///
  /// @param out Buffer to write string into
  /// @param obj The object to get an ID for
  /// @return 0 on success, <0 for error
  int git_object_short_id(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_short_id(
      out,
      obj,
    );
  }

  late final _git_object_short_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_object>)>>('git_object_short_id');
  late final _git_object_short_id = _git_object_short_idPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_object>)>();

  /// Get the object type of an object
  ///
  /// @param obj the repository object
  /// @return the object's type
  git_object_t git_object_type(
    ffi.Pointer<git_object> obj,
  ) {
    return git_object_t.fromValue(_git_object_type(
      obj,
    ));
  }

  late final _git_object_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_object>)>>(
          'git_object_type');
  late final _git_object_type =
      _git_object_typePtr.asFunction<int Function(ffi.Pointer<git_object>)>();

  /// Get the repository that owns this object
  ///
  /// Freeing or calling `git_repository_close` on the
  /// returned pointer will invalidate the actual object.
  ///
  /// Any other operation may be run on the repository without
  /// affecting the object.
  ///
  /// @param obj the object
  /// @return the repository who owns this object
  ffi.Pointer<git_repository> git_object_owner(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_owner(
      obj,
    );
  }

  late final _git_object_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_object>)>>('git_object_owner');
  late final _git_object_owner = _git_object_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_object>)>();

  /// Close an open object
  ///
  /// This method instructs the library to close an existing
  /// object; note that git_objects are owned and cached by the repository
  /// so the object may or may not be freed after this library call,
  /// depending on how aggressive is the caching mechanism used
  /// by the repository.
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop using
  /// an object. Failure to do so will cause a memory leak.
  ///
  /// @param object the object to close
  void git_object_free(
    ffi.Pointer<git_object> object,
  ) {
    return _git_object_free(
      object,
    );
  }

  late final _git_object_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_object>)>>(
          'git_object_free');
  late final _git_object_free =
      _git_object_freePtr.asFunction<void Function(ffi.Pointer<git_object>)>();

  /// Convert an object type to its string representation.
  ///
  /// The result is a pointer to a string in static memory and
  /// should not be free()'ed.
  ///
  /// @param type object type to convert.
  /// @return the corresponding string representation.
  ffi.Pointer<ffi.Char> git_object_type2string(
    git_object_t type,
  ) {
    return _git_object_type2string(
      type.value,
    );
  }

  late final _git_object_type2stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'git_object_type2string');
  late final _git_object_type2string = _git_object_type2stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Convert a string object type representation to it's git_object_t.
  ///
  /// @param str the string to convert.
  /// @return the corresponding git_object_t.
  git_object_t git_object_string2type(
    ffi.Pointer<ffi.Char> str,
  ) {
    return git_object_t.fromValue(_git_object_string2type(
      str,
    ));
  }

  late final _git_object_string2typePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'git_object_string2type');
  late final _git_object_string2type = _git_object_string2typePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Determine if the given git_object_t is a valid loose object type.
  ///
  /// @param type object type to test.
  /// @return true if the type represents a valid loose object type,
  /// false otherwise.
  int git_object_typeisloose(
    git_object_t type,
  ) {
    return _git_object_typeisloose(
      type.value,
    );
  }

  late final _git_object_typeisloosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'git_object_typeisloose');
  late final _git_object_typeisloose =
      _git_object_typeisloosePtr.asFunction<int Function(int)>();

  /// Recursively peel an object until an object of the specified type is met.
  ///
  /// If the query cannot be satisfied due to the object model,
  /// GIT_EINVALIDSPEC will be returned (e.g. trying to peel a blob to a
  /// tree).
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object will
  /// be peeled until the type changes. A tag will be peeled until the
  /// referenced object is no longer a tag, and a commit will be peeled
  /// to a tree. Any other object type will return GIT_EINVALIDSPEC.
  ///
  /// If peeling a tag we discover an object which cannot be peeled to
  /// the target type due to the object model, GIT_EPEEL will be
  /// returned.
  ///
  /// You must free the returned object.
  ///
  /// @param peeled Pointer to the peeled git_object
  /// @param object The object to be processed
  /// @param target_type The type of the requested object (a GIT_OBJECT_ value)
  /// @return 0 on success, GIT_EINVALIDSPEC, GIT_EPEEL, or an error code
  int git_object_peel(
    ffi.Pointer<ffi.Pointer<git_object>> peeled,
    ffi.Pointer<git_object> object,
    git_object_t target_type,
  ) {
    return _git_object_peel(
      peeled,
      object,
      target_type.value,
    );
  }

  late final _git_object_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>, ffi.Int)>>('git_object_peel');
  late final _git_object_peel = _git_object_peelPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_object>, int)>();

  /// Create an in-memory copy of a Git object. The copy must be
  /// explicitly free'd or it will leak.
  ///
  /// @param dest Pointer to store the copy of the object
  /// @param source Original object to copy
  /// @return 0 or an error code
  int git_object_dup(
    ffi.Pointer<ffi.Pointer<git_object>> dest,
    ffi.Pointer<git_object> source,
  ) {
    return _git_object_dup(
      dest,
      source,
    );
  }

  late final _git_object_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>)>>('git_object_dup');
  late final _git_object_dup = _git_object_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>, ffi.Pointer<git_object>)>();

  /// Analyzes a buffer of raw object content and determines its validity.
  /// Tree, commit, and tag objects will be parsed and ensured that they
  /// are valid, parseable content.  (Blobs are always valid by definition.)
  /// An error message will be set with an informative message if the object
  /// is not valid.
  ///
  /// @warning This function is experimental and its signature may change in
  /// the future.
  ///
  /// @param valid Output pointer to set with validity of the object content
  /// @param buf The contents to validate
  /// @param len The length of the buffer
  /// @param object_type The type of the object in the buffer
  /// @param oid_type The object ID type for the OIDs in the given buffer
  /// @return 0 on success or an error code
  int git_object_rawcontent_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> buf,
    int len,
    git_object_t object_type,
    git_oid_t oid_type,
  ) {
    return _git_object_rawcontent_is_valid(
      valid,
      buf,
      len,
      object_type.value,
      oid_type.value,
    );
  }

  late final _git_object_rawcontent_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Int,
              ffi.UnsignedInt)>>('git_object_rawcontent_is_valid');
  late final _git_object_rawcontent_is_valid =
      _git_object_rawcontent_is_validPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>, int, int, int)>();

  /// Lookup a commit object from a repository.
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @return 0 or an error code
  int git_commit_lookup(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_commit_lookup(
      commit,
      repo,
      id,
    );
  }

  late final _git_commit_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_commit_lookup');
  late final _git_commit_lookup = _git_commit_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a commit object from a repository, given a prefix of its
  /// identifier (short id).
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_commit_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_commit_lookup_prefix(
      commit,
      repo,
      id,
      len,
    );
  }

  late final _git_commit_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_commit_lookup_prefix');
  late final _git_commit_lookup_prefix =
      _git_commit_lookup_prefixPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open commit
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a commit. Failure to do so will cause a memory leak.
  ///
  /// @param commit the commit to close
  void git_commit_free(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_free(
      commit,
    );
  }

  late final _git_commit_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_commit>)>>(
          'git_commit_free');
  late final _git_commit_free =
      _git_commit_freePtr.asFunction<void Function(ffi.Pointer<git_commit>)>();

  /// Get the id of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return object identity for the commit.
  ffi.Pointer<git_oid> git_commit_id(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_id(
      commit,
    );
  }

  late final _git_commit_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_commit>)>>('git_commit_id');
  late final _git_commit_id = _git_commit_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>)>();

  /// Get the repository that contains the commit.
  ///
  /// @param commit A previously loaded commit.
  /// @return Repository that contains this commit.
  ffi.Pointer<git_repository> git_commit_owner(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_owner(
      commit,
    );
  }

  late final _git_commit_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_commit>)>>('git_commit_owner');
  late final _git_commit_owner = _git_commit_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_commit>)>();

  /// Get the encoding for the message of a commit,
  /// as a string representing a standard encoding name.
  ///
  /// The encoding may be NULL if the `encoding` header
  /// in the commit is missing; in that case UTF-8 is assumed.
  ///
  /// @param commit a previously loaded commit.
  /// @return NULL, or the encoding
  ffi.Pointer<ffi.Char> git_commit_message_encoding(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message_encoding(
      commit,
    );
  }

  late final _git_commit_message_encodingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_message_encoding');
  late final _git_commit_message_encoding = _git_commit_message_encodingPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the full message of a commit.
  ///
  /// The returned message will be slightly prettified by removing any
  /// potential leading newlines.
  ///
  /// @param commit a previously loaded commit.
  /// @return the message of a commit
  ffi.Pointer<ffi.Char> git_commit_message(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message(
      commit,
    );
  }

  late final _git_commit_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_message');
  late final _git_commit_message = _git_commit_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the full raw message of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the raw message of a commit
  ffi.Pointer<ffi.Char> git_commit_message_raw(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message_raw(
      commit,
    );
  }

  late final _git_commit_message_rawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_message_raw');
  late final _git_commit_message_raw = _git_commit_message_rawPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the short "summary" of the git commit message.
  ///
  /// The returned message is the summary of the commit, comprising the
  /// first paragraph of the message with whitespace trimmed and squashed.
  ///
  /// @param commit a previously loaded commit.
  /// @return the summary of a commit or NULL on error
  ffi.Pointer<ffi.Char> git_commit_summary(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_summary(
      commit,
    );
  }

  late final _git_commit_summaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_summary');
  late final _git_commit_summary = _git_commit_summaryPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the long "body" of the git commit message.
  ///
  /// The returned message is the body of the commit, comprising
  /// everything but the first paragraph of the message. Leading and
  /// trailing whitespaces are trimmed.
  ///
  /// @param commit a previously loaded commit.
  /// @return the body of a commit or NULL when no the message only
  /// consists of a summary
  ffi.Pointer<ffi.Char> git_commit_body(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_body(
      commit,
    );
  }

  late final _git_commit_bodyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_body');
  late final _git_commit_body = _git_commit_bodyPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the commit time (i.e. committer time) of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the time of a commit
  int git_commit_time(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_time(
      commit,
    );
  }

  late final _git_commit_timePtr =
      _lookup<ffi.NativeFunction<git_time_t Function(ffi.Pointer<git_commit>)>>(
          'git_commit_time');
  late final _git_commit_time =
      _git_commit_timePtr.asFunction<int Function(ffi.Pointer<git_commit>)>();

  /// Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return positive or negative timezone offset, in minutes from UTC
  int git_commit_time_offset(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_time_offset(
      commit,
    );
  }

  late final _git_commit_time_offsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_commit>)>>(
          'git_commit_time_offset');
  late final _git_commit_time_offset = _git_commit_time_offsetPtr
      .asFunction<int Function(ffi.Pointer<git_commit>)>();

  /// Get the committer of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the committer of a commit
  ffi.Pointer<git_signature> git_commit_committer(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_committer(
      commit,
    );
  }

  late final _git_commit_committerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_commit>)>>('git_commit_committer');
  late final _git_commit_committer = _git_commit_committerPtr.asFunction<
      ffi.Pointer<git_signature> Function(ffi.Pointer<git_commit>)>();

  /// Get the author of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the author of a commit
  ffi.Pointer<git_signature> git_commit_author(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_author(
      commit,
    );
  }

  late final _git_commit_authorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_commit>)>>('git_commit_author');
  late final _git_commit_author = _git_commit_authorPtr.asFunction<
      ffi.Pointer<git_signature> Function(ffi.Pointer<git_commit>)>();

  /// Get the committer of a commit, using the mailmap to map names and email
  /// addresses to canonical real names and email addresses.
  ///
  /// Call `git_signature_free` to free the signature.
  ///
  /// @param out a pointer to store the resolved signature.
  /// @param commit a previously loaded commit.
  /// @param mailmap the mailmap to resolve with. (may be NULL)
  /// @return 0 or an error code
  int git_commit_committer_with_mailmap(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_mailmap> mailmap,
  ) {
    return _git_commit_committer_with_mailmap(
      out,
      commit,
      mailmap,
    );
  }

  late final _git_commit_committer_with_mailmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_mailmap>)>>('git_commit_committer_with_mailmap');
  late final _git_commit_committer_with_mailmap =
      _git_commit_committer_with_mailmapPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>, ffi.Pointer<git_mailmap>)>();

  /// Get the author of a commit, using the mailmap to map names and email
  /// addresses to canonical real names and email addresses.
  ///
  /// Call `git_signature_free` to free the signature.
  ///
  /// @param out a pointer to store the resolved signature.
  /// @param commit a previously loaded commit.
  /// @param mailmap the mailmap to resolve with. (may be NULL)
  /// @return 0 or an error code
  int git_commit_author_with_mailmap(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_mailmap> mailmap,
  ) {
    return _git_commit_author_with_mailmap(
      out,
      commit,
      mailmap,
    );
  }

  late final _git_commit_author_with_mailmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_mailmap>)>>('git_commit_author_with_mailmap');
  late final _git_commit_author_with_mailmap =
      _git_commit_author_with_mailmapPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>, ffi.Pointer<git_mailmap>)>();

  /// Get the full raw text of the commit header.
  ///
  /// @param commit a previously loaded commit
  /// @return the header text of the commit
  ffi.Pointer<ffi.Char> git_commit_raw_header(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_raw_header(
      commit,
    );
  }

  late final _git_commit_raw_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_raw_header');
  late final _git_commit_raw_header = _git_commit_raw_headerPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the tree pointed to by a commit.
  ///
  /// @param tree_out pointer where to store the tree object
  /// @param commit a previously loaded commit.
  /// @return 0 or an error code
  int git_commit_tree(
    ffi.Pointer<ffi.Pointer<git_tree>> tree_out,
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_tree(
      tree_out,
      commit,
    );
  }

  late final _git_commit_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_commit>)>>('git_commit_tree');
  late final _git_commit_tree = _git_commit_treePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_tree>>, ffi.Pointer<git_commit>)>();

  /// Get the id of the tree pointed to by a commit. This differs from
  /// `git_commit_tree` in that no attempts are made to fetch an object
  /// from the ODB.
  ///
  /// @param commit a previously loaded commit.
  /// @return the id of tree pointed to by commit.
  ffi.Pointer<git_oid> git_commit_tree_id(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_tree_id(
      commit,
    );
  }

  late final _git_commit_tree_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_commit>)>>('git_commit_tree_id');
  late final _git_commit_tree_id = _git_commit_tree_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>)>();

  /// Get the number of parents of this commit
  ///
  /// @param commit a previously loaded commit.
  /// @return integer of count of parents
  int git_commit_parentcount(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_parentcount(
      commit,
    );
  }

  late final _git_commit_parentcountPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<git_commit>)>>(
      'git_commit_parentcount');
  late final _git_commit_parentcount = _git_commit_parentcountPtr
      .asFunction<int Function(ffi.Pointer<git_commit>)>();

  /// Get the specified parent of the commit.
  ///
  /// @param out Pointer where to store the parent commit
  /// @param commit a previously loaded commit.
  /// @param n the position of the parent (from 0 to `parentcount`)
  /// @return 0 or an error code
  int git_commit_parent(
    ffi.Pointer<ffi.Pointer<git_commit>> out,
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_parent(
      out,
      commit,
      n,
    );
  }

  late final _git_commit_parentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>, ffi.UnsignedInt)>>('git_commit_parent');
  late final _git_commit_parent = _git_commit_parentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
          ffi.Pointer<git_commit>, int)>();

  /// Get the oid of a specified parent for a commit. This is different from
  /// `git_commit_parent`, which will attempt to load the parent commit from
  /// the ODB.
  ///
  /// @param commit a previously loaded commit.
  /// @param n the position of the parent (from 0 to `parentcount`)
  /// @return the id of the parent, NULL on error.
  ffi.Pointer<git_oid> git_commit_parent_id(
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_parent_id(
      commit,
      n,
    );
  }

  late final _git_commit_parent_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>,
              ffi.UnsignedInt)>>('git_commit_parent_id');
  late final _git_commit_parent_id = _git_commit_parent_idPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>, int)>();

  /// Get the commit object that is the <n>th generation ancestor
  /// of the named commit object, following only the first parents.
  /// The returned commit has to be freed by the caller.
  ///
  /// Passing `0` as the generation number returns another instance of the
  /// base commit itself.
  ///
  /// @param ancestor Pointer where to store the ancestor commit
  /// @param commit a previously loaded commit.
  /// @param n the requested generation
  /// @return 0 on success; GIT_ENOTFOUND if no matching ancestor exists
  /// or an error code
  int git_commit_nth_gen_ancestor(
    ffi.Pointer<ffi.Pointer<git_commit>> ancestor,
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_nth_gen_ancestor(
      ancestor,
      commit,
      n,
    );
  }

  late final _git_commit_nth_gen_ancestorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>,
              ffi.UnsignedInt)>>('git_commit_nth_gen_ancestor');
  late final _git_commit_nth_gen_ancestor =
      _git_commit_nth_gen_ancestorPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>, int)>();

  /// Get an arbitrary header field
  ///
  /// @param out the buffer to fill; existing content will be
  /// overwritten
  /// @param commit the commit to look in
  /// @param field the header field to return
  /// @return 0 on succeess, GIT_ENOTFOUND if the field does not exist,
  /// or an error code
  int git_commit_header_field(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<ffi.Char> field,
  ) {
    return _git_commit_header_field(
      out,
      commit,
      field,
    );
  }

  late final _git_commit_header_fieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
              ffi.Pointer<ffi.Char>)>>('git_commit_header_field');
  late final _git_commit_header_field = _git_commit_header_fieldPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
          ffi.Pointer<ffi.Char>)>();

  /// Extract the signature from a commit
  ///
  /// If the id is not for a commit, the error class will be
  /// `GIT_ERROR_INVALID`. If the commit does not have a signature, the
  /// error class will be `GIT_ERROR_OBJECT`.
  ///
  /// @param signature the signature block; existing content will be
  /// overwritten
  /// @param signed_data signed data; this is the commit contents minus the signature block;
  /// existing content will be overwritten
  /// @param repo the repository in which the commit exists
  /// @param commit_id the commit from which to extract the data
  /// @param field the name of the header field containing the signature
  /// block; pass `NULL` to extract the default 'gpgsig'
  /// @return 0 on success, GIT_ENOTFOUND if the id is not for a commit
  /// or the commit does not have a signature.
  int git_commit_extract_signature(
    ffi.Pointer<git_buf> signature,
    ffi.Pointer<git_buf> signed_data,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit_id,
    ffi.Pointer<ffi.Char> field,
  ) {
    return _git_commit_extract_signature(
      signature,
      signed_data,
      repo,
      commit_id,
      field,
    );
  }

  late final _git_commit_extract_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_commit_extract_signature');
  late final _git_commit_extract_signature =
      _git_commit_extract_signaturePtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Create new commit in the repository from a list of `git_object` pointers
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int git_commit_create(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _git_commit_create(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _git_commit_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<git_commit>>)>>('git_commit_create');
  late final _git_commit_create = _git_commit_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_tree>,
          int,
          ffi.Pointer<ffi.Pointer<git_commit>>)>();

  /// Create new commit in the repository using a variable argument list.
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// The parents for the commit are specified as a variable list of pointers
  /// to `const git_commit *`. Note that this is a convenience method which may
  /// not be safe to export for certain languages or compilers
  ///
  /// All other parameters remain the same as `git_commit_create()`.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int git_commit_create_v(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
  ) {
    return _git_commit_create_v(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
    );
  }

  late final _git_commit_create_vPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>,
              ffi.Size)>>('git_commit_create_v');
  late final _git_commit_create_v = _git_commit_create_vPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_tree>,
          int)>();

  /// Commits the staged changes in the repository; this is a near analog to
  /// `git commit -m message`.
  ///
  /// By default, empty commits are not allowed.
  ///
  /// @param id pointer to store the new commit's object id
  /// @param repo repository to commit changes in
  /// @param message the commit message
  /// @param opts options for creating the commit
  /// @return 0 on success, GIT_EUNCHANGED if there were no changes to commit, or an error code
  int git_commit_create_from_stage(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_commit_create_options> opts,
  ) {
    return _git_commit_create_from_stage(
      id,
      repo,
      message,
      opts,
    );
  }

  late final _git_commit_create_from_stagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_oid>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_commit_create_options>)>>(
      'git_commit_create_from_stage');
  late final _git_commit_create_from_stage =
      _git_commit_create_from_stagePtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_commit_create_options>)>();

  /// Amend an existing commit by replacing only non-NULL values.
  ///
  /// This creates a new commit that is exactly the same as the old commit,
  /// except that any non-NULL values will be updated.  The new commit has
  /// the same parents as the old commit.
  ///
  /// The `update_ref` value works as in the regular `git_commit_create()`,
  /// updating the ref to point to the newly rewritten commit.  If you want
  /// to amend a commit that is not currently the tip of the branch and then
  /// rewrite the following commits to reach a ref, pass this as NULL and
  /// update the rest of the commit chain and ref separately.
  ///
  /// Unlike `git_commit_create()`, the `author`, `committer`, `message`,
  /// `message_encoding`, and `tree` parameters can be NULL in which case this
  /// will use the values from the original `commit_to_amend`.
  ///
  /// All parameters have the same meanings as in `git_commit_create()`.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param commit_to_amend The commit to amend
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int git_commit_amend(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_commit> commit_to_amend,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_commit_amend(
      id,
      commit_to_amend,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
    );
  }

  late final _git_commit_amendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>)>>('git_commit_amend');
  late final _git_commit_amend = _git_commit_amendPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_tree>)>();

  /// Create a commit and write it into a buffer
  ///
  /// Create a commit as with `git_commit_create()` but instead of
  /// writing it to the objectdb, write the contents of the object into a
  /// buffer.
  ///
  /// @param out the buffer into which to write the commit object content
  ///
  /// @param repo Repository where the referenced tree and parents live
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  int git_commit_create_buffer(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _git_commit_create_buffer(
      out,
      repo,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _git_commit_create_bufferPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_buf>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_tree>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<git_commit>>)>>(
      'git_commit_create_buffer');
  late final _git_commit_create_buffer =
      _git_commit_create_bufferPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>,
              int,
              ffi.Pointer<ffi.Pointer<git_commit>>)>();

  /// Create a commit object from the given buffer and signature
  ///
  /// Given the unsigned commit object's contents, its signature and the
  /// header field in which to store the signature, attach the signature
  /// to the commit and write it into the given repository.
  ///
  /// @param out the resulting commit id
  /// @param repo the repository to create the commit in.
  /// @param commit_content the content of the unsigned commit object
  /// @param signature the signature to add to the commit. Leave `NULL`
  /// to create a commit without adding a signature field.
  /// @param signature_field which header field should contain this
  /// signature. Leave `NULL` for the default of "gpgsig"
  /// @return 0 or an error code
  int git_commit_create_with_signature(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> commit_content,
    ffi.Pointer<ffi.Char> signature,
    ffi.Pointer<ffi.Char> signature_field,
  ) {
    return _git_commit_create_with_signature(
      out,
      repo,
      commit_content,
      signature,
      signature_field,
    );
  }

  late final _git_commit_create_with_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_commit_create_with_signature');
  late final _git_commit_create_with_signature =
      _git_commit_create_with_signaturePtr.asFunction<
          int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create an in-memory copy of a commit. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the commit
  /// @param source Original commit to copy
  /// @return 0
  int git_commit_dup(
    ffi.Pointer<ffi.Pointer<git_commit>> out,
    ffi.Pointer<git_commit> source,
  ) {
    return _git_commit_dup(
      out,
      source,
    );
  }

  late final _git_commit_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>)>>('git_commit_dup');
  late final _git_commit_dup = _git_commit_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_commit>>, ffi.Pointer<git_commit>)>();

  /// Free the commits contained in a commit array.  This method should
  /// be called on `git_commitarray` objects that were provided by the
  /// library.  Not doing so will result in a memory leak.
  ///
  /// This does not free the `git_commitarray` itself, since the library
  /// will never allocate that object directly itself.
  ///
  /// @param array The git_commitarray that contains commits to free
  void git_commitarray_dispose(
    ffi.Pointer<git_commitarray> array,
  ) {
    return _git_commitarray_dispose(
      array,
    );
  }

  late final _git_commitarray_disposePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_commitarray>)>>(
      'git_commitarray_dispose');
  late final _git_commitarray_dispose = _git_commitarray_disposePtr
      .asFunction<void Function(ffi.Pointer<git_commitarray>)>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param[out] out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int git_repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_repository_open(
      out,
      path,
    );
  }

  late final _git_repository_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>)>>('git_repository_open');
  late final _git_repository_open = _git_repository_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>, ffi.Pointer<ffi.Char>)>();

  /// Open working tree as a repository
  ///
  /// Open the working directory of the working tree as a normal
  /// repository that can then be worked on.
  ///
  /// @param out Output pointer containing opened repository
  /// @param wt Working tree to open
  /// @return 0 or an error code
  int git_repository_open_from_worktree(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_repository_open_from_worktree(
      out,
      wt,
    );
  }

  late final _git_repository_open_from_worktreePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_worktree>)>>('git_repository_open_from_worktree');
  late final _git_repository_open_from_worktree =
      _git_repository_open_from_worktreePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_worktree>)>();

  /// Create a "fake" repository to wrap an object database
  ///
  /// Create a repository object to wrap an object database to be used
  /// with the API when all you have is an object database. This doesn't
  /// have any paths associated with it, so use with care.
  ///
  /// @param out pointer to the repo
  /// @param odb the object database to wrap
  /// @return 0 or an error code
  int git_repository_wrap_odb(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_odb> odb,
  ) {
    return _git_repository_wrap_odb(
      out,
      odb,
    );
  }

  late final _git_repository_wrap_odbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_odb>)>>('git_repository_wrap_odb');
  late final _git_repository_wrap_odb = _git_repository_wrap_odbPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>, ffi.Pointer<git_odb>)>();

  /// Look for a git repository and copy its path in the given buffer.
  /// The lookup start from base_path and walk across parent directories
  /// if nothing has been found. The lookup ends when the first repository
  /// is found, or when reaching a directory referenced in ceiling_dirs
  /// or when the filesystem changes (in case across_fs is true).
  ///
  /// The method will automatically detect if the repository is bare
  /// (if there is a repository).
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param out A pointer to a user-allocated git_buf which will contain
  /// the found path.
  ///
  /// @param start_path The base path where the lookup starts.
  ///
  /// @param across_fs If true, then the lookup will not stop when a
  /// filesystem device change is detected while exploring parent directories.
  ///
  /// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR separated list of
  /// absolute symbolic link free paths. The lookup will stop when any
  /// of this paths is reached. Note that the lookup always performs on
  /// start_path no matter start_path appears in ceiling_dirs ceiling_dirs
  /// might be NULL (which is equivalent to an empty string)
  ///
  /// @return 0 or an error code
  int git_repository_discover(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Char> start_path,
    int across_fs,
    ffi.Pointer<ffi.Char> ceiling_dirs,
  ) {
    return _git_repository_discover(
      out,
      start_path,
      across_fs,
      ceiling_dirs,
    );
  }

  late final _git_repository_discoverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_repository_discover');
  late final _git_repository_discover = _git_repository_discoverPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Char>)>();

  /// Find and open a repository with extended controls.
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param[out] out Pointer to the repo which will be opened.  This can
  /// actually be NULL if you only want to use the error code to
  /// see if a repo at this path could be opened.
  /// @param path Path to open as git repository.  If the flags
  /// permit "searching", then this can be a path to a subdirectory
  /// inside the working directory of the repository. May be NULL if
  /// flags is GIT_REPOSITORY_OPEN_FROM_ENV.
  /// @param flags A combination of the GIT_REPOSITORY_OPEN flags above.
  /// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR delimited list of path
  /// prefixes at which the search for a containing repository should
  /// terminate.
  /// @return 0 on success, GIT_ENOTFOUND if no repository could be found,
  /// or -1 if there was a repository but open failed for some reason
  /// (such as repo corruption or system errors).
  int git_repository_open_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
    int flags,
    ffi.Pointer<ffi.Char> ceiling_dirs,
  ) {
    return _git_repository_open_ext(
      out,
      path,
      flags,
      ceiling_dirs,
    );
  }

  late final _git_repository_open_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('git_repository_open_ext');
  late final _git_repository_open_ext = _git_repository_open_extPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Open a bare repository on the serverside.
  ///
  /// This is a fast open for bare repositories that will come in handy
  /// if you're e.g. hosting git repositories and need to access them
  /// efficiently
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param[out] out Pointer to the repo which will be opened.
  /// @param bare_path Direct path to the bare repository
  /// @return 0 on success, or an error code
  int git_repository_open_bare(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> bare_path,
  ) {
    return _git_repository_open_bare(
      out,
      bare_path,
    );
  }

  late final _git_repository_open_barePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>)>>('git_repository_open_bare');
  late final _git_repository_open_bare =
      _git_repository_open_barePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>)>();

  /// Free a previously allocated repository
  ///
  /// Note that after a repository is free'd, all the objects it has spawned
  /// will still exist until they are manually closed by the user
  /// with `git_object_free`, but accessing any of the attributes of
  /// an object without a backing repository will result in undefined
  /// behavior
  ///
  /// @param repo repository handle to close. If NULL nothing occurs.
  void git_repository_free(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_free(
      repo,
    );
  }

  late final _git_repository_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_repository>)>>(
      'git_repository_free');
  late final _git_repository_free = _git_repository_freePtr
      .asFunction<void Function(ffi.Pointer<git_repository>)>();

  /// Creates a new Git repository in the given folder.
  ///
  /// TODO:
  /// - Reinit the repository
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param[out] out pointer to the repo which will be created or reinitialized
  /// @param path the path to the repository
  /// @param is_bare if true, a Git repository without a working directory is
  /// created at the pointed path. If false, provided path will be
  /// considered as the working directory into which the .git directory
  /// will be created.
  ///
  /// @return 0 or an error code
  int git_repository_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
    int is_bare,
  ) {
    return _git_repository_init(
      out,
      path,
      is_bare,
    );
  }

  late final _git_repository_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('git_repository_init');
  late final _git_repository_init = _git_repository_initPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Initialize git_repository_init_options structure
  ///
  /// Initializes a `git_repository_init_options` with default values. Equivalent to
  /// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_repository_init_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_repository_init_options_init(
    ffi.Pointer<git_repository_init_options> opts,
    int version,
  ) {
    return _git_repository_init_options_init(
      opts,
      version,
    );
  }

  late final _git_repository_init_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository_init_options>,
              ffi.UnsignedInt)>>('git_repository_init_options_init');
  late final _git_repository_init_options_init =
      _git_repository_init_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_repository_init_options>, int)>();

  /// Create a new Git repository in the given folder with extended controls.
  ///
  /// This will initialize a new git repository (creating the repo_path
  /// if requested by flags) and working directory as needed.  It will
  /// auto-detect the case sensitivity of the file system and if the
  /// file system supports file mode bits correctly.
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param out Pointer to the repo which will be created or reinitialized.
  /// @param repo_path The path to the repository.
  /// @param opts Pointer to git_repository_init_options struct.
  /// @return 0 or an error code on failure.
  int git_repository_init_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> repo_path,
    ffi.Pointer<git_repository_init_options> opts,
  ) {
    return _git_repository_init_ext(
      out,
      repo_path,
      opts,
    );
  }

  late final _git_repository_init_extPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_repository>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_repository_init_options>)>>(
      'git_repository_init_ext');
  late final _git_repository_init_ext = _git_repository_init_extPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_repository_init_options>)>();

  /// Retrieve and resolve the reference pointed at by HEAD.
  ///
  /// The returned `git_reference` will be owned by caller and
  /// `git_reference_free()` must be called when done with it to release the
  /// allocated memory and prevent a leak.
  ///
  /// @param[out] out pointer to the reference which will be retrieved
  /// @param repo a repository object
  ///
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
  int git_repository_head(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head(
      out,
      repo,
    );
  }

  late final _git_repository_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>)>>('git_repository_head');
  late final _git_repository_head = _git_repository_headPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>)>();

  /// Retrieve the referenced HEAD for the worktree
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  /// @param name name of the worktree to retrieve HEAD for
  /// @return 0 when successful, error-code otherwise
  int git_repository_head_for_worktree(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_repository_head_for_worktree(
      out,
      repo,
      name,
    );
  }

  late final _git_repository_head_for_worktreePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_repository_head_for_worktree');
  late final _git_repository_head_for_worktree =
      _git_repository_head_for_worktreePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Check if a repository's HEAD is detached
  ///
  /// A repository's HEAD is detached when it points directly to a commit
  /// instead of a branch.
  ///
  /// @param repo Repo to test
  /// @return 1 if HEAD is detached, 0 if it's not; error code if there
  /// was an error.
  int git_repository_head_detached(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_detached(
      repo,
    );
  }

  late final _git_repository_head_detachedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_head_detached');
  late final _git_repository_head_detached = _git_repository_head_detachedPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Check if a worktree's HEAD is detached
  ///
  /// A worktree's HEAD is detached when it points directly to a
  /// commit instead of a branch.
  ///
  /// @param repo a repository object
  /// @param name name of the worktree to retrieve HEAD for
  /// @return 1 if HEAD is detached, 0 if its not; error code if
  /// there was an error
  int git_repository_head_detached_for_worktree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_repository_head_detached_for_worktree(
      repo,
      name,
    );
  }

  late final _git_repository_head_detached_for_worktreePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>>(
      'git_repository_head_detached_for_worktree');
  late final _git_repository_head_detached_for_worktree =
      _git_repository_head_detached_for_worktreePtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Check if the current branch is unborn
  ///
  /// An unborn branch is one named from HEAD but which doesn't exist in
  /// the refs namespace, because it doesn't have any commit to point to.
  ///
  /// @param repo Repo to test
  /// @return 1 if the current branch is unborn, 0 if it's not; error
  /// code if there was an error
  int git_repository_head_unborn(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_unborn(
      repo,
    );
  }

  late final _git_repository_head_unbornPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_head_unborn');
  late final _git_repository_head_unborn = _git_repository_head_unbornPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Check if a repository is empty
  ///
  /// An empty repository has just been initialized and contains no references
  /// apart from HEAD, which must be pointing to the unborn master branch,
  /// or the branch specified for the repository in the `init.defaultBranch`
  /// configuration variable.
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is empty, 0 if it isn't, error code
  /// if the repository is corrupted
  int git_repository_is_empty(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_empty(
      repo,
    );
  }

  late final _git_repository_is_emptyPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_empty');
  late final _git_repository_is_empty = _git_repository_is_emptyPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Get the location of a specific repository file or directory
  ///
  /// This function will retrieve the path of a specific repository
  /// item. It will thereby honor things like the repository's
  /// common directory, gitdir, etc. In case a file path cannot
  /// exist for a given item (e.g. the working directory of a bare
  /// repository), GIT_ENOTFOUND is returned.
  ///
  /// @param out Buffer to store the path at
  /// @param repo Repository to get path for
  /// @param item The repository item for which to retrieve the path
  /// @return 0, GIT_ENOTFOUND if the path cannot exist or an error code
  int git_repository_item_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    git_repository_item_t item,
  ) {
    return _git_repository_item_path(
      out,
      repo,
      item.value,
    );
  }

  late final _git_repository_item_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.UnsignedInt)>>('git_repository_item_path');
  late final _git_repository_item_path =
      _git_repository_item_pathPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>, ffi.Pointer<git_repository>, int)>();

  /// Get the path of this repository
  ///
  /// This is the path of the `.git` folder for normal repositories,
  /// or of the repository itself for bare repositories.
  ///
  /// @param repo A repository object
  /// @return the path to the repository
  ffi.Pointer<ffi.Char> git_repository_path(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_path(
      repo,
    );
  }

  late final _git_repository_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_path');
  late final _git_repository_path = _git_repository_pathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Get the path of the working directory for this repository
  ///
  /// If the repository is bare, this function will always return
  /// NULL.
  ///
  /// @param repo A repository object
  /// @return the path to the working dir, if it exists
  ffi.Pointer<ffi.Char> git_repository_workdir(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_workdir(
      repo,
    );
  }

  late final _git_repository_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_workdir');
  late final _git_repository_workdir = _git_repository_workdirPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Get the path of the shared common directory for this repository.
  ///
  /// If the repository is bare, it is the root directory for the repository.
  /// If the repository is a worktree, it is the parent repo's gitdir.
  /// Otherwise, it is the gitdir.
  ///
  /// @param repo A repository object
  /// @return the path to the common dir
  ffi.Pointer<ffi.Char> git_repository_commondir(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_commondir(
      repo,
    );
  }

  late final _git_repository_commondirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_commondir');
  late final _git_repository_commondir =
      _git_repository_commondirPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Set the path to the working directory for this repository
  ///
  /// The working directory doesn't need to be the same one
  /// that contains the `.git` folder for this repository.
  ///
  /// If this repository is bare, setting its working directory
  /// will turn it into a normal repository, capable of performing
  /// all the common workdir operations (checkout, status, index
  /// manipulation, etc).
  ///
  /// @param repo A repository object
  /// @param workdir The path to a working directory
  /// @param update_gitlink Create/update gitlink in workdir and set config
  /// "core.worktree" (if workdir is not the parent of the .git directory)
  /// @return 0, or an error code
  int git_repository_set_workdir(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> workdir,
    int update_gitlink,
  ) {
    return _git_repository_set_workdir(
      repo,
      workdir,
      update_gitlink,
    );
  }

  late final _git_repository_set_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_repository_set_workdir');
  late final _git_repository_set_workdir =
      _git_repository_set_workdirPtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Check if a repository is bare
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is bare, 0 otherwise.
  int git_repository_is_bare(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_bare(
      repo,
    );
  }

  late final _git_repository_is_barePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_bare');
  late final _git_repository_is_bare = _git_repository_is_barePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Check if a repository is a linked work tree
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is a linked work tree, 0 otherwise.
  int git_repository_is_worktree(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_worktree(
      repo,
    );
  }

  late final _git_repository_is_worktreePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_worktree');
  late final _git_repository_is_worktree = _git_repository_is_worktreePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Get the configuration file for this repository.
  ///
  /// If a configuration file has not been set, the default
  /// config set for the repository will be returned, including
  /// global and system configurations (if they are available).
  ///
  /// The configuration file must be freed once it's no longer
  /// being used by the user.
  ///
  /// @param out Pointer to store the loaded configuration
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_config(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_config(
      out,
      repo,
    );
  }

  late final _git_repository_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_repository>)>>('git_repository_config');
  late final _git_repository_config = _git_repository_configPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<git_repository>)>();

  /// Get a snapshot of the repository's configuration
  ///
  /// Convenience function to take a snapshot from the repository's
  /// configuration.  The contents of this snapshot will not change,
  /// even if the underlying config files are modified.
  ///
  /// The configuration file must be freed once it's no longer
  /// being used by the user.
  ///
  /// @param out Pointer to store the loaded configuration
  /// @param repo the repository
  /// @return 0, or an error code
  int git_repository_config_snapshot(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_config_snapshot(
      out,
      repo,
    );
  }

  late final _git_repository_config_snapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_repository>)>>('git_repository_config_snapshot');
  late final _git_repository_config_snapshot =
      _git_repository_config_snapshotPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_repository>)>();

  /// Get the Object Database for this repository.
  ///
  /// If a custom ODB has not been set, the default
  /// database for the repository will be returned (the one
  /// located in `.git/objects`).
  ///
  /// The ODB must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param[out] out Pointer to store the loaded ODB
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_odb(
    ffi.Pointer<ffi.Pointer<git_odb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_odb(
      out,
      repo,
    );
  }

  late final _git_repository_odbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>>,
              ffi.Pointer<git_repository>)>>('git_repository_odb');
  late final _git_repository_odb = _git_repository_odbPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb>>, ffi.Pointer<git_repository>)>();

  /// Get the Reference Database Backend for this repository.
  ///
  /// If a custom refsdb has not been set, the default database for
  /// the repository will be returned (the one that manipulates loose
  /// and packed references in the `.git` directory).
  ///
  /// The refdb must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param[out] out Pointer to store the loaded refdb
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_refdb(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_refdb(
      out,
      repo,
    );
  }

  late final _git_repository_refdbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>>,
              ffi.Pointer<git_repository>)>>('git_repository_refdb');
  late final _git_repository_refdb = _git_repository_refdbPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refdb>>, ffi.Pointer<git_repository>)>();

  /// Get the Index file for this repository.
  ///
  /// If a custom index has not been set, the default
  /// index for the repository will be returned (the one
  /// located in `.git/index`).
  ///
  /// The index must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param[out] out Pointer to store the loaded index
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_index(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_index(
      out,
      repo,
    );
  }

  late final _git_repository_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>)>>('git_repository_index');
  late final _git_repository_index = _git_repository_indexPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>, ffi.Pointer<git_repository>)>();

  /// Retrieve git's prepared message
  ///
  /// Operations such as git revert/cherry-pick/merge with the -n option
  /// stop just short of creating a commit with the changes and save
  /// their prepared message in .git/MERGE_MSG so the next git-commit
  /// execution can present it to the user for them to amend if they
  /// wish.
  ///
  /// Use this function to get the contents of this file. Don't forget to
  /// remove the file after you create the commit.
  ///
  /// @param out git_buf to write data into
  /// @param repo Repository to read prepared message from
  /// @return 0, GIT_ENOTFOUND if no message exists or an error code
  int git_repository_message(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_message(
      out,
      repo,
    );
  }

  late final _git_repository_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>)>>('git_repository_message');
  late final _git_repository_message = _git_repository_messagePtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>)>();

  /// Remove git's prepared message.
  ///
  /// Remove the message that `git_repository_message` retrieves.
  ///
  /// @param repo Repository to remove prepared message from.
  /// @return 0 or an error code.
  int git_repository_message_remove(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_message_remove(
      repo,
    );
  }

  late final _git_repository_message_removePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_message_remove');
  late final _git_repository_message_remove = _git_repository_message_removePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Remove all the metadata associated with an ongoing command like merge,
  /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
  ///
  /// @param repo A repository object
  /// @return 0 on success, or error
  int git_repository_state_cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state_cleanup(
      repo,
    );
  }

  late final _git_repository_state_cleanupPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_state_cleanup');
  late final _git_repository_state_cleanup = _git_repository_state_cleanupPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Invoke 'callback' for each entry in the given FETCH_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no FETCH_HEAD file, or other error code.
  int git_repository_fetchhead_foreach(
    ffi.Pointer<git_repository> repo,
    git_repository_fetchhead_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_repository_fetchhead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_repository_fetchhead_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_repository_fetchhead_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_repository_fetchhead_foreach');
  late final _git_repository_fetchhead_foreach =
      _git_repository_fetchhead_foreachPtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              git_repository_fetchhead_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// If a merge is in progress, invoke 'callback' for each commit ID in the
  /// MERGE_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no MERGE_HEAD file, or other error code.
  int git_repository_mergehead_foreach(
    ffi.Pointer<git_repository> repo,
    git_repository_mergehead_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_repository_mergehead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_repository_mergehead_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_repository_mergehead_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_repository_mergehead_foreach');
  late final _git_repository_mergehead_foreach =
      _git_repository_mergehead_foreachPtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              git_repository_mergehead_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Calculate hash of file using repository filtering rules.
  ///
  /// If you simply want to calculate the hash of a file on disk with no filters,
  /// you can just use the `git_odb_hashfile()` API.  However, if you want to
  /// hash a file in the repository and you want to apply filtering rules (e.g.
  /// crlf filters) before generating the SHA, then use this function.
  ///
  /// Note: if the repository has `core.safecrlf` set to fail and the
  /// filtering triggers that failure, then this function will return an
  /// error and not calculate the hash of the file.
  ///
  /// @param out Output value of calculated SHA
  /// @param repo Repository pointer
  /// @param path Path to file on disk whose contents should be hashed.  This
  /// may be an absolute path or a relative path, in which case it
  /// will be treated as a path within the working directory.
  /// @param type The object type to hash as (e.g. GIT_OBJECT_BLOB)
  /// @param as_path The path to use to look up filtering rules. If this is
  /// an empty string then no filters will be applied when
  /// calculating the hash. If this is `NULL` and the `path`
  /// parameter is a file within the repository's working
  /// directory, then the `path` will be used.
  /// @return 0 on success, or an error code
  int git_repository_hashfile(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
    git_object_t type,
    ffi.Pointer<ffi.Char> as_path,
  ) {
    return _git_repository_hashfile(
      out,
      repo,
      path,
      type.value,
      as_path,
    );
  }

  late final _git_repository_hashfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_repository_hashfile');
  late final _git_repository_hashfile = _git_repository_hashfilePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Make the repository HEAD point to the specified reference.
  ///
  /// If the provided reference points to a Tree or a Blob, the HEAD is
  /// unaltered and -1 is returned.
  ///
  /// If the provided reference points to a branch, the HEAD will point
  /// to that branch, staying attached, or become attached if it isn't yet.
  /// If the branch doesn't exist yet, no error will be return. The HEAD
  /// will then be attached to an unborn branch.
  ///
  /// Otherwise, the HEAD will be detached and will directly point to
  /// the Commit.
  ///
  /// @param repo Repository pointer
  /// @param refname Canonical name of the reference the HEAD should point at
  /// @return 0 on success, or an error code
  int git_repository_set_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_repository_set_head(
      repo,
      refname,
    );
  }

  late final _git_repository_set_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_repository_set_head');
  late final _git_repository_set_head = _git_repository_set_headPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Make the repository HEAD directly point to the Commit.
  ///
  /// If the provided committish cannot be found in the repository, the HEAD
  /// is unaltered and GIT_ENOTFOUND is returned.
  ///
  /// If the provided committish cannot be peeled into a commit, the HEAD
  /// is unaltered and -1 is returned.
  ///
  /// Otherwise, the HEAD will eventually be detached and will directly point to
  /// the peeled Commit.
  ///
  /// @param repo Repository pointer
  /// @param committish Object id of the Commit the HEAD should point to
  /// @return 0 on success, or an error code
  int git_repository_set_head_detached(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> committish,
  ) {
    return _git_repository_set_head_detached(
      repo,
      committish,
    );
  }

  late final _git_repository_set_head_detachedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_repository_set_head_detached');
  late final _git_repository_set_head_detached =
      _git_repository_set_head_detachedPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Make the repository HEAD directly point to the Commit.
  ///
  /// This behaves like `git_repository_set_head_detached()` but takes an
  /// annotated commit, which lets you specify which extended sha syntax
  /// string was specified by a user, allowing for more exact reflog
  /// messages.
  ///
  /// See the documentation for `git_repository_set_head_detached()`.
  ///
  /// @param repo Repository pointer
  /// @param committish annotated commit to point HEAD to
  /// @return 0 on success, or an error code
  int git_repository_set_head_detached_from_annotated(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> committish,
  ) {
    return _git_repository_set_head_detached_from_annotated(
      repo,
      committish,
    );
  }

  late final _git_repository_set_head_detached_from_annotatedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_repository>,
                  ffi.Pointer<git_annotated_commit>)>>(
      'git_repository_set_head_detached_from_annotated');
  late final _git_repository_set_head_detached_from_annotated =
      _git_repository_set_head_detached_from_annotatedPtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>)>();

  /// Detach the HEAD.
  ///
  /// If the HEAD is already detached and points to a Commit, 0 is returned.
  ///
  /// If the HEAD is already detached and points to a Tag, the HEAD is
  /// updated into making it point to the peeled Commit, and 0 is returned.
  ///
  /// If the HEAD is already detached and points to a non committish, the HEAD is
  /// unaltered, and -1 is returned.
  ///
  /// Otherwise, the HEAD will be detached and point to the peeled Commit.
  ///
  /// @param repo Repository pointer
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch or an error code
  int git_repository_detach_head(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_detach_head(
      repo,
    );
  }

  late final _git_repository_detach_headPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_detach_head');
  late final _git_repository_detach_head = _git_repository_detach_headPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Determines the status of a git repository - ie, whether an operation
  /// (merge, cherry-pick, etc) is in progress.
  ///
  /// @param repo Repository pointer
  /// @return The state of the repository
  int git_repository_state(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state(
      repo,
    );
  }

  late final _git_repository_statePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_state');
  late final _git_repository_state = _git_repository_statePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Sets the active namespace for this Git Repository
  ///
  /// This namespace affects all reference operations for the repo.
  /// See `man gitnamespaces`
  ///
  /// @param repo The repo
  /// @param nmspace The namespace. This should not include the refs
  /// folder, e.g. to namespace all references under `refs/namespaces/foo/`,
  /// use `foo` as the namespace.
  /// @return 0 on success, -1 on error
  int git_repository_set_namespace(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> nmspace,
  ) {
    return _git_repository_set_namespace(
      repo,
      nmspace,
    );
  }

  late final _git_repository_set_namespacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_repository_set_namespace');
  late final _git_repository_set_namespace =
      _git_repository_set_namespacePtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Get the currently active namespace for this repository
  ///
  /// @param repo The repo
  /// @return the active namespace, or NULL if there isn't one
  ffi.Pointer<ffi.Char> git_repository_get_namespace(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_get_namespace(
      repo,
    );
  }

  late final _git_repository_get_namespacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_get_namespace');
  late final _git_repository_get_namespace =
      _git_repository_get_namespacePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Determine if the repository was a shallow clone
  ///
  /// @param repo The repository
  /// @return 1 if shallow, zero if not
  int git_repository_is_shallow(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_shallow(
      repo,
    );
  }

  late final _git_repository_is_shallowPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_shallow');
  late final _git_repository_is_shallow = _git_repository_is_shallowPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Retrieve the configured identity to use for reflogs
  ///
  /// The memory is owned by the repository and must not be freed by the
  /// user.
  ///
  /// @param[out] name where to store the pointer to the name
  /// @param[out] email where to store the pointer to the email
  /// @param repo the repository
  /// @return 0 or an error code
  int git_repository_ident(
    ffi.Pointer<ffi.Pointer<ffi.Char>> name,
    ffi.Pointer<ffi.Pointer<ffi.Char>> email,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_ident(
      name,
      email,
      repo,
    );
  }

  late final _git_repository_identPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>)>>('git_repository_ident');
  late final _git_repository_ident = _git_repository_identPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<git_repository>)>();

  /// Set the identity to be used for writing reflogs
  ///
  /// If both are set, this name and email will be used to write to the
  /// reflog. Pass NULL to unset. When unset, the identity will be taken
  /// from the repository's configuration.
  ///
  /// @param repo the repository to configure
  /// @param name the name to use for the reflog entries
  /// @param email the email to use for the reflog entries
  /// @return 0 or an error code.
  int git_repository_set_ident(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
  ) {
    return _git_repository_set_ident(
      repo,
      name,
      email,
    );
  }

  late final _git_repository_set_identPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_repository_set_ident');
  late final _git_repository_set_ident =
      _git_repository_set_identPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Gets the object type used by this repository.
  ///
  /// @param repo the repository
  /// @return the object id type
  git_oid_t git_repository_oid_type(
    ffi.Pointer<git_repository> repo,
  ) {
    return git_oid_t.fromValue(_git_repository_oid_type(
      repo,
    ));
  }

  late final _git_repository_oid_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<git_repository>)>>('git_repository_oid_type');
  late final _git_repository_oid_type = _git_repository_oid_typePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Gets the parents of the next commit, given the current repository state.
  /// Generally, this is the HEAD commit, except when performing a merge, in
  /// which case it is two or more commits.
  ///
  /// @param commits a `git_commitarray` that will contain the commit parents
  /// @param repo the repository
  /// @return 0 or an error code
  int git_repository_commit_parents(
    ffi.Pointer<git_commitarray> commits,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_commit_parents(
      commits,
      repo,
    );
  }

  late final _git_repository_commit_parentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_commitarray>,
              ffi.Pointer<git_repository>)>>('git_repository_commit_parents');
  late final _git_repository_commit_parents =
      _git_repository_commit_parentsPtr.asFunction<
          int Function(
              ffi.Pointer<git_commitarray>, ffi.Pointer<git_repository>)>();

  /// Creates a `git_annotated_commit` from the given reference.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param[out] out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given reference
  /// @param ref reference to use to lookup the git_annotated_commit
  /// @return 0 on success or error code
  int git_annotated_commit_from_ref(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_annotated_commit_from_ref(
      out,
      repo,
      ref,
    );
  }

  late final _git_annotated_commit_from_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_reference>)>>('git_annotated_commit_from_ref');
  late final _git_annotated_commit_from_ref =
      _git_annotated_commit_from_refPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_reference>)>();

  /// Creates a `git_annotated_commit` from the given fetch head data.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param[out] out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param branch_name name of the (remote) branch
  /// @param remote_url url of the remote
  /// @param id the commit object id of the remote branch
  /// @return 0 on success or error code
  int git_annotated_commit_from_fetchhead(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> branch_name,
    ffi.Pointer<ffi.Char> remote_url,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_annotated_commit_from_fetchhead(
      out,
      repo,
      branch_name,
      remote_url,
      id,
    );
  }

  late final _git_annotated_commit_from_fetchheadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>)>>('git_annotated_commit_from_fetchhead');
  late final _git_annotated_commit_from_fetchhead =
      _git_annotated_commit_from_fetchheadPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>)>();

  /// Creates a `git_annotated_commit` from the given commit id.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// An annotated commit contains information about how it was
  /// looked up, which may be useful for functions like merge or
  /// rebase to provide context to the operation.  For example,
  /// conflict files will include the name of the source or target
  /// branches being merged.  It is therefore preferable to use the
  /// most specific function (eg `git_annotated_commit_from_ref`)
  /// instead of this one when that data is known.
  ///
  /// @param[out] out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param id the commit object id to lookup
  /// @return 0 on success or error code
  int git_annotated_commit_lookup(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_annotated_commit_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_annotated_commit_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_annotated_commit_lookup');
  late final _git_annotated_commit_lookup =
      _git_annotated_commit_lookupPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Creates a `git_annotated_commit` from a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// @param[out] out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param revspec the extended sha syntax string to use to lookup the commit
  /// @return 0 on success or error code
  int git_annotated_commit_from_revspec(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> revspec,
  ) {
    return _git_annotated_commit_from_revspec(
      out,
      repo,
      revspec,
    );
  }

  late final _git_annotated_commit_from_revspecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_annotated_commit_from_revspec');
  late final _git_annotated_commit_from_revspec =
      _git_annotated_commit_from_revspecPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Gets the commit ID that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return commit id
  ffi.Pointer<git_oid> git_annotated_commit_id(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_id(
      commit,
    );
  }

  late final _git_annotated_commit_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_id');
  late final _git_annotated_commit_id = _git_annotated_commit_idPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_annotated_commit>)>();

  /// Get the refname that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return ref name.
  ffi.Pointer<ffi.Char> git_annotated_commit_ref(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_ref(
      commit,
    );
  }

  late final _git_annotated_commit_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_ref');
  late final _git_annotated_commit_ref =
      _git_annotated_commit_refPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_annotated_commit>)>();

  /// Frees a `git_annotated_commit`.
  ///
  /// @param commit annotated commit to free
  void git_annotated_commit_free(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_free(
      commit,
    );
  }

  late final _git_annotated_commit_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_free');
  late final _git_annotated_commit_free = _git_annotated_commit_freePtr
      .asFunction<void Function(ffi.Pointer<git_annotated_commit>)>();

  /// Lookup a tree object from the repository.
  ///
  /// @param[out] out Pointer to the looked up tree
  /// @param repo The repo to use when locating the tree.
  /// @param id Identity of the tree to locate.
  /// @return 0 or an error code
  int git_tree_lookup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tree_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_tree_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_tree_lookup');
  late final _git_tree_lookup = _git_tree_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a tree object from the repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param out pointer to the looked up tree
  /// @param repo the repo to use when locating the tree.
  /// @param id identity of the tree to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_tree_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_tree_lookup_prefix(
      out,
      repo,
      id,
      len,
    );
  }

  late final _git_tree_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_tree_lookup_prefix');
  late final _git_tree_lookup_prefix = _git_tree_lookup_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open tree
  ///
  /// You can no longer use the git_tree pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you stop using a tree to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tree The tree to close
  void git_tree_free(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_free(
      tree,
    );
  }

  late final _git_tree_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_tree>)>>(
          'git_tree_free');
  late final _git_tree_free =
      _git_tree_freePtr.asFunction<void Function(ffi.Pointer<git_tree>)>();

  /// Get the id of a tree.
  ///
  /// @param tree a previously loaded tree.
  /// @return object identity for the tree.
  ffi.Pointer<git_oid> git_tree_id(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_id(
      tree,
    );
  }

  late final _git_tree_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree>)>>('git_tree_id');
  late final _git_tree_id = _git_tree_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree>)>();

  /// Get the repository that contains the tree.
  ///
  /// @param tree A previously loaded tree.
  /// @return Repository that contains this tree.
  ffi.Pointer<git_repository> git_tree_owner(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_owner(
      tree,
    );
  }

  late final _git_tree_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_tree>)>>('git_tree_owner');
  late final _git_tree_owner = _git_tree_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_tree>)>();

  /// Get the number of entries listed in a tree
  ///
  /// @param tree a previously loaded tree.
  /// @return the number of entries in the tree
  int git_tree_entrycount(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_entrycount(
      tree,
    );
  }

  late final _git_tree_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_tree>)>>(
          'git_tree_entrycount');
  late final _git_tree_entrycount =
      _git_tree_entrycountPtr.asFunction<int Function(ffi.Pointer<git_tree>)>();

  /// Lookup a tree entry by its filename
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// @param tree a previously loaded tree.
  /// @param filename the filename of the desired entry
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byname(
    ffi.Pointer<git_tree> tree,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _git_tree_entry_byname(
      tree,
      filename,
    );
  }

  late final _git_tree_entry_bynamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree>,
              ffi.Pointer<ffi.Char>)>>('git_tree_entry_byname');
  late final _git_tree_entry_byname = _git_tree_entry_bynamePtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(
          ffi.Pointer<git_tree>, ffi.Pointer<ffi.Char>)>();

  /// Lookup a tree entry by its position in the tree
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// @param tree a previously loaded tree.
  /// @param idx the position in the entry list
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byindex(
    ffi.Pointer<git_tree> tree,
    int idx,
  ) {
    return _git_tree_entry_byindex(
      tree,
      idx,
    );
  }

  late final _git_tree_entry_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(
              ffi.Pointer<git_tree>, ffi.Size)>>('git_tree_entry_byindex');
  late final _git_tree_entry_byindex = _git_tree_entry_byindexPtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree>, int)>();

  /// Lookup a tree entry by SHA value.
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// Warning: this must examine every entry in the tree, so it is not fast.
  ///
  /// @param tree a previously loaded tree.
  /// @param id the sha being looked for
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byid(
    ffi.Pointer<git_tree> tree,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tree_entry_byid(
      tree,
      id,
    );
  }

  late final _git_tree_entry_byidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree>,
              ffi.Pointer<git_oid>)>>('git_tree_entry_byid');
  late final _git_tree_entry_byid = _git_tree_entry_byidPtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(
          ffi.Pointer<git_tree>, ffi.Pointer<git_oid>)>();

  /// Retrieve a tree entry contained in a tree or in any of its subtrees,
  /// given its relative path.
  ///
  /// Unlike the other lookup functions, the returned tree entry is owned by
  /// the user and must be freed explicitly with `git_tree_entry_free()`.
  ///
  /// @param out Pointer where to store the tree entry
  /// @param root Previously loaded tree which is the root of the relative path
  /// @param path Path to the contained entry
  /// @return 0 on success; GIT_ENOTFOUND if the path does not exist
  int git_tree_entry_bypath(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
    ffi.Pointer<git_tree> root,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_tree_entry_bypath(
      out,
      root,
      path,
    );
  }

  late final _git_tree_entry_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree_entry>>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<ffi.Char>)>>('git_tree_entry_bypath');
  late final _git_tree_entry_bypath = _git_tree_entry_bypathPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>>,
          ffi.Pointer<git_tree>, ffi.Pointer<ffi.Char>)>();

  /// Duplicate a tree entry
  ///
  /// Create a copy of a tree entry. The returned copy is owned by the user,
  /// and must be freed explicitly with `git_tree_entry_free()`.
  ///
  /// @param dest pointer where to store the copy
  /// @param source tree entry to duplicate
  /// @return 0 or an error code
  int git_tree_entry_dup(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> dest,
    ffi.Pointer<git_tree_entry> source,
  ) {
    return _git_tree_entry_dup(
      dest,
      source,
    );
  }

  late final _git_tree_entry_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>>,
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_dup');
  late final _git_tree_entry_dup = _git_tree_entry_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>>,
          ffi.Pointer<git_tree_entry>)>();

  /// Free a user-owned tree entry
  ///
  /// IMPORTANT: This function is only needed for tree entries owned by the
  /// user, such as the ones returned by `git_tree_entry_dup()` or
  /// `git_tree_entry_bypath()`.
  ///
  /// @param entry The entry to free
  void git_tree_entry_free(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_free(
      entry,
    );
  }

  late final _git_tree_entry_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_tree_entry>)>>(
      'git_tree_entry_free');
  late final _git_tree_entry_free = _git_tree_entry_freePtr
      .asFunction<void Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the filename of a tree entry
  ///
  /// @param entry a tree entry
  /// @return the name of the file
  ffi.Pointer<ffi.Char> git_tree_entry_name(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_name(
      entry,
    );
  }

  late final _git_tree_entry_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_name');
  late final _git_tree_entry_name = _git_tree_entry_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the id of the object pointed by the entry
  ///
  /// @param entry a tree entry
  /// @return the oid of the object
  ffi.Pointer<git_oid> git_tree_entry_id(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_id(
      entry,
    );
  }

  late final _git_tree_entry_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_id');
  late final _git_tree_entry_id = _git_tree_entry_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the type of the object pointed by the entry
  ///
  /// @param entry a tree entry
  /// @return the type of the pointed object
  git_object_t git_tree_entry_type(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return git_object_t.fromValue(_git_tree_entry_type(
      entry,
    ));
  }

  late final _git_tree_entry_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_tree_entry>)>>(
      'git_tree_entry_type');
  late final _git_tree_entry_type = _git_tree_entry_typePtr
      .asFunction<int Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the UNIX file attributes of a tree entry
  ///
  /// @param entry a tree entry
  /// @return filemode as an integer
  git_filemode_t git_tree_entry_filemode(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return git_filemode_t.fromValue(_git_tree_entry_filemode(
      entry,
    ));
  }

  late final _git_tree_entry_filemodePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_filemode');
  late final _git_tree_entry_filemode = _git_tree_entry_filemodePtr
      .asFunction<int Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the raw UNIX file attributes of a tree entry
  ///
  /// This function does not perform any normalization and is only useful
  /// if you need to be able to recreate the original tree object.
  ///
  /// @param entry a tree entry
  /// @return filemode as an integer
  git_filemode_t git_tree_entry_filemode_raw(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return git_filemode_t.fromValue(_git_tree_entry_filemode_raw(
      entry,
    ));
  }

  late final _git_tree_entry_filemode_rawPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_filemode_raw');
  late final _git_tree_entry_filemode_raw = _git_tree_entry_filemode_rawPtr
      .asFunction<int Function(ffi.Pointer<git_tree_entry>)>();

  /// Compare two tree entries
  ///
  /// @param e1 first tree entry
  /// @param e2 second tree entry
  /// @return <0 if e1 is before e2, 0 if e1 == e2, >0 if e1 is after e2
  int git_tree_entry_cmp(
    ffi.Pointer<git_tree_entry> e1,
    ffi.Pointer<git_tree_entry> e2,
  ) {
    return _git_tree_entry_cmp(
      e1,
      e2,
    );
  }

  late final _git_tree_entry_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_tree_entry>,
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_cmp');
  late final _git_tree_entry_cmp = _git_tree_entry_cmpPtr.asFunction<
      int Function(ffi.Pointer<git_tree_entry>, ffi.Pointer<git_tree_entry>)>();

  /// Convert a tree entry to the git_object it points to.
  ///
  /// You must call `git_object_free()` on the object when you are done with it.
  ///
  /// @param object_out pointer to the converted object
  /// @param repo repository where to lookup the pointed object
  /// @param entry a tree entry
  /// @return 0 or an error code
  int git_tree_entry_to_object(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_to_object(
      object_out,
      repo,
      entry,
    );
  }

  late final _git_tree_entry_to_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_to_object');
  late final _git_tree_entry_to_object =
      _git_tree_entry_to_objectPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_tree_entry>)>();

  /// Create a new tree builder.
  ///
  /// The tree builder can be used to create or modify trees in memory and
  /// write them as tree objects to the database.
  ///
  /// If the `source` parameter is not NULL, the tree builder will be
  /// initialized with the entries of the given tree.
  ///
  /// If the `source` parameter is NULL, the tree builder will start with no
  /// entries and will have to be filled manually.
  ///
  /// @param out Pointer where to store the tree builder
  /// @param repo Repository in which to store the object
  /// @param source Source tree to initialize the builder (optional)
  /// @return 0 on success; error code otherwise
  int git_treebuilder_new(
    ffi.Pointer<ffi.Pointer<git_treebuilder>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> source,
  ) {
    return _git_treebuilder_new(
      out,
      repo,
      source,
    );
  }

  late final _git_treebuilder_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_treebuilder>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>)>>('git_treebuilder_new');
  late final _git_treebuilder_new = _git_treebuilder_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_treebuilder>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_tree>)>();

  /// Clear all the entries in the builder
  ///
  /// @param bld Builder to clear
  /// @return 0 on success; error code otherwise
  int git_treebuilder_clear(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_clear(
      bld,
    );
  }

  late final _git_treebuilder_clearPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_treebuilder>)>>(
      'git_treebuilder_clear');
  late final _git_treebuilder_clear = _git_treebuilder_clearPtr
      .asFunction<int Function(ffi.Pointer<git_treebuilder>)>();

  /// Get the number of entries listed in a treebuilder
  ///
  /// @param bld a previously loaded treebuilder.
  /// @return the number of entries in the treebuilder
  int git_treebuilder_entrycount(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_entrycount(
      bld,
    );
  }

  late final _git_treebuilder_entrycountPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_treebuilder>)>>(
      'git_treebuilder_entrycount');
  late final _git_treebuilder_entrycount = _git_treebuilder_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_treebuilder>)>();

  /// Free a tree builder
  ///
  /// This will clear all the entries and free to builder.
  /// Failing to free the builder after you're done using it
  /// will result in a memory leak
  ///
  /// @param bld Builder to free
  void git_treebuilder_free(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_free(
      bld,
    );
  }

  late final _git_treebuilder_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_treebuilder>)>>(
      'git_treebuilder_free');
  late final _git_treebuilder_free = _git_treebuilder_freePtr
      .asFunction<void Function(ffi.Pointer<git_treebuilder>)>();

  /// Get an entry from the builder from its filename
  ///
  /// The returned entry is owned by the builder and should
  /// not be freed manually.
  ///
  /// @param bld Tree builder
  /// @param filename Name of the entry
  /// @return pointer to the entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_treebuilder_get(
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _git_treebuilder_get(
      bld,
      filename,
    );
  }

  late final _git_treebuilder_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_treebuilder>,
              ffi.Pointer<ffi.Char>)>>('git_treebuilder_get');
  late final _git_treebuilder_get = _git_treebuilder_getPtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(
          ffi.Pointer<git_treebuilder>, ffi.Pointer<ffi.Char>)>();

  /// Add or update an entry to the builder
  ///
  /// Insert a new entry for `filename` in the builder with the
  /// given attributes.
  ///
  /// If an entry named `filename` already exists, its attributes
  /// will be updated with the given ones.
  ///
  /// The optional pointer `out` can be used to retrieve a pointer to the
  /// newly created/updated entry.  Pass NULL if you do not need it. The
  /// pointer may not be valid past the next operation in this
  /// builder. Duplicate the entry if you want to keep it.
  ///
  /// By default the entry that you are inserting will be checked for
  /// validity; that it exists in the object database and is of the
  /// correct type.  If you do not want this behavior, set the
  /// `GIT_OPT_ENABLE_STRICT_OBJECT_CREATION` library option to false.
  ///
  /// @param out Pointer to store the entry (optional)
  /// @param bld Tree builder
  /// @param filename Filename of the entry
  /// @param id SHA1 oid of the entry
  /// @param filemode Folder attributes of the entry. This parameter must
  /// be valued with one of the following entries: 0040000, 0100644,
  /// 0100755, 0120000 or 0160000.
  /// @return 0 or an error code
  int git_treebuilder_insert(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<git_oid> id,
    git_filemode_t filemode,
  ) {
    return _git_treebuilder_insert(
      out,
      bld,
      filename,
      id,
      filemode.value,
    );
  }

  late final _git_treebuilder_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree_entry>>,
              ffi.Pointer<git_treebuilder>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.UnsignedInt)>>('git_treebuilder_insert');
  late final _git_treebuilder_insert = _git_treebuilder_insertPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_tree_entry>>,
          ffi.Pointer<git_treebuilder>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_oid>,
          int)>();

  /// Remove an entry from the builder by its filename
  ///
  /// @param bld Tree builder
  /// @param filename Filename of the entry to remove
  /// @return 0 or an error code
  int git_treebuilder_remove(
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _git_treebuilder_remove(
      bld,
      filename,
    );
  }

  late final _git_treebuilder_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_treebuilder>,
              ffi.Pointer<ffi.Char>)>>('git_treebuilder_remove');
  late final _git_treebuilder_remove = _git_treebuilder_removePtr.asFunction<
      int Function(ffi.Pointer<git_treebuilder>, ffi.Pointer<ffi.Char>)>();

  /// Selectively remove entries in the tree
  ///
  /// The `filter` callback will be called for each entry in the tree with a
  /// pointer to the entry and the provided `payload`; if the callback returns
  /// non-zero, the entry will be filtered (removed from the builder).
  ///
  /// @param bld Tree builder
  /// @param filter Callback to filter entries
  /// @param payload Extra data to pass to filter callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_treebuilder_filter(
    ffi.Pointer<git_treebuilder> bld,
    git_treebuilder_filter_cb filter,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_treebuilder_filter(
      bld,
      filter,
      payload,
    );
  }

  late final _git_treebuilder_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_treebuilder>,
              git_treebuilder_filter_cb,
              ffi.Pointer<ffi.Void>)>>('git_treebuilder_filter');
  late final _git_treebuilder_filter = _git_treebuilder_filterPtr.asFunction<
      int Function(ffi.Pointer<git_treebuilder>, git_treebuilder_filter_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Write the contents of the tree builder as a tree object
  ///
  /// The tree builder will be written to the given `repo`, and its
  /// identifying SHA1 hash will be stored in the `id` pointer.
  ///
  /// @param id Pointer to store the OID of the newly written tree
  /// @param bld Tree builder to write
  /// @return 0 or an error code
  int git_treebuilder_write(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_write(
      id,
      bld,
    );
  }

  late final _git_treebuilder_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_treebuilder>)>>('git_treebuilder_write');
  late final _git_treebuilder_write = _git_treebuilder_writePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_treebuilder>)>();

  /// Traverse the entries in a tree and its subtrees in post or pre order.
  ///
  /// The entries will be traversed in the specified order, children subtrees
  /// will be automatically loaded as required, and the `callback` will be
  /// called once per entry with the current (relative) root for the entry and
  /// the entry data itself.
  ///
  /// If the callback returns a positive value, the passed entry will be
  /// skipped on the traversal (in pre mode). A negative value stops the walk.
  ///
  /// @param tree The tree to walk
  /// @param mode Traversal mode (pre or post-order)
  /// @param callback Function to call on each tree entry
  /// @param payload Opaque pointer to be passed on each callback
  /// @return 0 or an error code
  int git_tree_walk(
    ffi.Pointer<git_tree> tree,
    git_treewalk_mode mode,
    git_treewalk_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_tree_walk(
      tree,
      mode.value,
      callback,
      payload,
    );
  }

  late final _git_tree_walkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_tree>, ffi.UnsignedInt,
              git_treewalk_cb, ffi.Pointer<ffi.Void>)>>('git_tree_walk');
  late final _git_tree_walk = _git_tree_walkPtr.asFunction<
      int Function(ffi.Pointer<git_tree>, int, git_treewalk_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Create an in-memory copy of a tree. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the tree
  /// @param source Original tree to copy
  /// @return 0
  int git_tree_dup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_tree> source,
  ) {
    return _git_tree_dup(
      out,
      source,
    );
  }

  late final _git_tree_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_tree>)>>('git_tree_dup');
  late final _git_tree_dup = _git_tree_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_tree>>, ffi.Pointer<git_tree>)>();

  /// Create a tree based on another one with the specified modifications
  ///
  /// Given the `baseline` perform the changes described in the list of
  /// `updates` and create a new tree.
  ///
  /// This function is optimized for common file/directory addition, removal and
  /// replacement in trees. It is much more efficient than reading the tree into a
  /// `git_index` and modifying that, but in exchange it is not as flexible.
  ///
  /// Deleting and adding the same entry is undefined behaviour, changing
  /// a tree to a blob or viceversa is not supported.
  ///
  /// @param out id of the new tree
  /// @param repo the repository in which to create the tree, must be the
  /// same as for `baseline`
  /// @param baseline the tree to base these changes on
  /// @param nupdates the number of elements in the update list
  /// @param updates the list of updates to perform
  /// @return 0 or an error code
  int git_tree_create_updated(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> baseline,
    int nupdates,
    ffi.Pointer<git_tree_update> updates,
  ) {
    return _git_tree_create_updated(
      out,
      repo,
      baseline,
      nupdates,
      updates,
    );
  }

  late final _git_tree_create_updatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Size,
              ffi.Pointer<git_tree_update>)>>('git_tree_create_updated');
  late final _git_tree_create_updated = _git_tree_create_updatedPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>, int, ffi.Pointer<git_tree_update>)>();

  /// Free the strings contained in a string array.  This method should
  /// be called on `git_strarray` objects that were provided by the
  /// library.  Not doing so, will result in a memory leak.
  ///
  /// This does not free the `git_strarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array The git_strarray that contains strings to free
  void git_strarray_dispose(
    ffi.Pointer<git_strarray> array,
  ) {
    return _git_strarray_dispose(
      array,
    );
  }

  late final _git_strarray_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_strarray>)>>(
          'git_strarray_dispose');
  late final _git_strarray_dispose = _git_strarray_disposePtr
      .asFunction<void Function(ffi.Pointer<git_strarray>)>();

  /// Lookup a reference by name in a repository.
  ///
  /// The returned reference must be freed by the user.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param[out] out pointer to the looked-up reference
  /// @param repo the repository to look up the reference
  /// @param name the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int git_reference_lookup(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reference_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_reference_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_lookup');
  late final _git_reference_lookup = _git_reference_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Lookup a reference by name and resolve immediately to OID.
  ///
  /// This function provides a quick way to resolve a reference name straight
  /// through to the object id that it refers to.  This avoids having to
  /// allocate or free any `git_reference` objects for simple situations.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param out Pointer to oid to be filled in
  /// @param repo The repository in which to look up the reference
  /// @param name The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int git_reference_name_to_id(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reference_name_to_id(
      out,
      repo,
      name,
    );
  }

  late final _git_reference_name_to_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_name_to_id');
  late final _git_reference_name_to_id =
      _git_reference_name_to_idPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Lookup a reference by DWIMing its short name
  ///
  /// Apply the git precedence rules to the given shorthand to determine
  /// which reference the user is referring to.
  ///
  /// @param out pointer in which to store the reference
  /// @param repo the repository in which to look
  /// @param shorthand the short name for the reference
  /// @return 0 or an error code
  int git_reference_dwim(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> shorthand,
  ) {
    return _git_reference_dwim(
      out,
      repo,
      shorthand,
    );
  }

  late final _git_reference_dwimPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_dwim');
  late final _git_reference_dwim = _git_reference_dwimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Conditionally create a new symbolic reference.
  ///
  /// A symbolic reference is a reference name that refers to another
  /// reference name.  If the other name moves, the symbolic name will move,
  /// too.  As a simple example, the "HEAD" reference might refer to
  /// "refs/heads/master" while on the "master" branch of a repository.
  ///
  /// The symbolic reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// It will return GIT_EMODIFIED if the reference's value at the time
  /// of updating does not match the one passed through `current_value`
  /// (i.e. if the ref has changed since the user read it).
  ///
  /// If `current_value` is all zeros, this function will return GIT_EMODIFIED
  /// if the ref already exists.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param target The target of the reference
  /// @param force Overwrite existing references
  /// @param current_value The expected value of the reference when updating
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC, GIT_EMODIFIED or an error code
  int git_reference_symbolic_create_matching(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> target,
    int force,
    ffi.Pointer<ffi.Char> current_value,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_symbolic_create_matching(
      out,
      repo,
      name,
      target,
      force,
      current_value,
      log_message,
    );
  }

  late final _git_reference_symbolic_create_matchingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_reference>>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>)>>(
      'git_reference_symbolic_create_matching');
  late final _git_reference_symbolic_create_matching =
      _git_reference_symbolic_create_matchingPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new symbolic reference.
  ///
  /// A symbolic reference is a reference name that refers to another
  /// reference name.  If the other name moves, the symbolic name will move,
  /// too.  As a simple example, the "HEAD" reference might refer to
  /// "refs/heads/master" while on the "master" branch of a repository.
  ///
  /// The symbolic reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param target The target of the reference
  /// @param force Overwrite existing references
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_symbolic_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> target,
    int force,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_symbolic_create(
      out,
      repo,
      name,
      target,
      force,
      log_message,
    );
  }

  late final _git_reference_symbolic_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_reference_symbolic_create');
  late final _git_reference_symbolic_create =
      _git_reference_symbolic_createPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new direct reference.
  ///
  /// A direct reference (also called an object id reference) refers directly
  /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
  /// permanently refers to the object (although the reference itself can be
  /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
  /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
  ///
  /// The direct reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param id The object id pointed to by the reference.
  /// @param force Overwrite existing references
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_oid> id,
    int force,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_create(
      out,
      repo,
      name,
      id,
      force,
      log_message,
    );
  }

  late final _git_reference_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_reference_create');
  late final _git_reference_create = _git_reference_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_oid>,
          int,
          ffi.Pointer<ffi.Char>)>();

  /// Conditionally create new direct reference
  ///
  /// A direct reference (also called an object id reference) refers directly
  /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
  /// permanently refers to the object (although the reference itself can be
  /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
  /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
  ///
  /// The direct reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// It will return GIT_EMODIFIED if the reference's value at the time
  /// of updating does not match the one passed through `current_id`
  /// (i.e. if the ref has changed since the user read it).
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param id The object id pointed to by the reference.
  /// @param force Overwrite existing references
  /// @param current_id The expected value of the reference at the time of update
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_create_matching(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_oid> id,
    int force,
    ffi.Pointer<git_oid> current_id,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_create_matching(
      out,
      repo,
      name,
      id,
      force,
      current_id,
      log_message,
    );
  }

  late final _git_reference_create_matchingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Int,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_reference_create_matching');
  late final _git_reference_create_matching =
      _git_reference_create_matchingPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              int,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the OID pointed to by a direct reference.
  ///
  /// Only available if the reference is direct (i.e. an object id reference,
  /// not a symbolic one).
  ///
  /// To find the OID of a symbolic ref, call `git_reference_resolve()` and
  /// then this function (or maybe use `git_reference_name_to_id()` to
  /// directly resolve a reference name all the way through to an OID).
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> git_reference_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_target(
      ref,
    );
  }

  late final _git_reference_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reference>)>>('git_reference_target');
  late final _git_reference_target = _git_reference_targetPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reference>)>();

  /// Return the peeled OID target of this reference.
  ///
  /// This peeled OID only applies to direct references that point to
  /// a hard Tag object: it is the result of peeling such Tag.
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> git_reference_target_peel(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_target_peel(
      ref,
    );
  }

  late final _git_reference_target_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reference>)>>('git_reference_target_peel');
  late final _git_reference_target_peel = _git_reference_target_peelPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reference>)>();

  /// Get full name to the reference pointed to by a symbolic reference.
  ///
  /// Only available if the reference is symbolic.
  ///
  /// @param ref The reference
  /// @return a pointer to the name if available, NULL otherwise
  ffi.Pointer<ffi.Char> git_reference_symbolic_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_symbolic_target(
      ref,
    );
  }

  late final _git_reference_symbolic_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reference>)>>('git_reference_symbolic_target');
  late final _git_reference_symbolic_target = _git_reference_symbolic_targetPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)>();

  /// Get the type of a reference.
  ///
  /// Either direct (GIT_REFERENCE_DIRECT) or symbolic (GIT_REFERENCE_SYMBOLIC)
  ///
  /// @param ref The reference
  /// @return the type
  git_reference_t git_reference_type(
    ffi.Pointer<git_reference> ref,
  ) {
    return git_reference_t.fromValue(_git_reference_type(
      ref,
    ));
  }

  late final _git_reference_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<git_reference>)>>('git_reference_type');
  late final _git_reference_type = _git_reference_typePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Get the full name of a reference.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param ref The reference
  /// @return the full name for the ref
  ffi.Pointer<ffi.Char> git_reference_name(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_name(
      ref,
    );
  }

  late final _git_reference_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reference>)>>('git_reference_name');
  late final _git_reference_name = _git_reference_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)>();

  /// Resolve a symbolic reference to a direct reference.
  ///
  /// This method iteratively peels a symbolic reference until it resolves to
  /// a direct reference to an OID.
  ///
  /// The peeled reference is returned in the `resolved_ref` argument, and
  /// must be freed manually once it's no longer needed.
  ///
  /// If a direct reference is passed as an argument, a copy of that
  /// reference is returned. This copy must be manually freed too.
  ///
  /// @param out Pointer to the peeled reference
  /// @param ref The reference
  /// @return 0 or an error code
  int git_reference_resolve(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_resolve(
      out,
      ref,
    );
  }

  late final _git_reference_resolvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_reference_resolve');
  late final _git_reference_resolve = _git_reference_resolvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Get the repository where a reference resides.
  ///
  /// @param ref The reference
  /// @return a pointer to the repo
  ffi.Pointer<git_repository> git_reference_owner(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_owner(
      ref,
    );
  }

  late final _git_reference_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_reference>)>>('git_reference_owner');
  late final _git_reference_owner = _git_reference_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_reference>)>();

  /// Create a new reference with the same name as the given reference but a
  /// different symbolic target. The reference must be a symbolic reference,
  /// otherwise this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// The target name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param target The new target for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_reference_symbolic_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_symbolic_set_target(
      out,
      ref,
      target,
      log_message,
    );
  }

  late final _git_reference_symbolic_set_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_reference_symbolic_set_target');
  late final _git_reference_symbolic_set_target =
      _git_reference_symbolic_set_targetPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Conditionally create a new reference with the same name as the given reference but a
  /// different OID target. The reference must be a direct reference, otherwise
  /// this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param id The new target OID for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed since it was read, or an error code
  int git_reference_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_set_target(
      out,
      ref,
      id,
      log_message,
    );
  }

  late final _git_reference_set_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_reference_set_target');
  late final _git_reference_set_target =
      _git_reference_set_targetPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Rename an existing reference.
  ///
  /// This method works for both direct and symbolic references.
  ///
  /// The new name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// If the `force` flag is not enabled, and there's already
  /// a reference with the given name, the renaming will fail.
  ///
  /// IMPORTANT:
  /// The user needs to write a proper reflog entry if the
  /// reflog is enabled for the repository. We only rename
  /// the reflog if it exists.
  ///
  /// @param[out] new_ref The new reference
  /// @param ref The reference to rename
  /// @param new_name The new name for the reference
  /// @param force Overwrite an existing reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_reference_rename(
    ffi.Pointer<ffi.Pointer<git_reference>> new_ref,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<ffi.Char> new_name,
    int force,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_rename(
      new_ref,
      ref,
      new_name,
      force,
      log_message,
    );
  }

  late final _git_reference_renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_reference_rename');
  late final _git_reference_rename = _git_reference_renamePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>)>();

  /// Delete an existing reference.
  ///
  /// This method works for both direct and symbolic references.  The reference
  /// will be immediately removed on disk but the memory will not be freed.
  /// Callers must call `git_reference_free`.
  ///
  /// This function will return an error if the reference has changed
  /// from the time it was looked up.
  ///
  /// @param ref The reference to remove
  /// @return 0, GIT_EMODIFIED or an error code
  int git_reference_delete(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_delete(
      ref,
    );
  }

  late final _git_reference_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_delete');
  late final _git_reference_delete = _git_reference_deletePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Delete an existing reference by name
  ///
  /// This method removes the named reference from the repository without
  /// looking at its old value.
  ///
  /// @param repo The repository to remove the reference from
  /// @param name The reference to remove
  /// @return 0 or an error code
  int git_reference_remove(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reference_remove(
      repo,
      name,
    );
  }

  late final _git_reference_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_remove');
  late final _git_reference_remove = _git_reference_removePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Fill a list with all the references that can be found in a repository.
  ///
  /// The string array will be filled with the names of all references; these
  /// values are owned by the user and should be free'd manually when no
  /// longer needed, using `git_strarray_free()`.
  ///
  /// @param array Pointer to a git_strarray structure where
  /// the reference names will be stored
  /// @param repo Repository where to find the refs
  /// @return 0 or an error code
  int git_reference_list(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_reference_list(
      array,
      repo,
    );
  }

  late final _git_reference_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_reference_list');
  late final _git_reference_list = _git_reference_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Perform a callback on each reference in the repository.
  ///
  /// The `callback` function will be called for each reference in the
  /// repository, receiving the reference object and the `payload` value
  /// passed to this method.  Returning a non-zero value from the callback
  /// will terminate the iteration.
  ///
  /// Note that the callback function is responsible to call `git_reference_free`
  /// on each reference passed to it.
  ///
  /// @param repo Repository where to find the refs
  /// @param callback Function which will be called for every listed ref
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_reference_foreach(
    ffi.Pointer<git_repository> repo,
    git_reference_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_reference_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_reference_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_reference_foreach');
  late final _git_reference_foreach = _git_reference_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, git_reference_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Perform a callback on the fully-qualified name of each reference.
  ///
  /// The `callback` function will be called for each reference in the
  /// repository, receiving the name of the reference and the `payload` value
  /// passed to this method.  Returning a non-zero value from the callback
  /// will terminate the iteration.
  ///
  /// @param repo Repository where to find the refs
  /// @param callback Function which will be called for every listed ref name
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_reference_foreach_name(
    ffi.Pointer<git_repository> repo,
    git_reference_foreach_name_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach_name(
      repo,
      callback,
      payload,
    );
  }

  late final _git_reference_foreach_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_reference_foreach_name_cb,
              ffi.Pointer<ffi.Void>)>>('git_reference_foreach_name');
  late final _git_reference_foreach_name =
      _git_reference_foreach_namePtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              git_reference_foreach_name_cb, ffi.Pointer<ffi.Void>)>();

  /// Create a copy of an existing reference.
  ///
  /// Call `git_reference_free` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_reference_dup(
    ffi.Pointer<ffi.Pointer<git_reference>> dest,
    ffi.Pointer<git_reference> source,
  ) {
    return _git_reference_dup(
      dest,
      source,
    );
  }

  late final _git_reference_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_reference_dup');
  late final _git_reference_dup = _git_reference_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Free the given reference.
  ///
  /// @param ref git_reference
  void git_reference_free(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_free(
      ref,
    );
  }

  late final _git_reference_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_reference>)>>(
      'git_reference_free');
  late final _git_reference_free = _git_reference_freePtr
      .asFunction<void Function(ffi.Pointer<git_reference>)>();

  /// Compare two references.
  ///
  /// @param ref1 The first git_reference
  /// @param ref2 The second git_reference
  /// @return 0 if the same, else a stable but meaningless ordering.
  int git_reference_cmp(
    ffi.Pointer<git_reference> ref1,
    ffi.Pointer<git_reference> ref2,
  ) {
    return _git_reference_cmp(
      ref1,
      ref2,
    );
  }

  late final _git_reference_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_reference>,
              ffi.Pointer<git_reference>)>>('git_reference_cmp');
  late final _git_reference_cmp = _git_reference_cmpPtr.asFunction<
      int Function(ffi.Pointer<git_reference>, ffi.Pointer<git_reference>)>();

  /// Create an iterator for the repo's references
  ///
  /// @param[out] out pointer in which to store the iterator
  /// @param repo the repository
  /// @return 0 or an error code
  int git_reference_iterator_new(
    ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_reference_iterator_new(
      out,
      repo,
    );
  }

  late final _git_reference_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>)>>('git_reference_iterator_new');
  late final _git_reference_iterator_new =
      _git_reference_iterator_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>)>();

  /// Create an iterator for the repo's references that match the
  /// specified glob
  ///
  /// @param out pointer in which to store the iterator
  /// @param repo the repository
  /// @param glob the glob to match against the reference names
  /// @return 0 or an error code
  int git_reference_iterator_glob_new(
    ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> glob,
  ) {
    return _git_reference_iterator_glob_new(
      out,
      repo,
      glob,
    );
  }

  late final _git_reference_iterator_glob_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_iterator_glob_new');
  late final _git_reference_iterator_glob_new =
      _git_reference_iterator_glob_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Get the next reference
  ///
  /// @param[out] out pointer in which to store the reference
  /// @param iter the iterator
  /// @return 0, GIT_ITEROVER if there are no more; or an error code
  int git_reference_next(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_next(
      out,
      iter,
    );
  }

  late final _git_reference_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference_iterator>)>>('git_reference_next');
  late final _git_reference_next = _git_reference_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference_iterator>)>();

  /// Get the next reference's name
  ///
  /// This function is provided for convenience in case only the names
  /// are interesting as it avoids the allocation of the `git_reference`
  /// object which `git_reference_next()` needs.
  ///
  /// @param out pointer in which to store the string
  /// @param iter the iterator
  /// @return 0, GIT_ITEROVER if there are no more; or an error code
  int git_reference_next_name(
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_next_name(
      out,
      iter,
    );
  }

  late final _git_reference_next_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_reference_iterator>)>>('git_reference_next_name');
  late final _git_reference_next_name = _git_reference_next_namePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_reference_iterator>)>();

  /// Free the iterator and its associated resources
  ///
  /// @param iter the iterator to free
  void git_reference_iterator_free(
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_iterator_free(
      iter,
    );
  }

  late final _git_reference_iterator_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_reference_iterator>)>>(
      'git_reference_iterator_free');
  late final _git_reference_iterator_free = _git_reference_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_reference_iterator>)>();

  /// Perform a callback on each reference in the repository whose name
  /// matches the given pattern.
  ///
  /// This function acts like `git_reference_foreach()` with an additional
  /// pattern match being applied to the reference name before issuing the
  /// callback function.  See that function for more information.
  ///
  /// The pattern is matched using fnmatch or "glob" style where a '*' matches
  /// any sequence of letters, a '?' matches any letter, and square brackets
  /// can be used to define character ranges (such as "[0-9]" for digits).
  ///
  /// @param repo Repository where to find the refs
  /// @param glob Pattern to match (fnmatch-style) against reference name.
  /// @param callback Function which will be called for every listed ref
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, GIT_EUSER on non-zero callback, or error code
  int git_reference_foreach_glob(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> glob,
    git_reference_foreach_name_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach_glob(
      repo,
      glob,
      callback,
      payload,
    );
  }

  late final _git_reference_foreach_globPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              git_reference_foreach_name_cb,
              ffi.Pointer<ffi.Void>)>>('git_reference_foreach_glob');
  late final _git_reference_foreach_glob =
      _git_reference_foreach_globPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              git_reference_foreach_name_cb, ffi.Pointer<ffi.Void>)>();

  /// Check if a reflog exists for the specified reference.
  ///
  /// @param repo the repository
  /// @param refname the reference's name
  /// @return 0 when no reflog can be found, 1 when it exists;
  /// otherwise an error code.
  int git_reference_has_log(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_reference_has_log(
      repo,
      refname,
    );
  }

  late final _git_reference_has_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_has_log');
  late final _git_reference_has_log = _git_reference_has_logPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Ensure there is a reflog for a particular reference.
  ///
  /// Make sure that successive updates to the reference will append to
  /// its log.
  ///
  /// @param repo the repository
  /// @param refname the reference's name
  /// @return 0 or an error code.
  int git_reference_ensure_log(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_reference_ensure_log(
      repo,
      refname,
    );
  }

  late final _git_reference_ensure_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_ensure_log');
  late final _git_reference_ensure_log =
      _git_reference_ensure_logPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Check if a reference is a local branch.
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/heads
  /// namespace; 0 otherwise.
  int git_reference_is_branch(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_branch(
      ref,
    );
  }

  late final _git_reference_is_branchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_branch');
  late final _git_reference_is_branch = _git_reference_is_branchPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Check if a reference is a remote tracking branch
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/remotes
  /// namespace; 0 otherwise.
  int git_reference_is_remote(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_remote(
      ref,
    );
  }

  late final _git_reference_is_remotePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_remote');
  late final _git_reference_is_remote = _git_reference_is_remotePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Check if a reference is a tag
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/tags
  /// namespace; 0 otherwise.
  int git_reference_is_tag(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_tag(
      ref,
    );
  }

  late final _git_reference_is_tagPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_tag');
  late final _git_reference_is_tag = _git_reference_is_tagPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Check if a reference is a note
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/notes
  /// namespace; 0 otherwise.
  int git_reference_is_note(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_note(
      ref,
    );
  }

  late final _git_reference_is_notePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_note');
  late final _git_reference_is_note = _git_reference_is_notePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Normalize reference name and check validity.
  ///
  /// This will normalize the reference name by removing any leading slash
  /// '/' characters and collapsing runs of adjacent slashes between name
  /// components into a single slash.
  ///
  /// Once normalized, if the reference name is valid, it will be returned in
  /// the user allocated buffer.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param buffer_out User allocated buffer to store normalized name
  /// @param buffer_size Size of buffer_out
  /// @param name Reference name to be checked.
  /// @param flags Flags to constrain name validation rules - see the
  /// GIT_REFERENCE_FORMAT constants above.
  /// @return 0 on success, GIT_EBUFS if buffer is too small, GIT_EINVALIDSPEC
  /// or an error code.
  int git_reference_normalize_name(
    ffi.Pointer<ffi.Char> buffer_out,
    int buffer_size,
    ffi.Pointer<ffi.Char> name,
    int flags,
  ) {
    return _git_reference_normalize_name(
      buffer_out,
      buffer_size,
      name,
      flags,
    );
  }

  late final _git_reference_normalize_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_reference_normalize_name');
  late final _git_reference_normalize_name =
      _git_reference_normalize_namePtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Recursively peel reference until object of the specified type is found.
  ///
  /// The retrieved `peeled` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object
  /// will be peeled until a non-tag object is met.
  ///
  /// @param[out] out Pointer to the peeled git_object
  /// @param ref The reference to be processed
  /// @param type The type of the requested object (GIT_OBJECT_COMMIT,
  /// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).
  /// @return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code
  int git_reference_peel(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_reference> ref,
    git_object_t type,
  ) {
    return _git_reference_peel(
      out,
      ref,
      type.value,
    );
  }

  late final _git_reference_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_reference>, ffi.Int)>>('git_reference_peel');
  late final _git_reference_peel = _git_reference_peelPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_reference>, int)>();

  /// Ensure the reference name is well-formed.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// @param valid output pointer to set with validity of given reference name
  /// @param refname name to be checked.
  /// @return 0 on success or an error code
  int git_reference_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_reference_name_is_valid(
      valid,
      refname,
    );
  }

  late final _git_reference_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_reference_name_is_valid');
  late final _git_reference_name_is_valid = _git_reference_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Get the reference's short name
  ///
  /// This will transform the reference name into a name "human-readable"
  /// version. If no shortname is appropriate, it will return the full
  /// name.
  ///
  /// The memory is owned by the reference and must not be freed.
  ///
  /// @param ref a reference
  /// @return the human-readable version of the name
  ffi.Pointer<ffi.Char> git_reference_shorthand(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_shorthand(
      ref,
    );
  }

  late final _git_reference_shorthandPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reference>)>>('git_reference_shorthand');
  late final _git_reference_shorthand = _git_reference_shorthandPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)>();

  /// Initialize git_diff_options structure
  ///
  /// Initializes a `git_diff_options` with default values. Equivalent to creating
  /// an instance with GIT_DIFF_OPTIONS_INIT.
  ///
  /// @param opts The `git_diff_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_options_init(
    ffi.Pointer<git_diff_options> opts,
    int version,
  ) {
    return _git_diff_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_options>,
              ffi.UnsignedInt)>>('git_diff_options_init');
  late final _git_diff_options_init = _git_diff_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_diff_options>, int)>();

  /// Initialize git_diff_find_options structure
  ///
  /// Initializes a `git_diff_find_options` with default values. Equivalent to creating
  /// an instance with GIT_DIFF_FIND_OPTIONS_INIT.
  ///
  /// @param opts The `git_diff_find_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_FIND_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_find_options_init(
    ffi.Pointer<git_diff_find_options> opts,
    int version,
  ) {
    return _git_diff_find_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_find_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_find_options>,
              ffi.UnsignedInt)>>('git_diff_find_options_init');
  late final _git_diff_find_options_init = _git_diff_find_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_diff_find_options>, int)>();

  /// Deallocate a diff.
  ///
  /// @param diff The previously created diff; cannot be used after free.
  void git_diff_free(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_free(
      diff,
    );
  }

  late final _git_diff_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_diff>)>>(
          'git_diff_free');
  late final _git_diff_free =
      _git_diff_freePtr.asFunction<void Function(ffi.Pointer<git_diff>)>();

  /// Create a diff with the difference between two tree objects.
  ///
  /// This is equivalent to `git diff <old-tree> <new-tree>`
  ///
  /// The first tree will be used for the "old_file" side of the delta and the
  /// second tree will be used for the "new_file" side of the delta.  You can
  /// pass NULL to indicate an empty tree, although it is an error to pass
  /// NULL for both the `old_tree` and `new_tree`.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the trees.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param new_tree A git_tree object to diff to, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_tree(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_tree> new_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_tree(
      diff,
      repo,
      old_tree,
      new_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>>('git_diff_tree_to_tree');
  late final _git_diff_tree_to_tree = _git_diff_tree_to_treePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_diff_options>)>();

  /// Create a diff between a tree and repository index.
  ///
  /// This is equivalent to `git diff --cached <treeish>` or if you pass
  /// the HEAD tree, then like `git diff --cached`.
  ///
  /// The tree you pass will be used for the "old_file" side of the delta, and
  /// the index will be used for the "new_file" side of the delta.
  ///
  /// If you pass NULL for the index, then the existing index of the `repo`
  /// will be used.  In this case, the index will be refreshed from disk
  /// (if it has changed) before the diff is generated.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the tree and index.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param index The index to diff with; repo index used if NULL.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_index(
      diff,
      repo,
      old_tree,
      index,
      opts,
    );
  }

  late final _git_diff_tree_to_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>>('git_diff_tree_to_index');
  late final _git_diff_tree_to_index = _git_diff_tree_to_indexPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_index>,
          ffi.Pointer<git_diff_options>)>();

  /// Create a diff between the repository index and the workdir directory.
  ///
  /// This matches the `git diff` command.  See the note below on
  /// `git_diff_tree_to_workdir` for a discussion of the difference between
  /// `git diff` and `git diff HEAD` and how to emulate a `git diff <treeish>`
  /// using libgit2.
  ///
  /// The index will be used for the "old_file" side of the delta, and the
  /// working directory will be used for the "new_file" side of the delta.
  ///
  /// If you pass NULL for the index, then the existing index of the `repo`
  /// will be used.  In this case, the index will be refreshed from disk
  /// (if it has changed) before the diff is generated.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository.
  /// @param index The index to diff from; repo index used if NULL.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_index_to_workdir(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_index_to_workdir(
      diff,
      repo,
      index,
      opts,
    );
  }

  late final _git_diff_index_to_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>>('git_diff_index_to_workdir');
  late final _git_diff_index_to_workdir =
      _git_diff_index_to_workdirPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>();

  /// Create a diff between a tree and the working directory.
  ///
  /// The tree you provide will be used for the "old_file" side of the delta,
  /// and the working directory will be used for the "new_file" side.
  ///
  /// This is not the same as `git diff <treeish>` or `git diff-index
  /// <treeish>`.  Those commands use information from the index, whereas this
  /// function strictly returns the differences between the tree and the files
  /// in the working directory, regardless of the state of the index.  Use
  /// `git_diff_tree_to_workdir_with_index` to emulate those commands.
  ///
  /// To see difference between this and `git_diff_tree_to_workdir_with_index`,
  /// consider the example of a staged file deletion where the file has then
  /// been put back into the working dir and further modified.  The
  /// tree-to-workdir diff for that file is 'modified', but `git diff` would
  /// show status 'deleted' since there is a staged delete.
  ///
  /// @param diff A pointer to a git_diff pointer that will be allocated.
  /// @param repo The repository containing the tree.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_workdir(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_workdir(
      diff,
      repo,
      old_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>>('git_diff_tree_to_workdir');
  late final _git_diff_tree_to_workdir =
      _git_diff_tree_to_workdirPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>();

  /// Create a diff between a tree and the working directory using index data
  /// to account for staged deletes, tracked files, etc.
  ///
  /// This emulates `git diff <tree>` by diffing the tree to the index and
  /// the index to the working directory and blending the results into a
  /// single diff that includes staged deleted, etc.
  ///
  /// @param diff A pointer to a git_diff pointer that will be allocated.
  /// @param repo The repository containing the tree.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_workdir_with_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_workdir_with_index(
      diff,
      repo,
      old_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_workdir_with_indexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_diff>>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<git_tree>,
                  ffi.Pointer<git_diff_options>)>>(
      'git_diff_tree_to_workdir_with_index');
  late final _git_diff_tree_to_workdir_with_index =
      _git_diff_tree_to_workdir_with_indexPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>();

  /// Create a diff with the difference between two index objects.
  ///
  /// The first index will be used for the "old_file" side of the delta and the
  /// second index will be used for the "new_file" side of the delta.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the indexes.
  /// @param old_index A git_index object to diff from.
  /// @param new_index A git_index object to diff to.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_index_to_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> old_index,
    ffi.Pointer<git_index> new_index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_index_to_index(
      diff,
      repo,
      old_index,
      new_index,
      opts,
    );
  }

  late final _git_diff_index_to_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>>('git_diff_index_to_index');
  late final _git_diff_index_to_index = _git_diff_index_to_indexPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_index>,
          ffi.Pointer<git_index>,
          ffi.Pointer<git_diff_options>)>();

  /// Merge one diff into another.
  ///
  /// This merges items from the "from" list into the "onto" list.  The
  /// resulting diff will have all items that appear in either list.
  /// If an item appears in both lists, then it will be "merged" to appear
  /// as if the old version was from the "onto" list and the new version
  /// is from the "from" list (with the exception that if the item has a
  /// pending DELETE in the middle, then it will show as deleted).
  ///
  /// @param onto Diff to merge into.
  /// @param from Diff to merge.
  /// @return 0 or an error code.
  int git_diff_merge(
    ffi.Pointer<git_diff> onto,
    ffi.Pointer<git_diff> from,
  ) {
    return _git_diff_merge(
      onto,
      from,
    );
  }

  late final _git_diff_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_diff>, ffi.Pointer<git_diff>)>>('git_diff_merge');
  late final _git_diff_merge = _git_diff_mergePtr
      .asFunction<int Function(ffi.Pointer<git_diff>, ffi.Pointer<git_diff>)>();

  /// Transform a diff marking file renames, copies, etc.
  ///
  /// This modifies a diff in place, replacing old entries that look
  /// like renames or copies with new entries reflecting those changes.
  /// This also will, if requested, break modified files into add/remove
  /// pairs if the amount of change is above a threshold.
  ///
  /// @param diff diff to run detection algorithms on
  /// @param options Control how detection should be run, NULL for defaults
  /// @return 0 on success, -1 on failure
  int git_diff_find_similar(
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_find_options> options,
  ) {
    return _git_diff_find_similar(
      diff,
      options,
    );
  }

  late final _git_diff_find_similarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff>,
              ffi.Pointer<git_diff_find_options>)>>('git_diff_find_similar');
  late final _git_diff_find_similar = _git_diff_find_similarPtr.asFunction<
      int Function(
          ffi.Pointer<git_diff>, ffi.Pointer<git_diff_find_options>)>();

  /// Query how many diff records are there in a diff.
  ///
  /// @param diff A git_diff generated by one of the above functions
  /// @return Count of number of deltas in the list
  int git_diff_num_deltas(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_num_deltas(
      diff,
    );
  }

  late final _git_diff_num_deltasPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff>)>>(
          'git_diff_num_deltas');
  late final _git_diff_num_deltas =
      _git_diff_num_deltasPtr.asFunction<int Function(ffi.Pointer<git_diff>)>();

  /// Query how many diff deltas are there in a diff filtered by type.
  ///
  /// This works just like `git_diff_num_deltas()` with an extra parameter
  /// that is a `git_delta_t` and returns just the count of how many deltas
  /// match that particular type.
  ///
  /// @param diff A git_diff generated by one of the above functions
  /// @param type A git_delta_t value to filter the count
  /// @return Count of number of deltas matching delta_t type
  int git_diff_num_deltas_of_type(
    ffi.Pointer<git_diff> diff,
    git_delta_t type,
  ) {
    return _git_diff_num_deltas_of_type(
      diff,
      type.value,
    );
  }

  late final _git_diff_num_deltas_of_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<git_diff>,
              ffi.UnsignedInt)>>('git_diff_num_deltas_of_type');
  late final _git_diff_num_deltas_of_type = _git_diff_num_deltas_of_typePtr
      .asFunction<int Function(ffi.Pointer<git_diff>, int)>();

  /// Return the diff delta for an entry in the diff list.
  ///
  /// The `git_diff_delta` pointer points to internal data and you do not
  /// have to release it when you are done with it.  It will go away when
  /// the * `git_diff` (or any associated `git_patch`) goes away.
  ///
  /// Note that the flags on the delta related to whether it has binary
  /// content or not may not be set if there are no attributes set for the
  /// file and there has been no reason to load the file data at this point.
  /// For now, if you need those flags to be up to date, your only option is
  /// to either use `git_diff_foreach` or create a `git_patch`.
  ///
  /// @param diff Diff list object
  /// @param idx Index into diff list
  /// @return Pointer to git_diff_delta (or NULL if `idx` out of range)
  ffi.Pointer<git_diff_delta> git_diff_get_delta(
    ffi.Pointer<git_diff> diff,
    int idx,
  ) {
    return _git_diff_get_delta(
      diff,
      idx,
    );
  }

  late final _git_diff_get_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_diff>, ffi.Size)>>('git_diff_get_delta');
  late final _git_diff_get_delta = _git_diff_get_deltaPtr.asFunction<
      ffi.Pointer<git_diff_delta> Function(ffi.Pointer<git_diff>, int)>();

  /// Check if deltas are sorted case sensitively or insensitively.
  ///
  /// @param diff diff to check
  /// @return 0 if case sensitive, 1 if case is ignored
  int git_diff_is_sorted_icase(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_is_sorted_icase(
      diff,
    );
  }

  late final _git_diff_is_sorted_icasePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff>)>>(
          'git_diff_is_sorted_icase');
  late final _git_diff_is_sorted_icase = _git_diff_is_sorted_icasePtr
      .asFunction<int Function(ffi.Pointer<git_diff>)>();

  /// Loop over all deltas in a diff issuing callbacks.
  ///
  /// This will iterate through all of the files described in a diff.  You
  /// should provide a file callback to learn about each file.
  ///
  /// The "hunk" and "line" callbacks are optional, and the text diff of the
  /// files will only be calculated if they are not NULL.  Of course, these
  /// callbacks will not be invoked for binary files on the diff or for
  /// files whose only changed is a file mode change.
  ///
  /// Returning a non-zero value from any of the callbacks will terminate
  /// the iteration and return the value to the user.
  ///
  /// @param diff A git_diff generated by one of the above functions.
  /// @param file_cb Callback function to make per file in the diff.
  /// @param binary_cb Optional callback to make for binary files.
  /// @param hunk_cb Optional callback to make per hunk of text diff.  This
  /// callback is called to describe a range of lines in the
  /// diff.  It will not be issued for binary files.
  /// @param line_cb Optional callback to make per line of diff text.  This
  /// same callback will be made for context lines, added, and
  /// removed lines, and even for a deleted trailing newline.
  /// @param payload Reference pointer that will be passed to your callbacks.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_foreach(
    ffi.Pointer<git_diff> diff,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_foreach(
      diff,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_diff>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_foreach');
  late final _git_diff_foreach = _git_diff_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_diff>, git_diff_file_cb, git_diff_binary_cb,
          git_diff_hunk_cb, git_diff_line_cb, ffi.Pointer<ffi.Void>)>();

  /// Look up the single character abbreviation for a delta status code.
  ///
  /// When you run `git diff --name-status` it uses single letter codes in
  /// the output such as 'A' for added, 'D' for deleted, 'M' for modified,
  /// etc.  This function converts a git_delta_t value into these letters for
  /// your own purposes.  GIT_DELTA_UNTRACKED will return a space (i.e. ' ').
  ///
  /// @param status The git_delta_t value to look up
  /// @return The single character label for that code
  int git_diff_status_char(
    git_delta_t status,
  ) {
    return _git_diff_status_char(
      status.value,
    );
  }

  late final _git_diff_status_charPtr =
      _lookup<ffi.NativeFunction<ffi.Char Function(ffi.UnsignedInt)>>(
          'git_diff_status_char');
  late final _git_diff_status_char =
      _git_diff_status_charPtr.asFunction<int Function(int)>();

  /// Iterate over a diff generating formatted text output.
  ///
  /// Returning a non-zero value from the callbacks will terminate the
  /// iteration and return the non-zero value to the caller.
  ///
  /// @param diff A git_diff generated by one of the above functions.
  /// @param format A git_diff_format_t value to pick the text format.
  /// @param print_cb Callback to make per line of diff text.
  /// @param payload Reference pointer that will be passed to your callback.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_print(
    ffi.Pointer<git_diff> diff,
    git_diff_format_t format,
    git_diff_line_cb print_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_print(
      diff,
      format.value,
      print_cb,
      payload,
    );
  }

  late final _git_diff_printPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff>, ffi.UnsignedInt,
              git_diff_line_cb, ffi.Pointer<ffi.Void>)>>('git_diff_print');
  late final _git_diff_print = _git_diff_printPtr.asFunction<
      int Function(ffi.Pointer<git_diff>, int, git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Produce the complete formatted text output from a diff into a
  /// buffer.
  ///
  /// @param out A pointer to a user-allocated git_buf that will
  /// contain the diff text
  /// @param diff A git_diff generated by one of the above functions.
  /// @param format A git_diff_format_t value to pick the text format.
  /// @return 0 on success or error code
  int git_diff_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff> diff,
    git_diff_format_t format,
  ) {
    return _git_diff_to_buf(
      out,
      diff,
      format.value,
    );
  }

  late final _git_diff_to_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff>,
              ffi.UnsignedInt)>>('git_diff_to_buf');
  late final _git_diff_to_buf = _git_diff_to_bufPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff>, int)>();

  /// Directly run a diff on two blobs.
  ///
  /// Compared to a file, a blob lacks some contextual information. As such,
  /// the `git_diff_file` given to the callback will have some fake data; i.e.
  /// `mode` will be 0 and `path` will be NULL.
  ///
  /// NULL is allowed for either `old_blob` or `new_blob` and will be treated
  /// as an empty blob, with the `oid` set to NULL in the `git_diff_file` data.
  /// Passing NULL for both blobs is a noop; no callbacks will be made at all.
  ///
  /// We do run a binary content check on the blob content and if either blob
  /// looks like binary data, the `git_diff_delta` binary attribute will be set
  /// to 1 and no call to the hunk_cb nor line_cb will be made (unless you pass
  /// `GIT_DIFF_FORCE_TEXT` of course).
  ///
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param new_blob Blob for new side of diff, or NULL for empty blob
  /// @param new_as_path Treat new blob as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_blobs(
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<git_blob> new_blob,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> options,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_blobs(
      old_blob,
      old_as_path,
      new_blob,
      new_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_blobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_blobs');
  late final _git_diff_blobs = _git_diff_blobsPtr.asFunction<
      int Function(
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>,
          git_diff_file_cb,
          git_diff_binary_cb,
          git_diff_hunk_cb,
          git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Directly run a diff between a blob and a buffer.
  ///
  /// As with `git_diff_blobs`, comparing a blob and buffer lacks some context,
  /// so the `git_diff_file` parameters to the callbacks will be faked a la the
  /// rules for `git_diff_blobs()`.
  ///
  /// Passing NULL for `old_blob` will be treated as an empty blob (i.e. the
  /// `file_cb` will be invoked with GIT_DELTA_ADDED and the diff will be the
  /// entire content of the buffer added).  Passing NULL to the buffer will do
  /// the reverse, with GIT_DELTA_REMOVED and blob content removed.
  ///
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param buffer Raw data for new side of diff, or NULL for empty
  /// @param buffer_len Length of raw data for new side of diff
  /// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_blob_to_buffer(
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Char> buffer,
    int buffer_len,
    ffi.Pointer<ffi.Char> buffer_as_path,
    ffi.Pointer<git_diff_options> options,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_blob_to_buffer(
      old_blob,
      old_as_path,
      buffer,
      buffer_len,
      buffer_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_blob_to_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_blob_to_buffer');
  late final _git_diff_blob_to_buffer = _git_diff_blob_to_bufferPtr.asFunction<
      int Function(
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>,
          git_diff_file_cb,
          git_diff_binary_cb,
          git_diff_hunk_cb,
          git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Directly run a diff between two buffers.
  ///
  /// Even more than with `git_diff_blobs`, comparing two buffer lacks
  /// context, so the `git_diff_file` parameters to the callbacks will be
  /// faked a la the rules for `git_diff_blobs()`.
  ///
  /// @param old_buffer Raw data for old side of diff, or NULL for empty
  /// @param old_len Length of the raw data for old side of the diff
  /// @param old_as_path Treat old buffer as if it had this filename; can be NULL
  /// @param new_buffer Raw data for new side of diff, or NULL for empty
  /// @param new_len Length of raw data for new side of diff
  /// @param new_as_path Treat buffer as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_buffers(
    ffi.Pointer<ffi.Void> old_buffer,
    int old_len,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Void> new_buffer,
    int new_len,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> options,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_buffers(
      old_buffer,
      old_len,
      old_as_path,
      new_buffer,
      new_len,
      new_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_buffersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_buffers');
  late final _git_diff_buffers = _git_diff_buffersPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>,
          git_diff_file_cb,
          git_diff_binary_cb,
          git_diff_hunk_cb,
          git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Read the contents of a git patch file into a `git_diff` object.
  ///
  /// The diff object produced is similar to the one that would be
  /// produced if you actually produced it computationally by comparing
  /// two trees, however there may be subtle differences.  For example,
  /// a patch file likely contains abbreviated object IDs, so the
  /// object IDs in a `git_diff_delta` produced by this function will
  /// also be abbreviated.
  ///
  /// This function will only read patch files created by a git
  /// implementation, it will not read unified diffs produced by
  /// the `diff` program, nor any other types of patch files.
  ///
  /// @param out A pointer to a git_diff pointer that will be allocated.
  /// @param content The contents of a patch file
  /// @param content_len The length of the patch file contents
  /// @return 0 or an error code
  int git_diff_from_buffer(
    ffi.Pointer<ffi.Pointer<git_diff>> out,
    ffi.Pointer<ffi.Char> content,
    int content_len,
    ffi.Pointer<git_diff_parse_options> opts,
  ) {
    return _git_diff_from_buffer(
      out,
      content,
      content_len,
      opts,
    );
  }

  late final _git_diff_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<git_diff_parse_options>)>>('git_diff_from_buffer');
  late final _git_diff_from_buffer = _git_diff_from_bufferPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_diff>>, ffi.Pointer<ffi.Char>,
          int, ffi.Pointer<git_diff_parse_options>)>();

  /// Accumulate diff statistics for all patches.
  ///
  /// @param out Structure containing the diff statistics.
  /// @param diff A git_diff generated by one of the above functions.
  /// @return 0 on success; non-zero on error
  int git_diff_get_stats(
    ffi.Pointer<ffi.Pointer<git_diff_stats>> out,
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_get_stats(
      out,
      diff,
    );
  }

  late final _git_diff_get_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff_stats>>,
              ffi.Pointer<git_diff>)>>('git_diff_get_stats');
  late final _git_diff_get_stats = _git_diff_get_statsPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff_stats>>, ffi.Pointer<git_diff>)>();

  /// Get the total number of files changed in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of files changed in the diff
  int git_diff_stats_files_changed(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_files_changed(
      stats,
    );
  }

  late final _git_diff_stats_files_changedPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_files_changed');
  late final _git_diff_stats_files_changed = _git_diff_stats_files_changedPtr
      .asFunction<int Function(ffi.Pointer<git_diff_stats>)>();

  /// Get the total number of insertions in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of insertions in the diff
  int git_diff_stats_insertions(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_insertions(
      stats,
    );
  }

  late final _git_diff_stats_insertionsPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_insertions');
  late final _git_diff_stats_insertions = _git_diff_stats_insertionsPtr
      .asFunction<int Function(ffi.Pointer<git_diff_stats>)>();

  /// Get the total number of deletions in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of deletions in the diff
  int git_diff_stats_deletions(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_deletions(
      stats,
    );
  }

  late final _git_diff_stats_deletionsPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_deletions');
  late final _git_diff_stats_deletions = _git_diff_stats_deletionsPtr
      .asFunction<int Function(ffi.Pointer<git_diff_stats>)>();

  /// Print diff statistics to a `git_buf`.
  ///
  /// @param out buffer to store the formatted diff statistics in.
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @param format Formatting option.
  /// @param width Target width for output (only affects GIT_DIFF_STATS_FULL)
  /// @return 0 on success; non-zero on error
  int git_diff_stats_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff_stats> stats,
    git_diff_stats_format_t format,
    int width,
  ) {
    return _git_diff_stats_to_buf(
      out,
      stats,
      format.value,
      width,
    );
  }

  late final _git_diff_stats_to_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff_stats>,
              ffi.UnsignedInt, ffi.Size)>>('git_diff_stats_to_buf');
  late final _git_diff_stats_to_buf = _git_diff_stats_to_bufPtr.asFunction<
      int Function(
          ffi.Pointer<git_buf>, ffi.Pointer<git_diff_stats>, int, int)>();

  /// Deallocate a `git_diff_stats`.
  ///
  /// @param stats The previously created statistics object;
  /// cannot be used after free.
  void git_diff_stats_free(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_free(
      stats,
    );
  }

  late final _git_diff_stats_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_free');
  late final _git_diff_stats_free = _git_diff_stats_freePtr
      .asFunction<void Function(ffi.Pointer<git_diff_stats>)>();

  /// Initialize git_diff_patchid_options structure
  ///
  /// Initializes a `git_diff_patchid_options` with default values. Equivalent to
  /// creating an instance with `GIT_DIFF_PATCHID_OPTIONS_INIT`.
  ///
  /// @param opts The `git_diff_patchid_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_PATCHID_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_patchid_options_init(
    ffi.Pointer<git_diff_patchid_options> opts,
    int version,
  ) {
    return _git_diff_patchid_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_patchid_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_patchid_options>,
              ffi.UnsignedInt)>>('git_diff_patchid_options_init');
  late final _git_diff_patchid_options_init = _git_diff_patchid_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_diff_patchid_options>, int)>();

  /// Calculate the patch ID for the given patch.
  ///
  /// Calculate a stable patch ID for the given patch by summing the
  /// hash of the file diffs, ignoring whitespace and line numbers.
  /// This can be used to derive whether two diffs are the same with
  /// a high probability.
  ///
  /// Currently, this function only calculates stable patch IDs, as
  /// defined in git-patch-id(1), and should in fact generate the
  /// same IDs as the upstream git project does.
  ///
  /// @param out Pointer where the calculated patch ID should be stored
  /// @param diff The diff to calculate the ID for
  /// @param opts Options for how to calculate the patch ID. This is
  /// intended for future changes, as currently no options are
  /// available.
  /// @return 0 on success, an error code otherwise.
  int git_diff_patchid(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_patchid_options> opts,
  ) {
    return _git_diff_patchid(
      out,
      diff,
      opts,
    );
  }

  late final _git_diff_patchidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_diff>,
              ffi.Pointer<git_diff_patchid_options>)>>('git_diff_patchid');
  late final _git_diff_patchid = _git_diff_patchidPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_diff>,
          ffi.Pointer<git_diff_patchid_options>)>();

  /// Initialize git_apply_options structure
  ///
  /// Initialize a `git_apply_options` with default values. Equivalent to creating
  /// an instance with GIT_APPLY_OPTIONS_INIT.
  ///
  /// @param opts The `git_apply_options` struct to initialize.
  /// @param version The struct version; pass `GIT_APPLY_OPTIONS_VERSION`
  /// @return 0 on success or -1 on failure.
  int git_apply_options_init(
    ffi.Pointer<git_apply_options> opts,
    int version,
  ) {
    return _git_apply_options_init(
      opts,
      version,
    );
  }

  late final _git_apply_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_apply_options>,
              ffi.UnsignedInt)>>('git_apply_options_init');
  late final _git_apply_options_init = _git_apply_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_apply_options>, int)>();

  /// Apply a `git_diff` to a `git_tree`, and return the resulting image
  /// as an index.
  ///
  /// @param out the postimage of the application
  /// @param repo the repository to apply
  /// @param preimage the tree to apply the diff to
  /// @param diff the diff to apply
  /// @param options the options for the apply (or null for defaults)
  /// @return 0 or an error code
  int git_apply_to_tree(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> preimage,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_apply_options> options,
  ) {
    return _git_apply_to_tree(
      out,
      repo,
      preimage,
      diff,
      options,
    );
  }

  late final _git_apply_to_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff>,
              ffi.Pointer<git_apply_options>)>>('git_apply_to_tree');
  late final _git_apply_to_tree = _git_apply_to_treePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_diff>,
          ffi.Pointer<git_apply_options>)>();

  /// Apply a `git_diff` to the given repository, making changes directly
  /// in the working directory, the index, or both.
  ///
  /// @param repo the repository to apply to
  /// @param diff the diff to apply
  /// @param location the location to apply (workdir, index or both)
  /// @param options the options for the apply (or null for defaults)
  /// @return 0 or an error code
  int git_apply(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_diff> diff,
    git_apply_location_t location,
    ffi.Pointer<git_apply_options> options,
  ) {
    return _git_apply(
      repo,
      diff,
      location.value,
      options,
    );
  }

  late final _git_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_diff>,
              ffi.UnsignedInt, ffi.Pointer<git_apply_options>)>>('git_apply');
  late final _git_apply = _git_applyPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_diff>, int,
          ffi.Pointer<git_apply_options>)>();

  /// Return the value type for a given attribute.
  ///
  /// This can be either `TRUE`, `FALSE`, `UNSPECIFIED` (if the attribute
  /// was not set at all), or `VALUE`, if the attribute was set to an
  /// actual string.
  ///
  /// If the attribute has a `VALUE` string, it can be accessed normally
  /// as a NULL-terminated C string.
  ///
  /// @param attr The attribute
  /// @return the value type for the attribute
  git_attr_value_t git_attr_value(
    ffi.Pointer<ffi.Char> attr,
  ) {
    return git_attr_value_t.fromValue(_git_attr_value(
      attr,
    ));
  }

  late final _git_attr_valuePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>(
      'git_attr_value');
  late final _git_attr_value =
      _git_attr_valuePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Look up the value of one git attribute for path.
  ///
  /// @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...
  /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
  /// use the string value for attributes set to a value.  You
  /// should NOT modify or free this value.
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path The path to check for attributes.  Relative paths are
  /// interpreted relative to the repo root.  The file does
  /// not have to exist, but if it does not, then it will be
  /// treated as a plain file (not a directory).
  /// @param name The name of the attribute to look up.
  /// @return 0 or an error code.
  int git_attr_get(
    ffi.Pointer<ffi.Pointer<ffi.Char>> value_out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_attr_get(
      value_out,
      repo,
      flags,
      path,
      name,
    );
  }

  late final _git_attr_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_attr_get');
  late final _git_attr_get = _git_attr_getPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Look up the value of one git attribute for path with extended options.
  ///
  /// @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...
  /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
  /// use the string value for attributes set to a value.  You
  /// should NOT modify or free this value.
  /// @param repo The repository containing the path.
  /// @param opts The `git_attr_options` to use when querying these attributes.
  /// @param path The path to check for attributes.  Relative paths are
  /// interpreted relative to the repo root.  The file does
  /// not have to exist, but if it does not, then it will be
  /// treated as a plain file (not a directory).
  /// @param name The name of the attribute to look up.
  /// @return 0 or an error code.
  int git_attr_get_ext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> value_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_attr_options> opts,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_attr_get_ext(
      value_out,
      repo,
      opts,
      path,
      name,
    );
  }

  late final _git_attr_get_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_attr_options>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_attr_get_ext');
  late final _git_attr_get_ext = _git_attr_get_extPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_attr_options>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Look up a list of git attributes for path.
  ///
  /// Use this if you have a known list of attributes that you want to
  /// look up in a single call.  This is somewhat more efficient than
  /// calling `git_attr_get()` multiple times.
  ///
  /// For example, you might write:
  ///
  /// const char *attrs[] = { "crlf", "diff", "foo" };
  /// const char **values[3];
  /// git_attr_get_many(values, repo, 0, "my/fun/file.c", 3, attrs);
  ///
  /// Then you could loop through the 3 values to get the settings for
  /// the three attributes you asked about.
  ///
  /// @param values_out An array of num_attr entries that will have string
  /// pointers written into it for the values of the attributes.
  /// You should not modify or free the values that are written
  /// into this array (although of course, you should free the
  /// array itself if you allocated it).
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path The path inside the repo to check attributes.  This
  /// does not have to exist, but if it does not, then
  /// it will be treated as a plain file (i.e. not a directory).
  /// @param num_attr The number of attributes being looked up
  /// @param names An array of num_attr strings containing attribute names.
  /// @return 0 or an error code.
  int git_attr_get_many(
    ffi.Pointer<ffi.Pointer<ffi.Char>> values_out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Char> path,
    int num_attr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> names,
  ) {
    return _git_attr_get_many(
      values_out,
      repo,
      flags,
      path,
      num_attr,
      names,
    );
  }

  late final _git_attr_get_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('git_attr_get_many');
  late final _git_attr_get_many = _git_attr_get_manyPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Look up a list of git attributes for path with extended options.
  ///
  /// @param values_out An array of num_attr entries that will have string
  /// pointers written into it for the values of the attributes.
  /// You should not modify or free the values that are written
  /// into this array (although of course, you should free the
  /// array itself if you allocated it).
  /// @param repo The repository containing the path.
  /// @param opts The `git_attr_options` to use when querying these attributes.
  /// @param path The path inside the repo to check attributes.  This
  /// does not have to exist, but if it does not, then
  /// it will be treated as a plain file (i.e. not a directory).
  /// @param num_attr The number of attributes being looked up
  /// @param names An array of num_attr strings containing attribute names.
  /// @return 0 or an error code.
  int git_attr_get_many_ext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> values_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_attr_options> opts,
    ffi.Pointer<ffi.Char> path,
    int num_attr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> names,
  ) {
    return _git_attr_get_many_ext(
      values_out,
      repo,
      opts,
      path,
      num_attr,
      names,
    );
  }

  late final _git_attr_get_many_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_attr_options>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('git_attr_get_many_ext');
  late final _git_attr_get_many_ext = _git_attr_get_many_extPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_attr_options>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Loop over all the git attributes for a path.
  ///
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path Path inside the repo to check attributes.  This does not have
  /// to exist, but if it does not, then it will be treated as a
  /// plain file (i.e. not a directory).
  /// @param callback Function to invoke on each attribute name and value.
  /// See git_attr_foreach_cb.
  /// @param payload Passed on as extra parameter to callback function.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_attr_foreach(
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Char> path,
    git_attr_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_attr_foreach(
      repo,
      flags,
      path,
      callback,
      payload,
    );
  }

  late final _git_attr_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              git_attr_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_attr_foreach');
  late final _git_attr_foreach = _git_attr_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, int, ffi.Pointer<ffi.Char>,
          git_attr_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Loop over all the git attributes for a path with extended options.
  ///
  /// @param repo The repository containing the path.
  /// @param opts The `git_attr_options` to use when querying these attributes.
  /// @param path Path inside the repo to check attributes.  This does not have
  /// to exist, but if it does not, then it will be treated as a
  /// plain file (i.e. not a directory).
  /// @param callback Function to invoke on each attribute name and value.
  /// See git_attr_foreach_cb.
  /// @param payload Passed on as extra parameter to callback function.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_attr_foreach_ext(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_attr_options> opts,
    ffi.Pointer<ffi.Char> path,
    git_attr_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_attr_foreach_ext(
      repo,
      opts,
      path,
      callback,
      payload,
    );
  }

  late final _git_attr_foreach_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_attr_options>,
              ffi.Pointer<ffi.Char>,
              git_attr_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_attr_foreach_ext');
  late final _git_attr_foreach_ext = _git_attr_foreach_extPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_attr_options>,
          ffi.Pointer<ffi.Char>, git_attr_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Flush the gitattributes cache.
  ///
  /// Call this if you have reason to believe that the attributes files on
  /// disk no longer match the cached contents of memory.  This will cause
  /// the attributes files to be reloaded the next time that an attribute
  /// access function is called.
  ///
  /// @param repo The repository containing the gitattributes cache
  /// @return 0 on success, or an error code
  int git_attr_cache_flush(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_attr_cache_flush(
      repo,
    );
  }

  late final _git_attr_cache_flushPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_attr_cache_flush');
  late final _git_attr_cache_flush = _git_attr_cache_flushPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Add a macro definition.
  ///
  /// Macros will automatically be loaded from the top level `.gitattributes`
  /// file of the repository (plus the built-in "binary" macro).  This
  /// function allows you to add others.  For example, to add the default
  /// macro, you would call:
  ///
  /// git_attr_add_macro(repo, "binary", "-diff -crlf");
  ///
  /// @param repo The repository to add the macro in.
  /// @param name The name of the macro.
  /// @param values The value for the macro.
  /// @return 0 or an error code.
  int git_attr_add_macro(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> values,
  ) {
    return _git_attr_add_macro(
      repo,
      name,
      values,
    );
  }

  late final _git_attr_add_macroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_attr_add_macro');
  late final _git_attr_add_macro = _git_attr_add_macroPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Lookup a blob object from a repository.
  ///
  /// @param[out] blob pointer to the looked up blob
  /// @param repo the repo to use when locating the blob.
  /// @param id identity of the blob to locate.
  /// @return 0 or an error code
  int git_blob_lookup(
    ffi.Pointer<ffi.Pointer<git_blob>> blob,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_blob_lookup(
      blob,
      repo,
      id,
    );
  }

  late final _git_blob_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blob>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_blob_lookup');
  late final _git_blob_lookup = _git_blob_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_blob>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a blob object from a repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param[out] blob pointer to the looked up blob
  /// @param repo the repo to use when locating the blob.
  /// @param id identity of the blob to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_blob_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_blob>> blob,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_blob_lookup_prefix(
      blob,
      repo,
      id,
      len,
    );
  }

  late final _git_blob_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blob>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_blob_lookup_prefix');
  late final _git_blob_lookup_prefix = _git_blob_lookup_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_blob>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open blob
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a blob. Failure to do so will cause a memory leak.
  ///
  /// @param blob the blob to close
  void git_blob_free(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_free(
      blob,
    );
  }

  late final _git_blob_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_blob>)>>(
          'git_blob_free');
  late final _git_blob_free =
      _git_blob_freePtr.asFunction<void Function(ffi.Pointer<git_blob>)>();

  /// Get the id of a blob.
  ///
  /// @param blob a previously loaded blob.
  /// @return SHA1 hash for this blob.
  ffi.Pointer<git_oid> git_blob_id(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_id(
      blob,
    );
  }

  late final _git_blob_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_blob>)>>('git_blob_id');
  late final _git_blob_id = _git_blob_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_blob>)>();

  /// Get the repository that contains the blob.
  ///
  /// @param blob A previously loaded blob.
  /// @return Repository that contains this blob.
  ffi.Pointer<git_repository> git_blob_owner(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_owner(
      blob,
    );
  }

  late final _git_blob_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_blob>)>>('git_blob_owner');
  late final _git_blob_owner = _git_blob_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_blob>)>();

  /// Get a read-only buffer with the raw content of a blob.
  ///
  /// A pointer to the raw content of a blob is returned;
  /// this pointer is owned internally by the object and shall
  /// not be free'd. The pointer may be invalidated at a later
  /// time.
  ///
  /// @param blob pointer to the blob
  /// @return @type `unsigned char *` the pointer, or NULL on error
  ffi.Pointer<ffi.Void> git_blob_rawcontent(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_rawcontent(
      blob,
    );
  }

  late final _git_blob_rawcontentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<git_blob>)>>('git_blob_rawcontent');
  late final _git_blob_rawcontent = _git_blob_rawcontentPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_blob>)>();

  /// Get the size in bytes of the contents of a blob
  ///
  /// @param blob pointer to the blob
  /// @return size in bytes
  int git_blob_rawsize(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_rawsize(
      blob,
    );
  }

  late final _git_blob_rawsizePtr = _lookup<
          ffi
          .NativeFunction<git_object_size_t Function(ffi.Pointer<git_blob>)>>(
      'git_blob_rawsize');
  late final _git_blob_rawsize =
      _git_blob_rawsizePtr.asFunction<int Function(ffi.Pointer<git_blob>)>();

  /// Initialize git_blob_filter_options structure
  ///
  /// Initializes a `git_blob_filter_options` with default values. Equivalent
  /// to creating an instance with `GIT_BLOB_FILTER_OPTIONS_INIT`.
  ///
  /// @param opts The `git_blob_filter_options` struct to initialize.
  /// @param version The struct version; pass GIT_BLOB_FILTER_OPTIONS_VERSION
  /// @return Zero on success; -1 on failure.
  int git_blob_filter_options_init(
    ffi.Pointer<git_blob_filter_options> opts,
    int version,
  ) {
    return _git_blob_filter_options_init(
      opts,
      version,
    );
  }

  late final _git_blob_filter_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_blob_filter_options>,
              ffi.UnsignedInt)>>('git_blob_filter_options_init');
  late final _git_blob_filter_options_init = _git_blob_filter_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_blob_filter_options>, int)>();

  /// Get a buffer with the filtered content of a blob.
  ///
  /// This applies filters as if the blob was being checked out to the
  /// working directory under the specified filename.  This may apply
  /// CRLF filtering or other types of changes depending on the file
  /// attributes set for the blob and the content detected in it.
  ///
  /// The output is written into a `git_buf` which the caller must dispose
  /// when done (via `git_buf_dispose`).
  ///
  /// If no filters need to be applied, then the `out` buffer will just
  /// be populated with a pointer to the raw content of the blob.  In
  /// that case, be careful to *not* free the blob until done with the
  /// buffer or copy it into memory you own.
  ///
  /// @param out The git_buf to be filled in
  /// @param blob Pointer to the blob
  /// @param as_path Path used for file attribute lookups, etc.
  /// @param opts Options to use for filtering the blob
  /// @return @type[enum] git_error_code 0 on success or an error code
  int git_blob_filter(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Char> as_path,
    ffi.Pointer<git_blob_filter_options> opts,
  ) {
    return _git_blob_filter(
      out,
      blob,
      as_path,
      opts,
    );
  }

  late final _git_blob_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blob_filter_options>)>>('git_blob_filter');
  late final _git_blob_filter = _git_blob_filterPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_blob_filter_options>)>();

  /// Read a file from the working folder of a repository and write it
  /// to the object database.
  ///
  /// @param[out] id return the id of the written blob
  /// @param repo repository where the blob will be written.
  /// this repository cannot be bare
  /// @param relative_path file from which the blob will be created,
  /// relative to the repository's working dir
  /// @return 0 or an error code
  int git_blob_create_from_workdir(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> relative_path,
  ) {
    return _git_blob_create_from_workdir(
      id,
      repo,
      relative_path,
    );
  }

  late final _git_blob_create_from_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_from_workdir');
  late final _git_blob_create_from_workdir =
      _git_blob_create_from_workdirPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Read a file from the filesystem (not necessarily inside the
  /// working folder of the repository) and write it to the object
  /// database.
  ///
  /// @param[out] id return the id of the written blob
  /// @param repo repository where the blob will be written.
  /// this repository can be bare or not
  /// @param path file from which the blob will be created
  /// @return 0 or an error code
  int git_blob_create_from_disk(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_blob_create_from_disk(
      id,
      repo,
      path,
    );
  }

  late final _git_blob_create_from_diskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_from_disk');
  late final _git_blob_create_from_disk =
      _git_blob_create_from_diskPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a stream to write a new blob into the object database.
  ///
  /// This function may need to buffer the data on disk and will in
  /// general not be the right choice if you know the size of the data
  /// to write. If you have data in memory, use
  /// `git_blob_create_from_buffer()`. If you do not, but know the size of
  /// the contents (and don't want/need to perform filtering), use
  /// `git_odb_open_wstream()`.
  ///
  /// Don't close this stream yourself but pass it to
  /// `git_blob_create_from_stream_commit()` to commit the write to the
  /// object db and get the object id.
  ///
  /// If the `hintpath` parameter is filled, it will be used to determine
  /// what git filters should be applied to the object before it is written
  /// to the object database.
  ///
  /// @param[out] out the stream into which to write
  /// @param repo Repository where the blob will be written.
  /// This repository can be bare or not.
  /// @param hintpath If not NULL, will be used to select data filters
  /// to apply onto the content of the blob to be created.
  /// @return 0 or error code
  int git_blob_create_from_stream(
    ffi.Pointer<ffi.Pointer<git_writestream>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> hintpath,
  ) {
    return _git_blob_create_from_stream(
      out,
      repo,
      hintpath,
    );
  }

  late final _git_blob_create_from_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_writestream>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_from_stream');
  late final _git_blob_create_from_stream =
      _git_blob_create_from_streamPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_writestream>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Close the stream and finalize writing the blob to the object database.
  ///
  /// The stream will be closed and freed.
  ///
  /// @param[out] out the id of the new blob
  /// @param stream the stream to close
  /// @return 0 or an error code
  int git_blob_create_from_stream_commit(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_writestream> stream,
  ) {
    return _git_blob_create_from_stream_commit(
      out,
      stream,
    );
  }

  late final _git_blob_create_from_stream_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_oid>, ffi.Pointer<git_writestream>)>>(
      'git_blob_create_from_stream_commit');
  late final _git_blob_create_from_stream_commit =
      _git_blob_create_from_stream_commitPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_writestream>)>();

  /// Write an in-memory buffer to the object database as a blob.
  ///
  /// @param[out] id return the id of the written blob
  /// @param repo repository where the blob will be written
  /// @param buffer data to be written into the blob
  /// @param len length of the data
  /// @return 0 or an error code
  int git_blob_create_from_buffer(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_blob_create_from_buffer(
      id,
      repo,
      buffer,
      len,
    );
  }

  late final _git_blob_create_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('git_blob_create_from_buffer');
  late final _git_blob_create_from_buffer =
      _git_blob_create_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Void>, int)>();

  /// Determine if the blob content is most likely binary or not.
  ///
  /// The heuristic used to guess if a file is binary is taken from core git:
  /// Searching for NUL bytes and looking for a reasonable ratio of printable
  /// to non-printable characters among the first 8000 bytes.
  ///
  /// @param blob The blob which content should be analyzed
  /// @return @type bool 1 if the content of the blob is detected
  /// as binary; 0 otherwise.
  int git_blob_is_binary(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_is_binary(
      blob,
    );
  }

  late final _git_blob_is_binaryPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_blob>)>>(
          'git_blob_is_binary');
  late final _git_blob_is_binary =
      _git_blob_is_binaryPtr.asFunction<int Function(ffi.Pointer<git_blob>)>();

  /// Determine if the given content is most certainly binary or not;
  /// this is the same mechanism used by `git_blob_is_binary` but only
  /// looking at raw data.
  ///
  /// @param data The blob data which content should be analyzed
  /// @param len The length of the data
  /// @return 1 if the content of the blob is detected
  /// as binary; 0 otherwise.
  int git_blob_data_is_binary(
    ffi.Pointer<ffi.Char> data,
    int len,
  ) {
    return _git_blob_data_is_binary(
      data,
      len,
    );
  }

  late final _git_blob_data_is_binaryPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>(
      'git_blob_data_is_binary');
  late final _git_blob_data_is_binary = _git_blob_data_is_binaryPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Create an in-memory copy of a blob. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param[out] out Pointer to store the copy of the object
  /// @param source Original object to copy
  /// @return 0.
  int git_blob_dup(
    ffi.Pointer<ffi.Pointer<git_blob>> out,
    ffi.Pointer<git_blob> source,
  ) {
    return _git_blob_dup(
      out,
      source,
    );
  }

  late final _git_blob_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blob>>,
              ffi.Pointer<git_blob>)>>('git_blob_dup');
  late final _git_blob_dup = _git_blob_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_blob>>, ffi.Pointer<git_blob>)>();

  /// Initialize git_blame_options structure
  ///
  /// Initializes a `git_blame_options` with default values. Equivalent to creating
  /// an instance with GIT_BLAME_OPTIONS_INIT.
  ///
  /// @param opts The `git_blame_options` struct to initialize.
  /// @param version The struct version; pass `GIT_BLAME_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_blame_options_init(
    ffi.Pointer<git_blame_options> opts,
    int version,
  ) {
    return _git_blame_options_init(
      opts,
      version,
    );
  }

  late final _git_blame_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_blame_options>,
              ffi.UnsignedInt)>>('git_blame_options_init');
  late final _git_blame_options_init = _git_blame_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_blame_options>, int)>();

  /// Gets the number of lines that exist in the blame structure.
  ///
  /// @param blame The blame structure to query.
  /// @return The number of line.
  int git_blame_linecount(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_linecount(
      blame,
    );
  }

  late final _git_blame_linecountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_blame>)>>(
          'git_blame_linecount');
  late final _git_blame_linecount = _git_blame_linecountPtr
      .asFunction<int Function(ffi.Pointer<git_blame>)>();

  /// Gets the number of hunks that exist in the blame structure.
  ///
  /// @param blame The blame structure to query.
  /// @return The number of hunks.
  int git_blame_hunkcount(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_hunkcount(
      blame,
    );
  }

  late final _git_blame_hunkcountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_blame>)>>(
          'git_blame_hunkcount');
  late final _git_blame_hunkcount = _git_blame_hunkcountPtr
      .asFunction<int Function(ffi.Pointer<git_blame>)>();

  /// Gets the blame hunk at the given index.
  ///
  /// @param blame the blame structure to query
  /// @param index index of the hunk to retrieve
  /// @return the hunk at the given index, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_hunk_byindex(
    ffi.Pointer<git_blame> blame,
    int index,
  ) {
    return _git_blame_hunk_byindex(
      blame,
      index,
    );
  }

  late final _git_blame_hunk_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_blame_hunk> Function(
              ffi.Pointer<git_blame>, ffi.Size)>>('git_blame_hunk_byindex');
  late final _git_blame_hunk_byindex = _git_blame_hunk_byindexPtr.asFunction<
      ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>, int)>();

  /// Gets the hunk that relates to the given line number in the newest
  /// commit.
  ///
  /// @param blame the blame structure to query
  /// @param lineno the (1-based) line number to find a hunk for
  /// @return the hunk that contains the given line, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_hunk_byline(
    ffi.Pointer<git_blame> blame,
    int lineno,
  ) {
    return _git_blame_hunk_byline(
      blame,
      lineno,
    );
  }

  late final _git_blame_hunk_bylinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_blame_hunk> Function(
              ffi.Pointer<git_blame>, ffi.Size)>>('git_blame_hunk_byline');
  late final _git_blame_hunk_byline = _git_blame_hunk_bylinePtr.asFunction<
      ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>, int)>();

  /// Gets the information about the line in the blame.
  ///
  /// @param blame the blame structure to query
  /// @param idx the (1-based) line number
  /// @return the blamed line, or NULL on error
  ffi.Pointer<git_blame_line> git_blame_line_byindex(
    ffi.Pointer<git_blame> blame,
    int idx,
  ) {
    return _git_blame_line_byindex(
      blame,
      idx,
    );
  }

  late final _git_blame_line_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_blame_line> Function(
              ffi.Pointer<git_blame>, ffi.Size)>>('git_blame_line_byindex');
  late final _git_blame_line_byindex = _git_blame_line_byindexPtr.asFunction<
      ffi.Pointer<git_blame_line> Function(ffi.Pointer<git_blame>, int)>();

  /// Gets the number of hunks that exist in the blame structure.
  ///
  /// @param blame The blame structure to query.
  /// @return The number of hunks.
  int git_blame_get_hunk_count(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_get_hunk_count(
      blame,
    );
  }

  late final _git_blame_get_hunk_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<git_blame>)>>(
          'git_blame_get_hunk_count');
  late final _git_blame_get_hunk_count = _git_blame_get_hunk_countPtr
      .asFunction<int Function(ffi.Pointer<git_blame>)>();

  /// Gets the blame hunk at the given index.
  ///
  /// @param blame the blame structure to query
  /// @param index index of the hunk to retrieve
  /// @return the hunk at the given index, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byindex(
    ffi.Pointer<git_blame> blame,
    int index,
  ) {
    return _git_blame_get_hunk_byindex(
      blame,
      index,
    );
  }

  late final _git_blame_get_hunk_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>,
              ffi.Uint32)>>('git_blame_get_hunk_byindex');
  late final _git_blame_get_hunk_byindex =
      _git_blame_get_hunk_byindexPtr.asFunction<
          ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>, int)>();

  /// Gets the hunk that relates to the given line number in the newest commit.
  ///
  /// @param blame the blame structure to query
  /// @param lineno the (1-based) line number to find a hunk for
  /// @return the hunk that contains the given line, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byline(
    ffi.Pointer<git_blame> blame,
    int lineno,
  ) {
    return _git_blame_get_hunk_byline(
      blame,
      lineno,
    );
  }

  late final _git_blame_get_hunk_bylinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_blame_hunk> Function(
              ffi.Pointer<git_blame>, ffi.Size)>>('git_blame_get_hunk_byline');
  late final _git_blame_get_hunk_byline =
      _git_blame_get_hunk_bylinePtr.asFunction<
          ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>, int)>();

  /// Get the blame for a single file in the repository.
  ///
  /// @param out pointer that will receive the blame object
  /// @param repo repository whose history is to be walked
  /// @param path path to file to consider
  /// @param options options for the blame operation or NULL
  /// @return 0 on success, or an error code
  int git_blame_file(
    ffi.Pointer<ffi.Pointer<git_blame>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_blame_options> options,
  ) {
    return _git_blame_file(
      out,
      repo,
      path,
      options,
    );
  }

  late final _git_blame_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blame>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blame_options>)>>('git_blame_file');
  late final _git_blame_file = _git_blame_filePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_blame>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_blame_options>)>();

  /// Get the blame for a single file in the repository, using the specified
  /// buffer contents as the uncommitted changes of the file (the working
  /// directory contents).
  ///
  /// @param out pointer that will receive the blame object
  /// @param repo repository whose history is to be walked
  /// @param path path to file to consider
  /// @param contents the uncommitted changes
  /// @param contents_len the length of the changes buffer
  /// @param options options for the blame operation or NULL
  /// @return 0 on success, or an error code
  int git_blame_file_from_buffer(
    ffi.Pointer<ffi.Pointer<git_blame>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> contents,
    int contents_len,
    ffi.Pointer<git_blame_options> options,
  ) {
    return _git_blame_file_from_buffer(
      out,
      repo,
      path,
      contents,
      contents_len,
      options,
    );
  }

  late final _git_blame_file_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blame>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<git_blame_options>)>>('git_blame_file_from_buffer');
  late final _git_blame_file_from_buffer =
      _git_blame_file_from_bufferPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_blame>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<git_blame_options>)>();

  /// Get blame data for a file that has been modified in memory. The `blame`
  /// parameter is a pre-calculated blame for the in-odb history of the file.
  /// This means that once a file blame is completed (which can be expensive),
  /// updating the buffer blame is very fast.
  ///
  /// Lines that differ between the buffer and the committed version are
  /// marked as having a zero OID for their final_commit_id.
  ///
  /// @param out pointer that will receive the resulting blame data
  /// @param base cached blame from the history of the file (usually the output
  /// from git_blame_file)
  /// @param buffer the (possibly) modified contents of the file
  /// @param buffer_len number of valid bytes in the buffer
  /// @return 0 on success, or an error code. (use git_error_last for information
  /// about the error)
  int git_blame_buffer(
    ffi.Pointer<ffi.Pointer<git_blame>> out,
    ffi.Pointer<git_blame> base,
    ffi.Pointer<ffi.Char> buffer,
    int buffer_len,
  ) {
    return _git_blame_buffer(
      out,
      base,
      buffer,
      buffer_len,
    );
  }

  late final _git_blame_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blame>>,
              ffi.Pointer<git_blame>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_blame_buffer');
  late final _git_blame_buffer = _git_blame_bufferPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_blame>>, ffi.Pointer<git_blame>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Free memory allocated by git_blame_file or git_blame_buffer.
  ///
  /// @param blame the blame structure to free
  void git_blame_free(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_free(
      blame,
    );
  }

  late final _git_blame_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_blame>)>>(
          'git_blame_free');
  late final _git_blame_free =
      _git_blame_freePtr.asFunction<void Function(ffi.Pointer<git_blame>)>();

  /// Create a new branch pointing at a target commit
  ///
  /// A new direct reference will be created pointing to
  /// this target commit. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The returned reference must be freed by the user.
  ///
  /// The branch name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out Pointer where to store the underlying reference.
  /// @param repo the repository to create the branch in.
  /// @param branch_name Name for the branch; this name is
  /// validated for consistency. It should also not conflict with
  /// an already existing branch name.
  /// @param target Commit to which this branch should point. This object
  /// must belong to the given `repo`.
  /// @param force Overwrite existing branch.
  /// @return 0, GIT_EINVALIDSPEC or an error code.
  /// A proper reference is written in the refs/heads namespace
  /// pointing to the provided target commit.
  int git_branch_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> branch_name,
    ffi.Pointer<git_commit> target,
    int force,
  ) {
    return _git_branch_create(
      out,
      repo,
      branch_name,
      target,
      force,
    );
  }

  late final _git_branch_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_commit>,
              ffi.Int)>>('git_branch_create');
  late final _git_branch_create = _git_branch_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_commit>,
          int)>();

  /// Create a new branch pointing at a target commit
  ///
  /// This behaves like `git_branch_create()` but takes an annotated
  /// commit, which lets you specify which extended sha syntax string was
  /// specified by a user, allowing for more exact reflog messages.
  ///
  /// @param ref_out Pointer where to store the underlying reference.
  /// @param repo the repository to create the branch in.
  /// @param branch_name Name for the branch; this name is
  /// validated for consistency. It should also not conflict with
  /// an already existing branch name.
  /// @param target Annotated commit to which this branch should point. This
  /// object must belong to the given `repo`.
  /// @param force Overwrite existing branch.
  /// @return 0, GIT_EINVALIDSPEC or an error code.
  int git_branch_create_from_annotated(
    ffi.Pointer<ffi.Pointer<git_reference>> ref_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> branch_name,
    ffi.Pointer<git_annotated_commit> target,
    int force,
  ) {
    return _git_branch_create_from_annotated(
      ref_out,
      repo,
      branch_name,
      target,
      force,
    );
  }

  late final _git_branch_create_from_annotatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Int)>>('git_branch_create_from_annotated');
  late final _git_branch_create_from_annotated =
      _git_branch_create_from_annotatedPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_annotated_commit>,
              int)>();

  /// Delete an existing branch reference.
  ///
  /// Note that if the deletion succeeds, the reference object will not
  /// be valid anymore, and should be freed immediately by the user using
  /// `git_reference_free()`.
  ///
  /// @param branch A valid reference representing a branch
  /// @return 0 on success, or an error code.
  int git_branch_delete(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_delete(
      branch,
    );
  }

  late final _git_branch_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_branch_delete');
  late final _git_branch_delete = _git_branch_deletePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Create an iterator which loops over the requested branches.
  ///
  /// @param out the iterator
  /// @param repo Repository where to find the branches.
  /// @param list_flags Filtering flags for the branch
  /// listing. Valid values are GIT_BRANCH_LOCAL, GIT_BRANCH_REMOTE
  /// or GIT_BRANCH_ALL.
  ///
  /// @return 0 on success  or an error code
  int git_branch_iterator_new(
    ffi.Pointer<ffi.Pointer<git_branch_iterator>> out,
    ffi.Pointer<git_repository> repo,
    git_branch_t list_flags,
  ) {
    return _git_branch_iterator_new(
      out,
      repo,
      list_flags.value,
    );
  }

  late final _git_branch_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_branch_iterator>>,
              ffi.Pointer<git_repository>,
              ffi.UnsignedInt)>>('git_branch_iterator_new');
  late final _git_branch_iterator_new = _git_branch_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_branch_iterator>>,
          ffi.Pointer<git_repository>, int)>();

  /// Retrieve the next branch from the iterator
  ///
  /// @param out the reference
  /// @param out_type the type of branch (local or remote-tracking)
  /// @param iter the branch iterator
  /// @return 0 on success, GIT_ITEROVER if there are no more branches or an error code.
  int git_branch_next(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<ffi.UnsignedInt> out_type,
    ffi.Pointer<git_branch_iterator> iter,
  ) {
    return _git_branch_next(
      out,
      out_type,
      iter,
    );
  }

  late final _git_branch_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_branch_iterator>)>>('git_branch_next');
  late final _git_branch_next = _git_branch_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<git_branch_iterator>)>();

  /// Free a branch iterator
  ///
  /// @param iter the iterator to free
  void git_branch_iterator_free(
    ffi.Pointer<git_branch_iterator> iter,
  ) {
    return _git_branch_iterator_free(
      iter,
    );
  }

  late final _git_branch_iterator_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<git_branch_iterator>)>>(
      'git_branch_iterator_free');
  late final _git_branch_iterator_free = _git_branch_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_branch_iterator>)>();

  /// Move/rename an existing local branch reference.
  ///
  /// The new branch name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// Note that if the move succeeds, the old reference object will not
  /// be valid anymore, and should be freed immediately by the user using
  /// `git_reference_free()`.
  ///
  /// @param out New reference object for the updated name.
  ///
  /// @param branch Current underlying reference of the branch.
  ///
  /// @param new_branch_name Target name of the branch once the move
  /// is performed; this name is validated for consistency.
  ///
  /// @param force Overwrite existing branch.
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code.
  int git_branch_move(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
    ffi.Pointer<ffi.Char> new_branch_name,
    int force,
  ) {
    return _git_branch_move(
      out,
      branch,
      new_branch_name,
      force,
    );
  }

  late final _git_branch_movePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_branch_move');
  late final _git_branch_move = _git_branch_movePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>, ffi.Pointer<ffi.Char>, int)>();

  /// Lookup a branch by its name in a repository.
  ///
  /// The generated reference must be freed by the user.
  /// The branch name will be checked for validity.
  ///
  /// @see git_tag_create for rules about valid names.
  ///
  /// @param out pointer to the looked-up branch reference
  /// @param repo the repository to look up the branch
  /// @param branch_name Name of the branch to be looked-up;
  /// this name is validated for consistency.
  /// @param branch_type Type of the considered branch. This should
  /// be valued with either GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no matching branch
  /// exists, GIT_EINVALIDSPEC, otherwise an error code.
  int git_branch_lookup(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> branch_name,
    git_branch_t branch_type,
  ) {
    return _git_branch_lookup(
      out,
      repo,
      branch_name,
      branch_type.value,
    );
  }

  late final _git_branch_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_branch_lookup');
  late final _git_branch_lookup = _git_branch_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the branch name
  ///
  /// Given a reference object, this will check that it really is a branch (ie.
  /// it lives under "refs/heads/" or "refs/remotes/"), and return the branch part
  /// of it.
  ///
  /// @param out Pointer to the abbreviated reference name.
  /// Owned by ref, do not free.
  ///
  /// @param ref A reference object, ideally pointing to a branch
  ///
  /// @return 0 on success; GIT_EINVALID if the reference isn't either a local or
  /// remote branch, otherwise an error code.
  int git_branch_name(
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_branch_name(
      out,
      ref,
    );
  }

  late final _git_branch_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_reference>)>>('git_branch_name');
  late final _git_branch_name = _git_branch_namePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<git_reference>)>();

  /// Get the upstream of a branch
  ///
  /// Given a reference, this will return a new reference object corresponding
  /// to its remote tracking branch. The reference must be a local branch.
  ///
  /// @see git_branch_upstream_name for details on the resolution.
  ///
  /// @param out Pointer where to store the retrieved reference.
  /// @param branch Current underlying reference of the branch.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no remote tracking
  /// reference exists, otherwise an error code.
  int git_branch_upstream(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_upstream(
      out,
      branch,
    );
  }

  late final _git_branch_upstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_branch_upstream');
  late final _git_branch_upstream = _git_branch_upstreamPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Set a branch's upstream branch
  ///
  /// This will update the configuration to set the branch named `branch_name` as the upstream of `branch`.
  /// Pass a NULL name to unset the upstream information.
  ///
  /// @note the actual tracking reference must have been already created for the
  /// operation to succeed.
  ///
  /// @param branch the branch to configure
  /// @param branch_name remote-tracking or local branch to set as upstream.
  ///
  /// @return @type git_error_t 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`
  /// or an error code
  int git_branch_set_upstream(
    ffi.Pointer<git_reference> branch,
    ffi.Pointer<ffi.Char> branch_name,
  ) {
    return _git_branch_set_upstream(
      branch,
      branch_name,
    );
  }

  late final _git_branch_set_upstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>)>>('git_branch_set_upstream');
  late final _git_branch_set_upstream = _git_branch_set_upstreamPtr.asFunction<
      int Function(ffi.Pointer<git_reference>, ffi.Pointer<ffi.Char>)>();

  /// Get the upstream name of a branch
  ///
  /// Given a local branch, this will return its remote-tracking branch information,
  /// as a full reference name, ie. "feature/nice" would become
  /// "refs/remote/origin/feature/nice", depending on that branch's configuration.
  ///
  /// @param out the buffer into which the name will be written.
  /// @param repo the repository where the branches live.
  /// @param refname reference name of the local branch.
  ///
  /// @return 0 on success, GIT_ENOTFOUND when no remote tracking reference exists,
  /// or an error code.
  int git_branch_upstream_name(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_upstream_name(
      out,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_upstream_name');
  late final _git_branch_upstream_name =
      _git_branch_upstream_namePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Determine if HEAD points to the given branch
  ///
  /// @param branch A reference to a local branch.
  ///
  /// @return 1 if HEAD points at the branch, 0 if it isn't, or a negative value
  /// as an error code.
  int git_branch_is_head(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_is_head(
      branch,
    );
  }

  late final _git_branch_is_headPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_branch_is_head');
  late final _git_branch_is_head = _git_branch_is_headPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Determine if any HEAD points to the current branch
  ///
  /// This will iterate over all known linked repositories (usually in the form of
  /// worktrees) and report whether any HEAD is pointing at the current branch.
  ///
  /// @param branch A reference to a local branch.
  ///
  /// @return 1 if branch is checked out, 0 if it isn't, an error code otherwise.
  int git_branch_is_checked_out(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_is_checked_out(
      branch,
    );
  }

  late final _git_branch_is_checked_outPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_branch_is_checked_out');
  late final _git_branch_is_checked_out = _git_branch_is_checked_outPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Find the remote name of a remote-tracking branch
  ///
  /// This will return the name of the remote whose fetch refspec is matching
  /// the given branch. E.g. given a branch "refs/remotes/test/master", it will
  /// extract the "test" part. If refspecs from multiple remotes match,
  /// the function will return GIT_EAMBIGUOUS.
  ///
  /// @param out The buffer into which the name will be written.
  /// @param repo The repository where the branch lives.
  /// @param refname complete name of the remote tracking branch.
  ///
  /// @return 0 on success, GIT_ENOTFOUND when no matching remote was found,
  /// GIT_EAMBIGUOUS when the branch maps to several remotes,
  /// otherwise an error code.
  int git_branch_remote_name(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_remote_name(
      out,
      repo,
      refname,
    );
  }

  late final _git_branch_remote_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_remote_name');
  late final _git_branch_remote_name = _git_branch_remote_namePtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Retrieve the upstream remote of a local branch
  ///
  /// This will return the currently configured "branch.*.remote" for a given
  /// branch. This branch must be local.
  ///
  /// @param buf the buffer into which to write the name
  /// @param repo the repository in which to look
  /// @param refname the full name of the branch
  /// @return 0 or an error code
  int git_branch_upstream_remote(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_upstream_remote(
      buf,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_remotePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_upstream_remote');
  late final _git_branch_upstream_remote =
      _git_branch_upstream_remotePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Retrieve the upstream merge of a local branch
  ///
  /// This will return the currently configured "branch.*.merge" for a given
  /// branch. This branch must be local.
  ///
  /// @param buf the buffer into which to write the name
  /// @param repo the repository in which to look
  /// @param refname the full name of the branch
  /// @return 0 or an error code
  int git_branch_upstream_merge(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_upstream_merge(
      buf,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_upstream_merge');
  late final _git_branch_upstream_merge =
      _git_branch_upstream_mergePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Determine whether a branch name is valid, meaning that (when prefixed
  /// with `refs/heads/`) that it is a valid reference name, and that any
  /// additional branch name restrictions are imposed (eg, it cannot start
  /// with a `-`).
  ///
  /// @param valid output pointer to set with validity of given branch name
  /// @param name a branch name to test
  /// @return 0 on success or an error code
  int git_branch_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_branch_name_is_valid(
      valid,
      name,
    );
  }

  late final _git_branch_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_branch_name_is_valid');
  late final _git_branch_name_is_valid = _git_branch_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Initialize git_checkout_options structure
  ///
  /// Initializes a `git_checkout_options` with default values. Equivalent to creating
  /// an instance with GIT_CHECKOUT_OPTIONS_INIT.
  ///
  /// @param opts The `git_checkout_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHECKOUT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_checkout_options_init(
    ffi.Pointer<git_checkout_options> opts,
    int version,
  ) {
    return _git_checkout_options_init(
      opts,
      version,
    );
  }

  late final _git_checkout_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_checkout_options>,
              ffi.UnsignedInt)>>('git_checkout_options_init');
  late final _git_checkout_options_init = _git_checkout_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_checkout_options>, int)>();

  /// Updates files in the index and the working tree to match the content of
  /// the commit pointed at by HEAD.
  ///
  /// Note that this is _not_ the correct mechanism used to switch branches;
  /// do not change your `HEAD` and then call this method, that would leave
  /// you with checkout conflicts since your working directory would then
  /// appear to be dirty.  Instead, checkout the target of the branch and
  /// then update `HEAD` using `git_repository_set_head` to point to the
  /// branch you checked out.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, GIT_EUNBORNBRANCH if HEAD points to a non
  /// existing branch, non-zero value returned by `notify_cb`, or
  /// other error code < 0 (use git_error_last for error details)
  int git_checkout_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_head(
      repo,
      opts,
    );
  }

  late final _git_checkout_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_head');
  late final _git_checkout_head = _git_checkout_headPtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>, ffi.Pointer<git_checkout_options>)>();

  /// Updates files in the working tree to match the content of the index.
  ///
  /// @param repo repository into which to check out (must be non-bare)
  /// @param index index to be checked out (or NULL to use repository index)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int git_checkout_index(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_index(
      repo,
      index,
      opts,
    );
  }

  late final _git_checkout_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_index>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_index');
  late final _git_checkout_index = _git_checkout_indexPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_index>,
          ffi.Pointer<git_checkout_options>)>();

  /// Updates files in the index and working tree to match the content of the
  /// tree pointed at by the treeish.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param treeish a commit, tag or tree which content will be used to update
  /// the working directory (or NULL to use HEAD)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int git_checkout_tree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_tree(
      repo,
      treeish,
      opts,
    );
  }

  late final _git_checkout_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_tree');
  late final _git_checkout_tree = _git_checkout_treePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
          ffi.Pointer<git_checkout_options>)>();

  /// Initialize git_index_options structure
  ///
  /// Initializes a `git_index_options` with default values. Equivalent to creating
  /// an instance with GIT_INDEX_OPTIONS_INIT.
  ///
  /// @param opts The `git_index_options` struct to initialize.
  /// @param version The struct version; pass `GIT_INDEX_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_index_options_init(
    ffi.Pointer<git_index_options> opts,
    int version,
  ) {
    return _git_index_options_init(
      opts,
      version,
    );
  }

  late final _git_index_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index_options>,
              ffi.UnsignedInt)>>('git_index_options_init');
  late final _git_index_options_init = _git_index_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_index_options>, int)>();

  /// Creates a new bare Git index object, without a repository to back
  /// it. This index object is capable of storing SHA256 objects.
  ///
  /// @param index_out the pointer for the new index
  /// @param index_path the path to the index file in disk
  /// @param opts the options for opening the index, or NULL
  /// @return 0 or an error code
  int git_index_open(
    ffi.Pointer<ffi.Pointer<git_index>> index_out,
    ffi.Pointer<ffi.Char> index_path,
    ffi.Pointer<git_index_options> opts,
  ) {
    return _git_index_open(
      index_out,
      index_path,
      opts,
    );
  }

  late final _git_index_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_index_options>)>>('git_index_open');
  late final _git_index_open = _git_index_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_index>>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_index_options>)>();

  /// Create an in-memory index object.
  ///
  /// @param index_out the pointer for the new index
  /// @param opts the options for opening the index, or NULL
  /// @return 0 or an error code
  int git_index_new(
    ffi.Pointer<ffi.Pointer<git_index>> index_out,
    ffi.Pointer<git_index_options> opts,
  ) {
    return _git_index_new(
      index_out,
      opts,
    );
  }

  late final _git_index_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_index_options>)>>('git_index_new');
  late final _git_index_new = _git_index_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_index_options>)>();

  /// Free an existing index object.
  ///
  /// @param index an existing index object
  void git_index_free(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_free(
      index,
    );
  }

  late final _git_index_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_index>)>>(
          'git_index_free');
  late final _git_index_free =
      _git_index_freePtr.asFunction<void Function(ffi.Pointer<git_index>)>();

  /// Get the repository this index relates to
  ///
  /// @param index The index
  /// @return A pointer to the repository
  ffi.Pointer<git_repository> git_index_owner(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_owner(
      index,
    );
  }

  late final _git_index_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_index>)>>('git_index_owner');
  late final _git_index_owner = _git_index_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_index>)>();

  /// Read index capabilities flags.
  ///
  /// @param index An existing index object
  /// @return A combination of GIT_INDEX_CAPABILITY values
  int git_index_caps(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_caps(
      index,
    );
  }

  late final _git_index_capsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_caps');
  late final _git_index_caps =
      _git_index_capsPtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Set index capabilities flags.
  ///
  /// If you pass `GIT_INDEX_CAPABILITY_FROM_OWNER` for the caps, then
  /// capabilities will be read from the config of the owner object,
  /// looking at `core.ignorecase`, `core.filemode`, `core.symlinks`.
  ///
  /// @param index An existing index object
  /// @param caps A combination of GIT_INDEX_CAPABILITY values
  /// @return 0 on success, -1 on failure
  int git_index_set_caps(
    ffi.Pointer<git_index> index,
    int caps,
  ) {
    return _git_index_set_caps(
      index,
      caps,
    );
  }

  late final _git_index_set_capsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<git_index>, ffi.Int)>>(
      'git_index_set_caps');
  late final _git_index_set_caps = _git_index_set_capsPtr
      .asFunction<int Function(ffi.Pointer<git_index>, int)>();

  /// Get index on-disk version.
  ///
  /// Valid return values are 2, 3, or 4.  If 3 is returned, an index
  /// with version 2 may be written instead, if the extension data in
  /// version 3 is not necessary.
  ///
  /// @param index An existing index object
  /// @return the index version
  int git_index_version(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_version(
      index,
    );
  }

  late final _git_index_versionPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<git_index>)>>(
      'git_index_version');
  late final _git_index_version =
      _git_index_versionPtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Set index on-disk version.
  ///
  /// Valid values are 2, 3, or 4.  If 2 is given, git_index_write may
  /// write an index with version 3 instead, if necessary to accurately
  /// represent the index.
  ///
  /// @param index An existing index object
  /// @param version The new version number
  /// @return 0 on success, -1 on failure
  int git_index_set_version(
    ffi.Pointer<git_index> index,
    int version,
  ) {
    return _git_index_set_version(
      index,
      version,
    );
  }

  late final _git_index_set_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.UnsignedInt)>>('git_index_set_version');
  late final _git_index_set_version = _git_index_set_versionPtr
      .asFunction<int Function(ffi.Pointer<git_index>, int)>();

  /// Update the contents of an existing index object in memory by reading
  /// from the hard disk.
  ///
  /// If `force` is true, this performs a "hard" read that discards in-memory
  /// changes and always reloads the on-disk index data.  If there is no
  /// on-disk version, the index will be cleared.
  ///
  /// If `force` is false, this does a "soft" read that reloads the index
  /// data from disk only if it has changed since the last time it was
  /// loaded.  Purely in-memory index data will be untouched.  Be aware: if
  /// there are changes on disk, unwritten in-memory changes are discarded.
  ///
  /// @param index an existing index object
  /// @param force if true, always reload, vs. only read if file has changed
  /// @return 0 or an error code
  int git_index_read(
    ffi.Pointer<git_index> index,
    int force,
  ) {
    return _git_index_read(
      index,
      force,
    );
  }

  late final _git_index_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Int)>>('git_index_read');
  late final _git_index_read = _git_index_readPtr
      .asFunction<int Function(ffi.Pointer<git_index>, int)>();

  /// Write an existing index object from memory back to disk
  /// using an atomic file lock.
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_write(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_write(
      index,
    );
  }

  late final _git_index_writePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_write');
  late final _git_index_write =
      _git_index_writePtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Get the full path to the index file on disk.
  ///
  /// @param index an existing index object
  /// @return path to index file or NULL for in-memory index
  ffi.Pointer<ffi.Char> git_index_path(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_path(
      index,
    );
  }

  late final _git_index_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_index>)>>('git_index_path');
  late final _git_index_path = _git_index_pathPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_index>)>();

  /// Get the checksum of the index
  ///
  /// This checksum is the SHA-1 hash over the index file (except the
  /// last 20 bytes which are the checksum itself). In cases where the
  /// index does not exist on-disk, it will be zeroed out.
  ///
  /// @deprecated this function is deprecated with no replacement
  /// @param index an existing index object
  /// @return a pointer to the checksum of the index
  ffi.Pointer<git_oid> git_index_checksum(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_checksum(
      index,
    );
  }

  late final _git_index_checksumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_index>)>>('git_index_checksum');
  late final _git_index_checksum = _git_index_checksumPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_index>)>();

  /// Read a tree into the index file with stats
  ///
  /// The current index contents will be replaced by the specified tree.
  ///
  /// @param index an existing index object
  /// @param tree tree to read
  /// @return 0 or an error code
  int git_index_read_tree(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_index_read_tree(
      index,
      tree,
    );
  }

  late final _git_index_read_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<git_tree>)>>('git_index_read_tree');
  late final _git_index_read_tree = _git_index_read_treePtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_tree>)>();

  /// Write the index as a tree
  ///
  /// This method will scan the index and write a representation
  /// of its current state back to disk; it recursively creates
  /// tree objects for each of the subtrees stored in the index,
  /// but only returns the OID of the root tree. This is the OID
  /// that can be used e.g. to create a commit.
  ///
  /// The index instance cannot be bare, and needs to be associated
  /// to an existing repository.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store the OID of the written tree
  /// @param index Index to write
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int git_index_write_tree(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_write_tree(
      out,
      index,
    );
  }

  late final _git_index_write_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_index>)>>('git_index_write_tree');
  late final _git_index_write_tree = _git_index_write_treePtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_index>)>();

  /// Write the index as a tree to the given repository
  ///
  /// This method will do the same as `git_index_write_tree`, but
  /// letting the user choose the repository where the tree will
  /// be written.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store OID of the written tree
  /// @param index Index to write
  /// @param repo Repository where to write the tree
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int git_index_write_tree_to(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_index_write_tree_to(
      out,
      index,
      repo,
    );
  }

  late final _git_index_write_tree_toPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_index>,
              ffi.Pointer<git_repository>)>>('git_index_write_tree_to');
  late final _git_index_write_tree_to = _git_index_write_tree_toPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_index>,
          ffi.Pointer<git_repository>)>();

  /// Get the count of entries currently in the index
  ///
  /// @param index an existing index object
  /// @return integer of count of current entries
  int git_index_entrycount(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_entrycount(
      index,
    );
  }

  late final _git_index_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_index>)>>(
          'git_index_entrycount');
  late final _git_index_entrycount = _git_index_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Clear the contents (all the entries) of an index object.
  ///
  /// This clears the index object in memory; changes must be explicitly
  /// written to disk for them to take effect persistently.
  ///
  /// @param index an existing index object
  /// @return 0 on success, error code < 0 on failure
  int git_index_clear(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_clear(
      index,
    );
  }

  late final _git_index_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_clear');
  late final _git_index_clear =
      _git_index_clearPtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Get a pointer to one of the entries in the index
  ///
  /// The entry is not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param index an existing index object
  /// @param n the position of the entry
  /// @return a pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_index_entry> git_index_get_byindex(
    ffi.Pointer<git_index> index,
    int n,
  ) {
    return _git_index_get_byindex(
      index,
      n,
    );
  }

  late final _git_index_get_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_index_entry> Function(
              ffi.Pointer<git_index>, ffi.Size)>>('git_index_get_byindex');
  late final _git_index_get_byindex = _git_index_get_byindexPtr.asFunction<
      ffi.Pointer<git_index_entry> Function(ffi.Pointer<git_index>, int)>();

  /// Get a pointer to one of the entries in the index
  ///
  /// The entry is not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param index an existing index object
  /// @param path path to search
  /// @param stage stage to search
  /// @return a pointer to the entry; NULL if it was not found
  ffi.Pointer<git_index_entry> git_index_get_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
    int stage,
  ) {
    return _git_index_get_bypath(
      index,
      path,
      stage,
    );
  }

  late final _git_index_get_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_index_entry> Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_index_get_bypath');
  late final _git_index_get_bypath = _git_index_get_bypathPtr.asFunction<
      ffi.Pointer<git_index_entry> Function(
          ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>, int)>();

  /// Remove an entry from the index
  ///
  /// @param index an existing index object
  /// @param path path to search
  /// @param stage stage to search
  /// @return 0 or an error code
  int git_index_remove(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
    int stage,
  ) {
    return _git_index_remove(
      index,
      path,
      stage,
    );
  }

  late final _git_index_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_index_remove');
  late final _git_index_remove = _git_index_removePtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>, int)>();

  /// Remove all entries from the index under a given directory
  ///
  /// @param index an existing index object
  /// @param dir container directory path
  /// @param stage stage to search
  /// @return 0 or an error code
  int git_index_remove_directory(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> dir,
    int stage,
  ) {
    return _git_index_remove_directory(
      index,
      dir,
      stage,
    );
  }

  late final _git_index_remove_directoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_index_remove_directory');
  late final _git_index_remove_directory =
      _git_index_remove_directoryPtr.asFunction<
          int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>, int)>();

  /// Add or update an index entry from an in-memory struct
  ///
  /// If a previous index entry exists that has the same path and stage
  /// as the given 'source_entry', it will be replaced.  Otherwise, the
  /// 'source_entry' will be added.
  ///
  /// A full copy (including the 'path' string) of the given
  /// 'source_entry' will be inserted on the index.
  ///
  /// @param index an existing index object
  /// @param source_entry new entry object
  /// @return 0 or an error code
  int git_index_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> source_entry,
  ) {
    return _git_index_add(
      index,
      source_entry,
    );
  }

  late final _git_index_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<git_index_entry>)>>('git_index_add');
  late final _git_index_add = _git_index_addPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>)>();

  /// Return the stage number from a git index entry
  ///
  /// This entry is calculated from the entry's flag attribute like this:
  ///
  /// (entry->flags & GIT_INDEX_ENTRY_STAGEMASK) >> GIT_INDEX_ENTRY_STAGESHIFT
  ///
  /// @param entry The entry
  /// @return the stage number
  int git_index_entry_stage(
    ffi.Pointer<git_index_entry> entry,
  ) {
    return _git_index_entry_stage(
      entry,
    );
  }

  late final _git_index_entry_stagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index_entry>)>>(
      'git_index_entry_stage');
  late final _git_index_entry_stage = _git_index_entry_stagePtr
      .asFunction<int Function(ffi.Pointer<git_index_entry>)>();

  /// Return whether the given index entry is a conflict (has a high stage
  /// entry).  This is simply shorthand for `git_index_entry_stage > 0`.
  ///
  /// @param entry The entry
  /// @return 1 if the entry is a conflict entry, 0 otherwise
  int git_index_entry_is_conflict(
    ffi.Pointer<git_index_entry> entry,
  ) {
    return _git_index_entry_is_conflict(
      entry,
    );
  }

  late final _git_index_entry_is_conflictPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index_entry>)>>(
      'git_index_entry_is_conflict');
  late final _git_index_entry_is_conflict = _git_index_entry_is_conflictPtr
      .asFunction<int Function(ffi.Pointer<git_index_entry>)>();

  /// Create an iterator that will return every entry contained in the
  /// index at the time of creation.  Entries are returned in order,
  /// sorted by path.  This iterator is backed by a snapshot that allows
  /// callers to modify the index while iterating without affecting the
  /// iterator.
  ///
  /// @param iterator_out The newly created iterator
  /// @param index The index to iterate
  /// @return 0 or an error code.
  int git_index_iterator_new(
    ffi.Pointer<ffi.Pointer<git_index_iterator>> iterator_out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_iterator_new(
      iterator_out,
      index,
    );
  }

  late final _git_index_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_iterator>>,
              ffi.Pointer<git_index>)>>('git_index_iterator_new');
  late final _git_index_iterator_new = _git_index_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_index_iterator>>,
          ffi.Pointer<git_index>)>();

  /// Return the next index entry in-order from the iterator.
  ///
  /// @param out Pointer to store the index entry in
  /// @param iterator The iterator
  /// @return 0, GIT_ITEROVER on iteration completion or an error code
  int git_index_iterator_next(
    ffi.Pointer<ffi.Pointer<git_index_entry>> out,
    ffi.Pointer<git_index_iterator> iterator,
  ) {
    return _git_index_iterator_next(
      out,
      iterator,
    );
  }

  late final _git_index_iterator_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<git_index_iterator>)>>('git_index_iterator_next');
  late final _git_index_iterator_next = _git_index_iterator_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<git_index_iterator>)>();

  /// Free the index iterator
  ///
  /// @param iterator The iterator to free
  void git_index_iterator_free(
    ffi.Pointer<git_index_iterator> iterator,
  ) {
    return _git_index_iterator_free(
      iterator,
    );
  }

  late final _git_index_iterator_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<git_index_iterator>)>>(
      'git_index_iterator_free');
  late final _git_index_iterator_free = _git_index_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_index_iterator>)>();

  /// Add or update an index entry from a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder and must be readable.
  ///
  /// This method will fail in bare index instances.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to add
  /// @return 0 or an error code
  int git_index_add_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_add_bypath(
      index,
      path,
    );
  }

  late final _git_index_add_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_add_bypath');
  late final _git_index_add_bypath = _git_index_add_bypathPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>)>();

  /// Add or update an index entry from a buffer in memory
  ///
  /// This method will create a blob in the repository that owns the
  /// index and then add the index entry to the index.  The `path` of the
  /// entry represents the position of the blob relative to the
  /// repository's root folder.
  ///
  /// If a previous index entry exists that has the same path as the
  /// given 'entry', it will be replaced.  Otherwise, the 'entry' will be
  /// added.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param entry filename to add
  /// @param buffer data to be written into the blob
  /// @param len length of the data
  /// @return 0 or an error code
  int git_index_add_from_buffer(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> entry,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_index_add_from_buffer(
      index,
      entry,
      buffer,
      len,
    );
  }

  late final _git_index_add_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('git_index_add_from_buffer');
  late final _git_index_add_from_buffer =
      _git_index_add_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
              ffi.Pointer<ffi.Void>, int)>();

  /// Remove an index entry corresponding to a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder.  It may exist.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to remove
  /// @return 0 or an error code
  int git_index_remove_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_remove_bypath(
      index,
      path,
    );
  }

  late final _git_index_remove_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_remove_bypath');
  late final _git_index_remove_bypath = _git_index_remove_bypathPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>)>();

  /// Add or update index entries matching files in the working directory.
  ///
  /// This method will fail in bare index instances.
  ///
  /// The `pathspec` is a list of file names or shell glob patterns that will
  /// be matched against files in the repository's working directory.  Each
  /// file that matches will be added to the index (either updating an
  /// existing entry or adding a new entry).  You can disable glob expansion
  /// and force exact matching with the `GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH`
  /// flag.
  ///
  /// Files that are ignored will be skipped (unlike `git_index_add_bypath`).
  /// If a file is already tracked in the index, then it *will* be updated
  /// even if it is ignored.  Pass the `GIT_INDEX_ADD_FORCE` flag to skip
  /// the checking of ignore rules.
  ///
  /// To emulate `git add -A` and generate an error if the pathspec contains
  /// the exact path of an ignored file (when not using FORCE), add the
  /// `GIT_INDEX_ADD_CHECK_PATHSPEC` flag.  This checks that each entry
  /// in the `pathspec` that is an exact match to a filename on disk is
  /// either not ignored or already in the index.  If this check fails, the
  /// function will return GIT_EINVALIDSPEC.
  ///
  /// To emulate `git add -A` with the "dry-run" option, just use a callback
  /// function that always returns a positive value.  See below for details.
  ///
  /// If any files are currently the result of a merge conflict, those files
  /// will no longer be marked as conflicting.  The data about the conflicts
  /// will be moved to the "resolve undo" (REUC) section.
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the working directory immediately *before* it is added to /
  /// updated in the index.  Returning zero will add the item to the index,
  /// greater than zero will skip the item, and less than zero will abort the
  /// scan and return that value to the caller.
  ///
  /// @param index an existing index object
  /// @param pathspec array of path patterns
  /// @param flags combination of git_index_add_option_t flags
  /// @param callback notification callback for each added/updated path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_add_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    int flags,
    git_index_matched_path_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_add_all(
      index,
      pathspec,
      flags,
      callback,
      payload,
    );
  }

  late final _git_index_add_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_strarray>,
              ffi.UnsignedInt,
              git_index_matched_path_cb,
              ffi.Pointer<ffi.Void>)>>('git_index_add_all');
  late final _git_index_add_all = _git_index_add_allPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_strarray>, int,
          git_index_matched_path_cb, ffi.Pointer<ffi.Void>)>();

  /// Remove all matching index entries.
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the index immediately *before* it is removed.  Return 0 to
  /// remove the item, > 0 to skip the item, and < 0 to abort the scan.
  ///
  /// @param index An existing index object
  /// @param pathspec array of path patterns
  /// @param callback notification callback for each removed path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_remove_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    git_index_matched_path_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_remove_all(
      index,
      pathspec,
      callback,
      payload,
    );
  }

  late final _git_index_remove_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_strarray>,
              git_index_matched_path_cb,
              ffi.Pointer<ffi.Void>)>>('git_index_remove_all');
  late final _git_index_remove_all = _git_index_remove_allPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_strarray>,
          git_index_matched_path_cb, ffi.Pointer<ffi.Void>)>();

  /// Update all index entries to match the working directory
  ///
  /// This method will fail in bare index instances.
  ///
  /// This scans the existing index entries and synchronizes them with the
  /// working directory, deleting them if the corresponding working directory
  /// file no longer exists otherwise updating the information (including
  /// adding the latest version of file to the ODB if needed).
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the index immediately *before* it is updated (either refreshed
  /// or removed depending on working directory state).  Return 0 to proceed
  /// with updating the item, > 0 to skip the item, and < 0 to abort the scan.
  ///
  /// @param index An existing index object
  /// @param pathspec array of path patterns
  /// @param callback notification callback for each updated path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_update_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    git_index_matched_path_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_update_all(
      index,
      pathspec,
      callback,
      payload,
    );
  }

  late final _git_index_update_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_strarray>,
              git_index_matched_path_cb,
              ffi.Pointer<ffi.Void>)>>('git_index_update_all');
  late final _git_index_update_all = _git_index_update_allPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_strarray>,
          git_index_matched_path_cb, ffi.Pointer<ffi.Void>)>();

  /// Find the first position of any entries which point to given
  /// path in the Git index.
  ///
  /// @param at_pos the address to which the position of the index entry is written (optional)
  /// @param index an existing index object
  /// @param path path to search
  /// @return 0 or an error code
  int git_index_find(
    ffi.Pointer<ffi.Size> at_pos,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_find(
      at_pos,
      index,
      path,
    );
  }

  late final _git_index_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_find');
  late final _git_index_find = _git_index_findPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>)>();

  /// Find the first position of any entries matching a prefix. To find the first position
  /// of a path inside a given folder, suffix the prefix with a '/'.
  ///
  /// @param at_pos the address to which the position of the index entry is written (optional)
  /// @param index an existing index object
  /// @param prefix the prefix to search for
  /// @return 0 or an error code
  int git_index_find_prefix(
    ffi.Pointer<ffi.Size> at_pos,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> prefix,
  ) {
    return _git_index_find_prefix(
      at_pos,
      index,
      prefix,
    );
  }

  late final _git_index_find_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_find_prefix');
  late final _git_index_find_prefix = _git_index_find_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>)>();

  /// Add or update index entries to represent a conflict.  Any staged
  /// entries that exist at the given paths will be removed.
  ///
  /// The entries are the entries from the tree included in the merge.  Any
  /// entry may be null to indicate that that file was not present in the
  /// trees during the merge.  For example, ancestor_entry may be NULL to
  /// indicate that a file was added in both branches and must be resolved.
  ///
  /// @param index an existing index object
  /// @param ancestor_entry the entry data for the ancestor of the conflict
  /// @param our_entry the entry data for our side of the merge conflict
  /// @param their_entry the entry data for their side of the merge conflict
  /// @return 0 or an error code
  int git_index_conflict_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> ancestor_entry,
    ffi.Pointer<git_index_entry> our_entry,
    ffi.Pointer<git_index_entry> their_entry,
  ) {
    return _git_index_conflict_add(
      index,
      ancestor_entry,
      our_entry,
      their_entry,
    );
  }

  late final _git_index_conflict_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>)>>('git_index_conflict_add');
  late final _git_index_conflict_add = _git_index_conflict_addPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
          ffi.Pointer<git_index_entry>, ffi.Pointer<git_index_entry>)>();

  /// Get the index entries that represent a conflict of a single file.
  ///
  /// The entries are not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param ancestor_out Pointer to store the ancestor entry
  /// @param our_out Pointer to store the our entry
  /// @param their_out Pointer to store the their entry
  /// @param index an existing index object
  /// @param path path to search
  /// @return 0 or an error code
  int git_index_conflict_get(
    ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_conflict_get(
      ancestor_out,
      our_out,
      their_out,
      index,
      path,
    );
  }

  late final _git_index_conflict_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_conflict_get');
  late final _git_index_conflict_get = _git_index_conflict_getPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>)>();

  /// Removes the index entries that represent a conflict of a single file.
  ///
  /// @param index an existing index object
  /// @param path path to remove conflicts for
  /// @return 0 or an error code
  int git_index_conflict_remove(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_conflict_remove(
      index,
      path,
    );
  }

  late final _git_index_conflict_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_conflict_remove');
  late final _git_index_conflict_remove =
      _git_index_conflict_removePtr.asFunction<
          int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>)>();

  /// Remove all conflicts in the index (entries with a stage greater than 0).
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_conflict_cleanup(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_conflict_cleanup(
      index,
    );
  }

  late final _git_index_conflict_cleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_conflict_cleanup');
  late final _git_index_conflict_cleanup = _git_index_conflict_cleanupPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Determine if the index contains entries representing file conflicts.
  ///
  /// @param index An existing index object.
  /// @return 1 if at least one conflict is found, 0 otherwise.
  int git_index_has_conflicts(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_has_conflicts(
      index,
    );
  }

  late final _git_index_has_conflictsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_has_conflicts');
  late final _git_index_has_conflicts = _git_index_has_conflictsPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Create an iterator for the conflicts in the index.
  ///
  /// The index must not be modified while iterating; the results are undefined.
  ///
  /// @param iterator_out The newly created conflict iterator
  /// @param index The index to scan
  /// @return 0 or an error code
  int git_index_conflict_iterator_new(
    ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>> iterator_out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_conflict_iterator_new(
      iterator_out,
      index,
    );
  }

  late final _git_index_conflict_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>>,
              ffi.Pointer<git_index>)>>('git_index_conflict_iterator_new');
  late final _git_index_conflict_iterator_new =
      _git_index_conflict_iterator_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>>,
              ffi.Pointer<git_index>)>();

  /// Returns the current conflict (ancestor, ours and theirs entry) and
  /// advance the iterator internally to the next value.
  ///
  /// @param ancestor_out Pointer to store the ancestor side of the conflict
  /// @param our_out Pointer to store our side of the conflict
  /// @param their_out Pointer to store their side of the conflict
  /// @param iterator The conflict iterator.
  /// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
  /// (negative value)
  int git_index_conflict_next(
    ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
    ffi.Pointer<git_index_conflict_iterator> iterator,
  ) {
    return _git_index_conflict_next(
      ancestor_out,
      our_out,
      their_out,
      iterator,
    );
  }

  late final _git_index_conflict_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_index_entry>>,
                  ffi.Pointer<ffi.Pointer<git_index_entry>>,
                  ffi.Pointer<ffi.Pointer<git_index_entry>>,
                  ffi.Pointer<git_index_conflict_iterator>)>>(
      'git_index_conflict_next');
  late final _git_index_conflict_next = _git_index_conflict_nextPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<git_index_conflict_iterator>)>();

  /// Frees a `git_index_conflict_iterator`.
  ///
  /// @param iterator pointer to the iterator
  void git_index_conflict_iterator_free(
    ffi.Pointer<git_index_conflict_iterator> iterator,
  ) {
    return _git_index_conflict_iterator_free(
      iterator,
    );
  }

  late final _git_index_conflict_iterator_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_index_conflict_iterator>)>>(
      'git_index_conflict_iterator_free');
  late final _git_index_conflict_iterator_free =
      _git_index_conflict_iterator_freePtr.asFunction<
          void Function(ffi.Pointer<git_index_conflict_iterator>)>();

  /// Initializes a `git_merge_file_input` with default values. Equivalent to
  /// creating an instance with GIT_MERGE_FILE_INPUT_INIT.
  ///
  /// @param opts the `git_merge_file_input` instance to initialize.
  /// @param version the version of the struct; you should pass
  /// `GIT_MERGE_FILE_INPUT_VERSION` here.
  /// @return Zero on success; -1 on failure.
  int git_merge_file_input_init(
    ffi.Pointer<git_merge_file_input> opts,
    int version,
  ) {
    return _git_merge_file_input_init(
      opts,
      version,
    );
  }

  late final _git_merge_file_input_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_file_input>,
              ffi.UnsignedInt)>>('git_merge_file_input_init');
  late final _git_merge_file_input_init = _git_merge_file_input_initPtr
      .asFunction<int Function(ffi.Pointer<git_merge_file_input>, int)>();

  /// Initialize git_merge_file_options structure
  ///
  /// Initializes a `git_merge_file_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_FILE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_file_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_FILE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_merge_file_options_init(
    ffi.Pointer<git_merge_file_options> opts,
    int version,
  ) {
    return _git_merge_file_options_init(
      opts,
      version,
    );
  }

  late final _git_merge_file_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_file_options>,
              ffi.UnsignedInt)>>('git_merge_file_options_init');
  late final _git_merge_file_options_init = _git_merge_file_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_merge_file_options>, int)>();

  /// Initialize git_merge_options structure
  ///
  /// Initializes a `git_merge_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_merge_options_init(
    ffi.Pointer<git_merge_options> opts,
    int version,
  ) {
    return _git_merge_options_init(
      opts,
      version,
    );
  }

  late final _git_merge_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_options>,
              ffi.UnsignedInt)>>('git_merge_options_init');
  late final _git_merge_options_init = _git_merge_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_merge_options>, int)>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into the HEAD of the repository.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param preference_out One of the `git_merge_preference_t` flag.
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int git_merge_analysis(
    ffi.Pointer<ffi.UnsignedInt> analysis_out,
    ffi.Pointer<ffi.UnsignedInt> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _git_merge_analysis(
      analysis_out,
      preference_out,
      repo,
      their_heads,
      their_heads_len,
    );
  }

  late final _git_merge_analysisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Size)>>('git_merge_analysis');
  late final _git_merge_analysis = _git_merge_analysisPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
          int)>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into a reference.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param preference_out One of the `git_merge_preference_t` flag.
  /// @param repo the repository to merge
  /// @param our_ref the reference to perform the analysis from
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int git_merge_analysis_for_ref(
    ffi.Pointer<ffi.UnsignedInt> analysis_out,
    ffi.Pointer<ffi.UnsignedInt> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> our_ref,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _git_merge_analysis_for_ref(
      analysis_out,
      preference_out,
      repo,
      our_ref,
      their_heads,
      their_heads_len,
    );
  }

  late final _git_merge_analysis_for_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Size)>>('git_merge_analysis_for_ref');
  late final _git_merge_analysis_for_ref =
      _git_merge_analysis_for_refPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              int)>();

  /// Find a merge base between two commits
  ///
  /// @param out the OID of a merge base between 'one' and 'two'
  /// @param repo the repository where the commits exist
  /// @param one one of the commits
  /// @param two the other commit
  /// @return 0 on success, GIT_ENOTFOUND if not found or error code
  int git_merge_base(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> one,
    ffi.Pointer<git_oid> two,
  ) {
    return _git_merge_base(
      out,
      repo,
      one,
      two,
    );
  }

  late final _git_merge_basePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_merge_base');
  late final _git_merge_base = _git_merge_basePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Find merge bases between two commits
  ///
  /// @param out array in which to store the resulting ids
  /// @param repo the repository where the commits exist
  /// @param one one of the commits
  /// @param two the other commit
  /// @return 0 on success, GIT_ENOTFOUND if not found or error code
  int git_merge_bases(
    ffi.Pointer<git_oidarray> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> one,
    ffi.Pointer<git_oid> two,
  ) {
    return _git_merge_bases(
      out,
      repo,
      one,
      two,
    );
  }

  late final _git_merge_basesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oidarray>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_merge_bases');
  late final _git_merge_bases = _git_merge_basesPtr.asFunction<
      int Function(ffi.Pointer<git_oidarray>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Find a merge base given a list of commits
  ///
  /// @param out the OID of a merge base considering all the commits
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_base_many(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_base_many(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_base_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Size, ffi.Pointer<git_oid>)>>('git_merge_base_many');
  late final _git_merge_base_many = _git_merge_base_manyPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_oid>)>();

  /// Find all merge bases given a list of commits
  ///
  /// This behaves similar to [`git merge-base`](https://git-scm.com/docs/git-merge-base#_discussion).
  ///
  /// Given three commits `a`, `b`, and `c`, `merge_base_many`
  /// will compute a hypothetical commit `m`, which is a merge between `b`
  /// and `c`.
  ///
  /// For example, with the following topology:
  /// ```text
  /// o---o---o---o---C
  /// /
  /// /   o---o---o---B
  /// /   /
  /// ---2---1---o---o---o---A
  /// ```
  ///
  /// the result of `merge_base_many` given `a`, `b`, and `c` is 1. This is
  /// because the equivalent topology with the imaginary merge commit `m`
  /// between `b` and `c` is:
  /// ```text
  /// o---o---o---o---o
  /// /                 \
  /// /   o---o---o---o---M
  /// /   /
  /// ---2---1---o---o---o---A
  /// ```
  ///
  /// and the result of `merge_base_many` given `a` and `m` is 1.
  ///
  /// If you're looking to recieve the common ancestor between all the
  /// given commits, use `merge_base_octopus`.
  ///
  /// @param out array in which to store the resulting ids
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_bases_many(
    ffi.Pointer<git_oidarray> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_bases_many(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_bases_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oidarray>,
              ffi.Pointer<git_repository>,
              ffi.Size,
              ffi.Pointer<git_oid>)>>('git_merge_bases_many');
  late final _git_merge_bases_many = _git_merge_bases_manyPtr.asFunction<
      int Function(ffi.Pointer<git_oidarray>, ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_oid>)>();

  /// Find a merge base in preparation for an octopus merge
  ///
  /// @param out the OID of a merge base considering all the commits
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_base_octopus(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_base_octopus(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_base_octopusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Size, ffi.Pointer<git_oid>)>>('git_merge_base_octopus');
  late final _git_merge_base_octopus = _git_merge_base_octopusPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_oid>)>();

  /// Merge two files as they exist in the in-memory data structures, using
  /// the given common ancestor as the baseline, producing a
  /// `git_merge_file_result` that reflects the merge result.  The
  /// `git_merge_file_result` must be freed with `git_merge_file_result_free`.
  ///
  /// Note that this function does not reference a repository and any
  /// configuration must be passed as `git_merge_file_options`.
  ///
  /// @param out The git_merge_file_result to be filled in
  /// @param ancestor The contents of the ancestor file
  /// @param ours The contents of the file in "our" side
  /// @param theirs The contents of the file in "their" side
  /// @param opts The merge file options or `NULL` for defaults
  /// @return 0 on success or error code
  int git_merge_file(
    ffi.Pointer<git_merge_file_result> out,
    ffi.Pointer<git_merge_file_input> ancestor,
    ffi.Pointer<git_merge_file_input> ours,
    ffi.Pointer<git_merge_file_input> theirs,
    ffi.Pointer<git_merge_file_options> opts,
  ) {
    return _git_merge_file(
      out,
      ancestor,
      ours,
      theirs,
      opts,
    );
  }

  late final _git_merge_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_merge_file_result>,
              ffi.Pointer<git_merge_file_input>,
              ffi.Pointer<git_merge_file_input>,
              ffi.Pointer<git_merge_file_input>,
              ffi.Pointer<git_merge_file_options>)>>('git_merge_file');
  late final _git_merge_file = _git_merge_filePtr.asFunction<
      int Function(
          ffi.Pointer<git_merge_file_result>,
          ffi.Pointer<git_merge_file_input>,
          ffi.Pointer<git_merge_file_input>,
          ffi.Pointer<git_merge_file_input>,
          ffi.Pointer<git_merge_file_options>)>();

  /// Merge two files as they exist in the index, using the given common
  /// ancestor as the baseline, producing a `git_merge_file_result` that
  /// reflects the merge result.  The `git_merge_file_result` must be freed with
  /// `git_merge_file_result_free`.
  ///
  /// @param out The git_merge_file_result to be filled in
  /// @param repo The repository
  /// @param ancestor The index entry for the ancestor file (stage level 1)
  /// @param ours The index entry for our file (stage level 2)
  /// @param theirs The index entry for their file (stage level 3)
  /// @param opts The merge file options or NULL
  /// @return 0 on success or error code
  int git_merge_file_from_index(
    ffi.Pointer<git_merge_file_result> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index_entry> ancestor,
    ffi.Pointer<git_index_entry> ours,
    ffi.Pointer<git_index_entry> theirs,
    ffi.Pointer<git_merge_file_options> opts,
  ) {
    return _git_merge_file_from_index(
      out,
      repo,
      ancestor,
      ours,
      theirs,
      opts,
    );
  }

  late final _git_merge_file_from_indexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_merge_file_result>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<git_index_entry>,
                  ffi.Pointer<git_index_entry>,
                  ffi.Pointer<git_index_entry>,
                  ffi.Pointer<git_merge_file_options>)>>(
      'git_merge_file_from_index');
  late final _git_merge_file_from_index =
      _git_merge_file_from_indexPtr.asFunction<
          int Function(
              ffi.Pointer<git_merge_file_result>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_merge_file_options>)>();

  /// Frees a `git_merge_file_result`.
  ///
  /// @param result The result to free or `NULL`
  void git_merge_file_result_free(
    ffi.Pointer<git_merge_file_result> result,
  ) {
    return _git_merge_file_result_free(
      result,
    );
  }

  late final _git_merge_file_result_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_merge_file_result>)>>(
      'git_merge_file_result_free');
  late final _git_merge_file_result_free = _git_merge_file_result_freePtr
      .asFunction<void Function(ffi.Pointer<git_merge_file_result>)>();

  /// Merge two trees, producing a `git_index` that reflects the result of
  /// the merge.  The index may be written as-is to the working directory
  /// or checked out.  If the index is to be converted to a tree, the caller
  /// should resolve any conflicts that arose as part of the merge.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo repository that contains the given trees
  /// @param ancestor_tree the common ancestor between the trees (or null if none)
  /// @param our_tree the tree that reflects the destination tree
  /// @param their_tree the tree to merge in to `our_tree`
  /// @param opts the merge tree options (or null for defaults)
  /// @return 0 on success or error code
  int git_merge_trees(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> ancestor_tree,
    ffi.Pointer<git_tree> our_tree,
    ffi.Pointer<git_tree> their_tree,
    ffi.Pointer<git_merge_options> opts,
  ) {
    return _git_merge_trees(
      out,
      repo,
      ancestor_tree,
      our_tree,
      their_tree,
      opts,
    );
  }

  late final _git_merge_treesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_merge_options>)>>('git_merge_trees');
  late final _git_merge_trees = _git_merge_treesPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_merge_options>)>();

  /// Merge two commits, producing a `git_index` that reflects the result of
  /// the merge.  The index may be written as-is to the working directory
  /// or checked out.  If the index is to be converted to a tree, the caller
  /// should resolve any conflicts that arose as part of the merge.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo repository that contains the given trees
  /// @param our_commit the commit that reflects the destination tree
  /// @param their_commit the commit to merge in to `our_commit`
  /// @param opts the merge tree options (or null for defaults)
  /// @return 0 on success or error code
  int git_merge_commits(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> our_commit,
    ffi.Pointer<git_commit> their_commit,
    ffi.Pointer<git_merge_options> opts,
  ) {
    return _git_merge_commits(
      out,
      repo,
      our_commit,
      their_commit,
      opts,
    );
  }

  late final _git_merge_commitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_merge_options>)>>('git_merge_commits');
  late final _git_merge_commits = _git_merge_commitsPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_merge_options>)>();

  /// Merges the given commit(s) into HEAD, writing the results into the working
  /// directory.  Any changes are staged for commit and any conflicts are written
  /// to the index.  Callers should inspect the repository's index after this
  /// completes, resolve any conflicts and prepare a commit.
  ///
  /// For compatibility with git, the repository is put into a merging
  /// state. Once the commit is done (or if the user wishes to abort),
  /// you should clear this state by calling
  /// `git_repository_state_cleanup()`.
  ///
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @param merge_opts merge options
  /// @param checkout_opts checkout options
  /// @return 0 on success or error code
  int git_merge(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
    ffi.Pointer<git_merge_options> merge_opts,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_merge(
      repo,
      their_heads,
      their_heads_len,
      merge_opts,
      checkout_opts,
    );
  }

  late final _git_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Size,
              ffi.Pointer<git_merge_options>,
              ffi.Pointer<git_checkout_options>)>>('git_merge');
  late final _git_merge = _git_mergePtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
          int,
          ffi.Pointer<git_merge_options>,
          ffi.Pointer<git_checkout_options>)>();

  /// Initialize git_cherrypick_options structure
  ///
  /// Initializes a `git_cherrypick_options` with default values. Equivalent to creating
  /// an instance with GIT_CHERRYPICK_OPTIONS_INIT.
  ///
  /// @param opts The `git_cherrypick_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHERRYPICK_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_cherrypick_options_init(
    ffi.Pointer<git_cherrypick_options> opts,
    int version,
  ) {
    return _git_cherrypick_options_init(
      opts,
      version,
    );
  }

  late final _git_cherrypick_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_cherrypick_options>,
              ffi.UnsignedInt)>>('git_cherrypick_options_init');
  late final _git_cherrypick_options_init = _git_cherrypick_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_cherrypick_options>, int)>();

  /// Cherry-picks the given commit against the given "our" commit, producing an
  /// index that reflects the result of the cherry-pick.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo the repository that contains the given commits
  /// @param cherrypick_commit the commit to cherry-pick
  /// @param our_commit the commit to cherry-pick against (eg, HEAD)
  /// @param mainline the parent of the `cherrypick_commit`, if it is a merge
  /// @param merge_options the merge options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_cherrypick_commit(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> cherrypick_commit,
    ffi.Pointer<git_commit> our_commit,
    int mainline,
    ffi.Pointer<git_merge_options> merge_options,
  ) {
    return _git_cherrypick_commit(
      out,
      repo,
      cherrypick_commit,
      our_commit,
      mainline,
      merge_options,
    );
  }

  late final _git_cherrypick_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_commit>,
              ffi.UnsignedInt,
              ffi.Pointer<git_merge_options>)>>('git_cherrypick_commit');
  late final _git_cherrypick_commit = _git_cherrypick_commitPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_commit>,
          int,
          ffi.Pointer<git_merge_options>)>();

  /// Cherry-pick the given commit, producing changes in the index and working directory.
  ///
  /// @param repo the repository to cherry-pick
  /// @param commit the commit to cherry-pick
  /// @param cherrypick_options the cherry-pick options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_cherrypick(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_cherrypick_options> cherrypick_options,
  ) {
    return _git_cherrypick(
      repo,
      commit,
      cherrypick_options,
    );
  }

  late final _git_cherrypickPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
              ffi.Pointer<git_cherrypick_options>)>>('git_cherrypick');
  late final _git_cherrypick = _git_cherrypickPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
          ffi.Pointer<git_cherrypick_options>)>();

  /// Parse a given refspec string
  ///
  /// @param refspec a pointer to hold the refspec handle
  /// @param input the refspec string
  /// @param is_fetch is this a refspec for a fetch
  /// @return 0 if the refspec string could be parsed, -1 otherwise
  int git_refspec_parse(
    ffi.Pointer<ffi.Pointer<git_refspec>> refspec,
    ffi.Pointer<ffi.Char> input,
    int is_fetch,
  ) {
    return _git_refspec_parse(
      refspec,
      input,
      is_fetch,
    );
  }

  late final _git_refspec_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refspec>>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_refspec_parse');
  late final _git_refspec_parse = _git_refspec_parsePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refspec>>, ffi.Pointer<ffi.Char>, int)>();

  /// Free a refspec object which has been created by git_refspec_parse
  ///
  /// @param refspec the refspec object
  void git_refspec_free(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_free(
      refspec,
    );
  }

  late final _git_refspec_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_refspec>)>>(
          'git_refspec_free');
  late final _git_refspec_free = _git_refspec_freePtr
      .asFunction<void Function(ffi.Pointer<git_refspec>)>();

  /// Get the source specifier
  ///
  /// @param refspec the refspec
  /// @return the refspec's source specifier
  ffi.Pointer<ffi.Char> git_refspec_src(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_src(
      refspec,
    );
  }

  late final _git_refspec_srcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_refspec>)>>('git_refspec_src');
  late final _git_refspec_src = _git_refspec_srcPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec>)>();

  /// Get the destination specifier
  ///
  /// @param refspec the refspec
  /// @return the refspec's destination specifier
  ffi.Pointer<ffi.Char> git_refspec_dst(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_dst(
      refspec,
    );
  }

  late final _git_refspec_dstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_refspec>)>>('git_refspec_dst');
  late final _git_refspec_dst = _git_refspec_dstPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec>)>();

  /// Get the refspec's string
  ///
  /// @param refspec the refspec
  /// @return the refspec's original string
  ffi.Pointer<ffi.Char> git_refspec_string(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_string(
      refspec,
    );
  }

  late final _git_refspec_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_refspec>)>>('git_refspec_string');
  late final _git_refspec_string = _git_refspec_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec>)>();

  /// Get the force update setting
  ///
  /// @param refspec the refspec
  /// @return 1 if force update has been set, 0 otherwise
  int git_refspec_force(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_force(
      refspec,
    );
  }

  late final _git_refspec_forcePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_refspec>)>>(
          'git_refspec_force');
  late final _git_refspec_force = _git_refspec_forcePtr
      .asFunction<int Function(ffi.Pointer<git_refspec>)>();

  /// Get the refspec's direction.
  ///
  /// @param spec refspec
  /// @return GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
  git_direction git_refspec_direction(
    ffi.Pointer<git_refspec> spec,
  ) {
    return git_direction.fromValue(_git_refspec_direction(
      spec,
    ));
  }

  late final _git_refspec_directionPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<git_refspec>)>>(
      'git_refspec_direction');
  late final _git_refspec_direction = _git_refspec_directionPtr
      .asFunction<int Function(ffi.Pointer<git_refspec>)>();

  /// Check if a refspec's source descriptor matches a negative reference
  ///
  /// @param refspec the refspec
  /// @param refname the name of the reference to check
  /// @return 1 if the refspec matches, 0 otherwise
  int git_refspec_src_matches_negative(
    ffi.Pointer<git_refspec> refspec,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_refspec_src_matches_negative(
      refspec,
      refname,
    );
  }

  late final _git_refspec_src_matches_negativePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_src_matches_negative');
  late final _git_refspec_src_matches_negative =
      _git_refspec_src_matches_negativePtr.asFunction<
          int Function(ffi.Pointer<git_refspec>, ffi.Pointer<ffi.Char>)>();

  /// Check if a refspec's source descriptor matches a reference
  ///
  /// @param refspec the refspec
  /// @param refname the name of the reference to check
  /// @return 1 if the refspec matches, 0 otherwise
  int git_refspec_src_matches(
    ffi.Pointer<git_refspec> refspec,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_refspec_src_matches(
      refspec,
      refname,
    );
  }

  late final _git_refspec_src_matchesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_src_matches');
  late final _git_refspec_src_matches = _git_refspec_src_matchesPtr.asFunction<
      int Function(ffi.Pointer<git_refspec>, ffi.Pointer<ffi.Char>)>();

  /// Check if a refspec's destination descriptor matches a reference
  ///
  /// @param refspec the refspec
  /// @param refname the name of the reference to check
  /// @return 1 if the refspec matches, 0 otherwise
  int git_refspec_dst_matches(
    ffi.Pointer<git_refspec> refspec,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_refspec_dst_matches(
      refspec,
      refname,
    );
  }

  late final _git_refspec_dst_matchesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_dst_matches');
  late final _git_refspec_dst_matches = _git_refspec_dst_matchesPtr.asFunction<
      int Function(ffi.Pointer<git_refspec>, ffi.Pointer<ffi.Char>)>();

  /// Transform a reference to its target following the refspec's rules
  ///
  /// @param out where to store the target name
  /// @param spec the refspec
  /// @param name the name of the reference to transform
  /// @return 0, GIT_EBUFS or another error
  int git_refspec_transform(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_refspec> spec,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_refspec_transform(
      out,
      spec,
      name,
    );
  }

  late final _git_refspec_transformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_transform');
  late final _git_refspec_transform = _git_refspec_transformPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
          ffi.Pointer<ffi.Char>)>();

  /// Transform a target reference to its source reference following the refspec's rules
  ///
  /// @param out where to store the source reference name
  /// @param spec the refspec
  /// @param name the name of the reference to transform
  /// @return 0, GIT_EBUFS or another error
  int git_refspec_rtransform(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_refspec> spec,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_refspec_rtransform(
      out,
      spec,
      name,
    );
  }

  late final _git_refspec_rtransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_rtransform');
  late final _git_refspec_rtransform = _git_refspec_rtransformPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
          ffi.Pointer<ffi.Char>)>();

  /// Free a credential.
  ///
  /// This is only necessary if you own the object; that is, if you are a
  /// transport.
  ///
  /// @param cred the object to free
  void git_credential_free(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_free(
      cred,
    );
  }

  late final _git_credential_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_credential>)>>(
      'git_credential_free');
  late final _git_credential_free = _git_credential_freePtr
      .asFunction<void Function(ffi.Pointer<git_credential>)>();

  /// Check whether a credential object contains username information.
  ///
  /// @param cred object to check
  /// @return 1 if the credential object has non-NULL username, 0 otherwise
  int git_credential_has_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_has_username(
      cred,
    );
  }

  late final _git_credential_has_usernamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_credential>)>>(
      'git_credential_has_username');
  late final _git_credential_has_username = _git_credential_has_usernamePtr
      .asFunction<int Function(ffi.Pointer<git_credential>)>();

  /// Return the username associated with a credential object.
  ///
  /// @param cred object to check
  /// @return the credential username, or NULL if not applicable
  ffi.Pointer<ffi.Char> git_credential_get_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_get_username(
      cred,
    );
  }

  late final _git_credential_get_usernamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_credential>)>>('git_credential_get_username');
  late final _git_credential_get_username =
      _git_credential_get_usernamePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_credential>)>();

  /// Create a new plain-text username and password credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username The username of the credential.
  /// @param password The password of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _git_credential_userpass_plaintext_new(
      out,
      username,
      password,
    );
  }

  late final _git_credential_userpass_plaintext_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_credential_userpass_plaintext_new');
  late final _git_credential_userpass_plaintext_new =
      _git_credential_userpass_plaintext_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Create a "default" credential usable for Negotiate mechanisms like NTLM
  /// or Kerberos authentication.
  ///
  /// @param out The newly created credential object.
  /// @return 0 for success or an error code for failure
  int git_credential_default_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
  ) {
    return _git_credential_default_new(
      out,
    );
  }

  late final _git_credential_default_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>)>>(
      'git_credential_default_new');
  late final _git_credential_default_new = _git_credential_default_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_credential>>)>();

  /// Create a credential to specify a username.
  ///
  /// This is used with ssh authentication to query for the username if
  /// none is specified in the url.
  ///
  /// @param out The newly created credential object.
  /// @param username The username to authenticate with
  /// @return 0 for success or an error code for failure
  int git_credential_username_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
  ) {
    return _git_credential_username_new(
      out,
      username,
    );
  }

  late final _git_credential_username_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>>('git_credential_username_new');
  late final _git_credential_username_new =
      _git_credential_username_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new passphrase-protected ssh key credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @param publickey The path to the public key of the credential.
  /// @param privatekey The path to the private key of the credential.
  /// @param passphrase The passphrase of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    ffi.Pointer<ffi.Char> privatekey,
    ffi.Pointer<ffi.Char> passphrase,
  ) {
    return _git_credential_ssh_key_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_credential_ssh_key_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_credential_ssh_key_new');
  late final _git_credential_ssh_key_new =
      _git_credential_ssh_key_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new ssh key credential object reading the keys from memory.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate.
  /// @param publickey The public key of the credential.
  /// @param privatekey The private key of the credential.
  /// @param passphrase The passphrase of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_memory_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    ffi.Pointer<ffi.Char> privatekey,
    ffi.Pointer<ffi.Char> passphrase,
  ) {
    return _git_credential_ssh_key_memory_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_credential_ssh_key_memory_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_credential_ssh_key_memory_new');
  late final _git_credential_ssh_key_memory_new =
      _git_credential_ssh_key_memory_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new ssh keyboard-interactive based credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username Username to use to authenticate.
  /// @param prompt_callback The callback method used for prompts.
  /// @param payload Additional data to pass to the callback.
  /// @return 0 for success or an error code for failure.
  int git_credential_ssh_interactive_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    git_credential_ssh_interactive_cb prompt_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_ssh_interactive_new(
      out,
      username,
      prompt_callback,
      payload,
    );
  }

  late final _git_credential_ssh_interactive_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              git_credential_ssh_interactive_cb,
              ffi.Pointer<ffi.Void>)>>('git_credential_ssh_interactive_new');
  late final _git_credential_ssh_interactive_new =
      _git_credential_ssh_interactive_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              git_credential_ssh_interactive_cb,
              ffi.Pointer<ffi.Void>)>();

  /// Create a new ssh key credential object used for querying an ssh-agent.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_from_agent(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
  ) {
    return _git_credential_ssh_key_from_agent(
      out,
      username,
    );
  }

  late final _git_credential_ssh_key_from_agentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>>('git_credential_ssh_key_from_agent');
  late final _git_credential_ssh_key_from_agent =
      _git_credential_ssh_key_from_agentPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>();

  /// Create an ssh key credential with a custom signing function.
  ///
  /// This lets you use your own function to sign the challenge.
  ///
  /// This function and its credential type is provided for completeness
  /// and wraps `libssh2_userauth_publickey()`, which is undocumented.
  ///
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @param publickey The bytes of the public key.
  /// @param publickey_len The length of the public key in bytes.
  /// @param sign_callback The callback method to sign the data during the challenge.
  /// @param payload Additional data to pass to the callback.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_custom_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    int publickey_len,
    git_credential_sign_cb sign_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_ssh_custom_new(
      out,
      username,
      publickey,
      publickey_len,
      sign_callback,
      payload,
    );
  }

  late final _git_credential_ssh_custom_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              git_credential_sign_cb,
              ffi.Pointer<ffi.Void>)>>('git_credential_ssh_custom_new');
  late final _git_credential_ssh_custom_new =
      _git_credential_ssh_custom_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              git_credential_sign_cb,
              ffi.Pointer<ffi.Void>)>();

  /// Initialize a new packbuilder
  ///
  /// @param out The new packbuilder object
  /// @param repo The repository
  ///
  /// @return 0 or an error code
  int git_packbuilder_new(
    ffi.Pointer<ffi.Pointer<git_packbuilder>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_packbuilder_new(
      out,
      repo,
    );
  }

  late final _git_packbuilder_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_packbuilder>>,
              ffi.Pointer<git_repository>)>>('git_packbuilder_new');
  late final _git_packbuilder_new = _git_packbuilder_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_packbuilder>>,
          ffi.Pointer<git_repository>)>();

  /// Set number of threads to spawn
  ///
  /// By default, libgit2 won't spawn any threads at all;
  /// when set to 0, libgit2 will autodetect the number of
  /// CPUs.
  ///
  /// @param pb The packbuilder
  /// @param n Number of threads to spawn
  /// @return number of actual threads to be used
  int git_packbuilder_set_threads(
    ffi.Pointer<git_packbuilder> pb,
    int n,
  ) {
    return _git_packbuilder_set_threads(
      pb,
      n,
    );
  }

  late final _git_packbuilder_set_threadsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<git_packbuilder>,
              ffi.UnsignedInt)>>('git_packbuilder_set_threads');
  late final _git_packbuilder_set_threads = _git_packbuilder_set_threadsPtr
      .asFunction<int Function(ffi.Pointer<git_packbuilder>, int)>();

  /// Insert a single object
  ///
  /// For an optimal pack it's mandatory to insert objects in recency order,
  /// commits followed by trees and blobs.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the commit
  /// @param name The name; might be NULL
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_packbuilder_insert(
      pb,
      id,
      name,
    );
  }

  late final _git_packbuilder_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_packbuilder_insert');
  late final _git_packbuilder_insert = _git_packbuilder_insertPtr.asFunction<
      int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
          ffi.Pointer<ffi.Char>)>();

  /// Insert a root tree object
  ///
  /// This will add the tree as well as all referenced trees and blobs.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the root tree
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_tree(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_packbuilder_insert_tree(
      pb,
      id,
    );
  }

  late final _git_packbuilder_insert_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>,
              ffi.Pointer<git_oid>)>>('git_packbuilder_insert_tree');
  late final _git_packbuilder_insert_tree =
      _git_packbuilder_insert_treePtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>)>();

  /// Insert a commit object
  ///
  /// This will add a commit as well as the completed referenced tree.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the commit
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_commit(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_packbuilder_insert_commit(
      pb,
      id,
    );
  }

  late final _git_packbuilder_insert_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>,
              ffi.Pointer<git_oid>)>>('git_packbuilder_insert_commit');
  late final _git_packbuilder_insert_commit =
      _git_packbuilder_insert_commitPtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>)>();

  /// Insert objects as given by the walk
  ///
  /// Those commits and all objects they reference will be inserted into
  /// the packbuilder.
  ///
  /// @param pb the packbuilder
  /// @param walk the revwalk to use to fill the packbuilder
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_walk(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_packbuilder_insert_walk(
      pb,
      walk,
    );
  }

  late final _git_packbuilder_insert_walkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>,
              ffi.Pointer<git_revwalk>)>>('git_packbuilder_insert_walk');
  late final _git_packbuilder_insert_walk =
      _git_packbuilder_insert_walkPtr.asFunction<
          int Function(
              ffi.Pointer<git_packbuilder>, ffi.Pointer<git_revwalk>)>();

  /// Recursively insert an object and its referenced objects
  ///
  /// Insert the object as well as any object it references.
  ///
  /// @param pb the packbuilder
  /// @param id the id of the root object to insert
  /// @param name optional name for the object
  /// @return 0 or an error code
  int git_packbuilder_insert_recur(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_packbuilder_insert_recur(
      pb,
      id,
      name,
    );
  }

  late final _git_packbuilder_insert_recurPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_packbuilder_insert_recur');
  late final _git_packbuilder_insert_recur =
      _git_packbuilder_insert_recurPtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Write the contents of the packfile to an in-memory buffer
  ///
  /// The contents of the buffer will become a valid packfile, even though there
  /// will be no attached index
  ///
  /// @param buf Buffer where to write the packfile
  /// @param pb The packbuilder
  /// @return 0 or an error code
  int git_packbuilder_write_buf(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_write_buf(
      buf,
      pb,
    );
  }

  late final _git_packbuilder_write_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_packbuilder>)>>('git_packbuilder_write_buf');
  late final _git_packbuilder_write_buf =
      _git_packbuilder_write_bufPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_packbuilder>)>();

  /// Write the new pack and corresponding index file to path.
  ///
  /// @param pb The packbuilder
  /// @param path Path to the directory where the packfile and index should be stored, or NULL for default location
  /// @param mode permissions to use creating a packfile or 0 for defaults
  /// @param progress_cb function to call with progress information from the indexer (optional)
  /// @param progress_cb_payload payload for the progress callback (optional)
  ///
  /// @return 0 or an error code
  int git_packbuilder_write(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<ffi.Char> path,
    int mode,
    git_indexer_progress_cb progress_cb,
    ffi.Pointer<ffi.Void> progress_cb_payload,
  ) {
    return _git_packbuilder_write(
      pb,
      path,
      mode,
      progress_cb,
      progress_cb_payload,
    );
  }

  late final _git_packbuilder_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_packbuilder>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              git_indexer_progress_cb,
              ffi.Pointer<ffi.Void>)>>('git_packbuilder_write');
  late final _git_packbuilder_write = _git_packbuilder_writePtr.asFunction<
      int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<ffi.Char>, int,
          git_indexer_progress_cb, ffi.Pointer<ffi.Void>)>();

  /// Get the packfile's hash
  ///
  /// A packfile's name is derived from the sorted hashing of all object
  /// names. This is only correct after the packfile has been written.
  ///
  /// @deprecated use git_packbuilder_name
  /// @param pb The packbuilder object
  /// @return 0 or an error code
  ffi.Pointer<git_oid> git_packbuilder_hash(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_hash(
      pb,
    );
  }

  late final _git_packbuilder_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_packbuilder>)>>('git_packbuilder_hash');
  late final _git_packbuilder_hash = _git_packbuilder_hashPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_packbuilder>)>();

  /// Get the unique name for the resulting packfile.
  ///
  /// The packfile's name is derived from the packfile's content.
  /// This is only correct after the packfile has been written.
  ///
  /// @param pb the packbuilder instance
  /// @return a NUL terminated string for the packfile name
  ffi.Pointer<ffi.Char> git_packbuilder_name(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_name(
      pb,
    );
  }

  late final _git_packbuilder_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_packbuilder>)>>('git_packbuilder_name');
  late final _git_packbuilder_name = _git_packbuilder_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_packbuilder>)>();

  /// Create the new pack and pass each object to the callback
  ///
  /// @param pb the packbuilder
  /// @param cb the callback to call with each packed object's buffer
  /// @param payload the callback's data
  /// @return 0 or an error code
  int git_packbuilder_foreach(
    ffi.Pointer<git_packbuilder> pb,
    git_packbuilder_foreach_cb cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_packbuilder_foreach(
      pb,
      cb,
      payload,
    );
  }

  late final _git_packbuilder_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_packbuilder>,
              git_packbuilder_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_packbuilder_foreach');
  late final _git_packbuilder_foreach = _git_packbuilder_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_packbuilder>, git_packbuilder_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Get the total number of objects the packbuilder will write out
  ///
  /// @param pb the packbuilder
  /// @return the number of objects in the packfile
  int git_packbuilder_object_count(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_object_count(
      pb,
    );
  }

  late final _git_packbuilder_object_countPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_packbuilder>)>>(
      'git_packbuilder_object_count');
  late final _git_packbuilder_object_count = _git_packbuilder_object_countPtr
      .asFunction<int Function(ffi.Pointer<git_packbuilder>)>();

  /// Get the number of objects the packbuilder has already written out
  ///
  /// @param pb the packbuilder
  /// @return the number of objects which have already been written
  int git_packbuilder_written(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_written(
      pb,
    );
  }

  late final _git_packbuilder_writtenPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_packbuilder>)>>(
      'git_packbuilder_written');
  late final _git_packbuilder_written = _git_packbuilder_writtenPtr
      .asFunction<int Function(ffi.Pointer<git_packbuilder>)>();

  /// Set the callbacks for a packbuilder
  ///
  /// @param pb The packbuilder object
  /// @param progress_cb Function to call with progress information during
  /// pack building. Be aware that this is called inline with pack building
  /// operations, so performance may be affected.
  /// When progress_cb returns an error, the pack building process will be
  /// aborted and the error will be returned from the invoked function.
  /// `pb` must then be freed.
  /// @param progress_cb_payload Payload for progress callback.
  /// @return 0 or an error code
  int git_packbuilder_set_callbacks(
    ffi.Pointer<git_packbuilder> pb,
    git_packbuilder_progress progress_cb,
    ffi.Pointer<ffi.Void> progress_cb_payload,
  ) {
    return _git_packbuilder_set_callbacks(
      pb,
      progress_cb,
      progress_cb_payload,
    );
  }

  late final _git_packbuilder_set_callbacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_packbuilder>,
              git_packbuilder_progress,
              ffi.Pointer<ffi.Void>)>>('git_packbuilder_set_callbacks');
  late final _git_packbuilder_set_callbacks =
      _git_packbuilder_set_callbacksPtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, git_packbuilder_progress,
              ffi.Pointer<ffi.Void>)>();

  /// Free the packbuilder and all associated data
  ///
  /// @param pb The packbuilder
  void git_packbuilder_free(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_free(
      pb,
    );
  }

  late final _git_packbuilder_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_packbuilder>)>>(
      'git_packbuilder_free');
  late final _git_packbuilder_free = _git_packbuilder_freePtr
      .asFunction<void Function(ffi.Pointer<git_packbuilder>)>();

  /// Initialize git_proxy_options structure
  ///
  /// Initializes a `git_proxy_options` with default values. Equivalent to
  /// creating an instance with `GIT_PROXY_OPTIONS_INIT`.
  ///
  /// @param opts The `git_proxy_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PROXY_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_proxy_options_init(
    ffi.Pointer<git_proxy_options> opts,
    int version,
  ) {
    return _git_proxy_options_init(
      opts,
      version,
    );
  }

  late final _git_proxy_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_proxy_options>,
              ffi.UnsignedInt)>>('git_proxy_options_init');
  late final _git_proxy_options_init = _git_proxy_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_proxy_options>, int)>();

  /// Add a remote with the default fetch refspec to the repository's configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_create(
      out,
      repo,
      name,
      url,
    );
  }

  late final _git_remote_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create');
  late final _git_remote_create = _git_remote_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_remote>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Initialize git_remote_create_options structure
  ///
  /// Initializes a `git_remote_create_options` with default values. Equivalent to
  /// creating an instance with `GIT_REMOTE_CREATE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_remote_create_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REMOTE_CREATE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_remote_create_options_init(
    ffi.Pointer<git_remote_create_options> opts,
    int version,
  ) {
    return _git_remote_create_options_init(
      opts,
      version,
    );
  }

  late final _git_remote_create_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_create_options>,
              ffi.UnsignedInt)>>('git_remote_create_options_init');
  late final _git_remote_create_options_init =
      _git_remote_create_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_remote_create_options>, int)>();

  /// Create a remote, with options.
  ///
  /// This function allows more fine-grained control over the remote creation.
  ///
  /// Passing NULL as the opts argument will result in a detached remote.
  ///
  /// @param out the resulting remote
  /// @param url the remote's url
  /// @param opts the remote creation options
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create_with_opts(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<git_remote_create_options> opts,
  ) {
    return _git_remote_create_with_opts(
      out,
      url,
      opts,
    );
  }

  late final _git_remote_create_with_optsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_remote>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_remote_create_options>)>>(
      'git_remote_create_with_opts');
  late final _git_remote_create_with_opts =
      _git_remote_create_with_optsPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_remote_create_options>)>();

  /// Add a remote with the provided fetch refspec (or default if NULL) to the repository's
  /// configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @param fetch the remote fetch value
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create_with_fetchspec(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> fetch,
  ) {
    return _git_remote_create_with_fetchspec(
      out,
      repo,
      name,
      url,
      fetch,
    );
  }

  late final _git_remote_create_with_fetchspecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create_with_fetchspec');
  late final _git_remote_create_with_fetchspec =
      _git_remote_create_with_fetchspecPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create an anonymous remote
  ///
  /// Create a remote with the given url in-memory. You can use this when
  /// you have a URL instead of a remote's name.
  ///
  /// @param out pointer to the new remote objects
  /// @param repo the associated repository
  /// @param url the remote repository's URL
  /// @return 0 or an error code
  int git_remote_create_anonymous(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_create_anonymous(
      out,
      repo,
      url,
    );
  }

  late final _git_remote_create_anonymousPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create_anonymous');
  late final _git_remote_create_anonymous =
      _git_remote_create_anonymousPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Create a remote without a connected local repo
  ///
  /// Create a remote with the given url in-memory. You can use this when
  /// you have a URL instead of a remote's name.
  ///
  /// Contrasted with git_remote_create_anonymous, a detached remote
  /// will not consider any repo configuration values (such as insteadof url
  /// substitutions).
  ///
  /// @param out pointer to the new remote objects
  /// @param url the remote repository's URL
  /// @return 0 or an error code
  int git_remote_create_detached(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_create_detached(
      out,
      url,
    );
  }

  late final _git_remote_create_detachedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create_detached');
  late final _git_remote_create_detached =
      _git_remote_create_detachedPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>, ffi.Pointer<ffi.Char>)>();

  /// Get the information for a particular remote
  ///
  /// The name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out pointer to the new remote object
  /// @param repo the associated repository
  /// @param name the remote's name
  /// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
  int git_remote_lookup(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_remote_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_remote_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_remote_lookup');
  late final _git_remote_lookup = _git_remote_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Create a copy of an existing remote.  All internal strings are also
  /// duplicated. Callbacks are not duplicated.
  ///
  /// Call `git_remote_free` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_remote_dup(
    ffi.Pointer<ffi.Pointer<git_remote>> dest,
    ffi.Pointer<git_remote> source,
  ) {
    return _git_remote_dup(
      dest,
      source,
    );
  }

  late final _git_remote_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_remote>)>>('git_remote_dup');
  late final _git_remote_dup = _git_remote_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_remote>>, ffi.Pointer<git_remote>)>();

  /// Get the remote's repository
  ///
  /// @param remote the remote
  /// @return a pointer to the repository
  ffi.Pointer<git_repository> git_remote_owner(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_owner(
      remote,
    );
  }

  late final _git_remote_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_remote>)>>('git_remote_owner');
  late final _git_remote_owner = _git_remote_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_remote>)>();

  /// Get the remote's name
  ///
  /// @param remote the remote
  /// @return a pointer to the name or NULL for in-memory remotes
  ffi.Pointer<ffi.Char> git_remote_name(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_name(
      remote,
    );
  }

  late final _git_remote_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_remote>)>>('git_remote_name');
  late final _git_remote_name = _git_remote_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)>();

  /// Get the remote's url
  ///
  /// If url.*.insteadOf has been configured for this URL, it will return
  /// the modified URL. This function does not consider if a push url has
  /// been configured for this remote (use `git_remote_pushurl` if needed).
  ///
  /// @param remote the remote
  /// @return a pointer to the url
  ffi.Pointer<ffi.Char> git_remote_url(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_url(
      remote,
    );
  }

  late final _git_remote_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_remote>)>>('git_remote_url');
  late final _git_remote_url = _git_remote_urlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)>();

  /// Get the remote's url for pushing.
  ///
  /// If url.*.pushInsteadOf has been configured for this URL, it
  /// will return the modified URL.  If `git_remote_set_instance_pushurl`
  /// has been called for this remote, then that URL will be returned.
  ///
  /// @param remote the remote
  /// @return a pointer to the url or NULL if no special url for pushing is set
  ffi.Pointer<ffi.Char> git_remote_pushurl(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_pushurl(
      remote,
    );
  }

  late final _git_remote_pushurlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_remote>)>>('git_remote_pushurl');
  late final _git_remote_pushurl = _git_remote_pushurlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)>();

  /// Set the remote's url in the configuration
  ///
  /// Remote objects already in memory will not be affected. This assumes
  /// the common case of a single-url remote and will otherwise return an error.
  ///
  /// @param repo the repository in which to perform the change
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0 or an error value
  int git_remote_set_url(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_url(
      repo,
      remote,
      url,
    );
  }

  late final _git_remote_set_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_url');
  late final _git_remote_set_url = _git_remote_set_urlPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set the remote's url for pushing in the configuration.
  ///
  /// Remote objects already in memory will not be affected. This assumes
  /// the common case of a single-url remote and will otherwise return an error.
  ///
  ///
  /// @param repo the repository in which to perform the change
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0, or an error code
  int git_remote_set_pushurl(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_pushurl(
      repo,
      remote,
      url,
    );
  }

  late final _git_remote_set_pushurlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_pushurl');
  late final _git_remote_set_pushurl = _git_remote_set_pushurlPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set the url for this particular url instance.  The URL in the
  /// configuration will be ignored, and will not be changed.
  ///
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0 or an error value
  int git_remote_set_instance_url(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_instance_url(
      remote,
      url,
    );
  }

  late final _git_remote_set_instance_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_instance_url');
  late final _git_remote_set_instance_url =
      _git_remote_set_instance_urlPtr.asFunction<
          int Function(ffi.Pointer<git_remote>, ffi.Pointer<ffi.Char>)>();

  /// Set the push url for this particular url instance.  The URL in the
  /// configuration will be ignored, and will not be changed.
  ///
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0 or an error value
  int git_remote_set_instance_pushurl(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_instance_pushurl(
      remote,
      url,
    );
  }

  late final _git_remote_set_instance_pushurlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_instance_pushurl');
  late final _git_remote_set_instance_pushurl =
      _git_remote_set_instance_pushurlPtr.asFunction<
          int Function(ffi.Pointer<git_remote>, ffi.Pointer<ffi.Char>)>();

  /// Add a fetch refspec to the remote's configuration
  ///
  /// Add the given refspec to the fetch list in the configuration. No
  /// loaded remote instances will be affected.
  ///
  /// @param repo the repository in which to change the configuration
  /// @param remote the name of the remote to change
  /// @param refspec the new fetch refspec
  /// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
  int git_remote_add_fetch(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> refspec,
  ) {
    return _git_remote_add_fetch(
      repo,
      remote,
      refspec,
    );
  }

  late final _git_remote_add_fetchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_add_fetch');
  late final _git_remote_add_fetch = _git_remote_add_fetchPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the remote's list of fetch refspecs
  ///
  /// The memory is owned by the user and should be freed with
  /// `git_strarray_free`.
  ///
  /// @param array pointer to the array in which to store the strings
  /// @param remote the remote to query
  /// @return 0 or an error code.
  int git_remote_get_fetch_refspecs(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_get_fetch_refspecs(
      array,
      remote,
    );
  }

  late final _git_remote_get_fetch_refspecsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_remote>)>>('git_remote_get_fetch_refspecs');
  late final _git_remote_get_fetch_refspecs =
      _git_remote_get_fetch_refspecsPtr.asFunction<
          int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_remote>)>();

  /// Add a push refspec to the remote's configuration
  ///
  /// Add the given refspec to the push list in the configuration. No
  /// loaded remote instances will be affected.
  ///
  /// @param repo the repository in which to change the configuration
  /// @param remote the name of the remote to change
  /// @param refspec the new push refspec
  /// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
  int git_remote_add_push(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> refspec,
  ) {
    return _git_remote_add_push(
      repo,
      remote,
      refspec,
    );
  }

  late final _git_remote_add_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_add_push');
  late final _git_remote_add_push = _git_remote_add_pushPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the remote's list of push refspecs
  ///
  /// The memory is owned by the user and should be freed with
  /// `git_strarray_free`.
  ///
  /// @param array pointer to the array in which to store the strings
  /// @param remote the remote to query
  /// @return 0 or an error code.
  int git_remote_get_push_refspecs(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_get_push_refspecs(
      array,
      remote,
    );
  }

  late final _git_remote_get_push_refspecsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_remote>)>>('git_remote_get_push_refspecs');
  late final _git_remote_get_push_refspecs =
      _git_remote_get_push_refspecsPtr.asFunction<
          int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_remote>)>();

  /// Get the number of refspecs for a remote
  ///
  /// @param remote the remote
  /// @return the amount of refspecs configured in this remote
  int git_remote_refspec_count(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_refspec_count(
      remote,
    );
  }

  late final _git_remote_refspec_countPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_remote>)>>(
          'git_remote_refspec_count');
  late final _git_remote_refspec_count = _git_remote_refspec_countPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Get a refspec from the remote
  ///
  /// @param remote the remote to query
  /// @param n the refspec to get
  /// @return the nth refspec
  ffi.Pointer<git_refspec> git_remote_get_refspec(
    ffi.Pointer<git_remote> remote,
    int n,
  ) {
    return _git_remote_get_refspec(
      remote,
      n,
    );
  }

  late final _git_remote_get_refspecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_refspec> Function(
              ffi.Pointer<git_remote>, ffi.Size)>>('git_remote_get_refspec');
  late final _git_remote_get_refspec = _git_remote_get_refspecPtr.asFunction<
      ffi.Pointer<git_refspec> Function(ffi.Pointer<git_remote>, int)>();

  /// Get the remote repository's reference advertisement list
  ///
  /// Get the list of references with which the server responds to a new
  /// connection.
  ///
  /// The remote (or more exactly its transport) must have connected to
  /// the remote repository. This list is available as soon as the
  /// connection to the remote is initiated and it remains available
  /// after disconnecting.
  ///
  /// The memory belongs to the remote. The pointer will be valid as long
  /// as a new connection is not initiated, but it is recommended that
  /// you make a copy in order to make use of the data.
  ///
  /// @param out pointer to the array
  /// @param size the number of remote heads
  /// @param remote the remote
  /// @return 0 on success, or an error code
  int git_remote_ls(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> out,
    ffi.Pointer<ffi.Size> size,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_ls(
      out,
      size,
      remote,
    );
  }

  late final _git_remote_lsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_remote>)>>('git_remote_ls');
  late final _git_remote_ls = _git_remote_lsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<git_remote>)>();

  /// Check whether the remote is connected
  ///
  /// Check whether the remote's underlying transport is connected to the
  /// remote host.
  ///
  /// @param remote the remote
  /// @return 1 if it's connected, 0 otherwise.
  int git_remote_connected(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_connected(
      remote,
    );
  }

  late final _git_remote_connectedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_connected');
  late final _git_remote_connected = _git_remote_connectedPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Cancel the operation
  ///
  /// At certain points in its operation, the network code checks whether
  /// the operation has been cancelled and if so stops the operation.
  ///
  /// @param remote the remote
  /// @return 0 on success, or an error code
  int git_remote_stop(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_stop(
      remote,
    );
  }

  late final _git_remote_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_stop');
  late final _git_remote_stop =
      _git_remote_stopPtr.asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Disconnect from the remote
  ///
  /// Close the connection to the remote.
  ///
  /// @param remote the remote to disconnect from
  /// @return 0 on success, or an error code
  int git_remote_disconnect(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_disconnect(
      remote,
    );
  }

  late final _git_remote_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_disconnect');
  late final _git_remote_disconnect = _git_remote_disconnectPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Free the memory associated with a remote
  ///
  /// This also disconnects from the remote, if the connection
  /// has not been closed yet (using git_remote_disconnect).
  ///
  /// @param remote the remote to free
  void git_remote_free(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_free(
      remote,
    );
  }

  late final _git_remote_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_remote>)>>(
          'git_remote_free');
  late final _git_remote_free =
      _git_remote_freePtr.asFunction<void Function(ffi.Pointer<git_remote>)>();

  /// Get a list of the configured remotes for a repo
  ///
  /// The string array must be freed by the user.
  ///
  /// @param out a string array which receives the names of the remotes
  /// @param repo the repository to query
  /// @return 0 or an error code
  int git_remote_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_remote_list(
      out,
      repo,
    );
  }

  late final _git_remote_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_remote_list');
  late final _git_remote_list = _git_remote_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Initializes a `git_remote_callbacks` with default values. Equivalent to
  /// creating an instance with GIT_REMOTE_CALLBACKS_INIT.
  ///
  /// @param opts the `git_remote_callbacks` struct to initialize
  /// @param version Version of struct; pass `GIT_REMOTE_CALLBACKS_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_remote_init_callbacks(
    ffi.Pointer<git_remote_callbacks> opts,
    int version,
  ) {
    return _git_remote_init_callbacks(
      opts,
      version,
    );
  }

  late final _git_remote_init_callbacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_callbacks>,
              ffi.UnsignedInt)>>('git_remote_init_callbacks');
  late final _git_remote_init_callbacks = _git_remote_init_callbacksPtr
      .asFunction<int Function(ffi.Pointer<git_remote_callbacks>, int)>();

  /// Initialize git_fetch_options structure
  ///
  /// Initializes a `git_fetch_options` with default values. Equivalent to
  /// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_fetch_options` struct to initialize.
  /// @param version The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_fetch_options_init(
    ffi.Pointer<git_fetch_options> opts,
    int version,
  ) {
    return _git_fetch_options_init(
      opts,
      version,
    );
  }

  late final _git_fetch_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_fetch_options>,
              ffi.UnsignedInt)>>('git_fetch_options_init');
  late final _git_fetch_options_init = _git_fetch_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_fetch_options>, int)>();

  /// Initialize git_push_options structure
  ///
  /// Initializes a `git_push_options` with default values. Equivalent to
  /// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_push_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_push_options_init(
    ffi.Pointer<git_push_options> opts,
    int version,
  ) {
    return _git_push_options_init(
      opts,
      version,
    );
  }

  late final _git_push_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_push_options>,
              ffi.UnsignedInt)>>('git_push_options_init');
  late final _git_push_options_init = _git_push_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_push_options>, int)>();

  /// Initialize git_remote_connect_options structure.
  ///
  /// Initializes a `git_remote_connect_options` with default values.
  /// Equivalent to creating an instance with
  /// `GIT_REMOTE_CONNECT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_remote_connect_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REMOTE_CONNECT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_remote_connect_options_init(
    ffi.Pointer<git_remote_connect_options> opts,
    int version,
  ) {
    return _git_remote_connect_options_init(
      opts,
      version,
    );
  }

  late final _git_remote_connect_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_connect_options>,
              ffi.UnsignedInt)>>('git_remote_connect_options_init');
  late final _git_remote_connect_options_init =
      _git_remote_connect_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_remote_connect_options>, int)>();

  /// Open a connection to a remote.
  ///
  /// The transport is selected based on the URL; the direction argument
  /// is due to a limitation of the git protocol which starts up a
  /// specific binary which can only do the one or the other.
  ///
  /// @param remote the remote to connect to
  /// @param direction GIT_DIRECTION_FETCH if you want to fetch or
  /// GIT_DIRECTION_PUSH if you want to push
  /// @param callbacks the callbacks to use for this connection
  /// @param proxy_opts proxy settings
  /// @param custom_headers extra HTTP headers to use in this connection
  /// @return 0 or an error code
  int git_remote_connect(
    ffi.Pointer<git_remote> remote,
    git_direction direction,
    ffi.Pointer<git_remote_callbacks> callbacks,
    ffi.Pointer<git_proxy_options> proxy_opts,
    ffi.Pointer<git_strarray> custom_headers,
  ) {
    return _git_remote_connect(
      remote,
      direction.value,
      callbacks,
      proxy_opts,
      custom_headers,
    );
  }

  late final _git_remote_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_remote>,
              ffi.UnsignedInt,
              ffi.Pointer<git_remote_callbacks>,
              ffi.Pointer<git_proxy_options>,
              ffi.Pointer<git_strarray>)>>('git_remote_connect');
  late final _git_remote_connect = _git_remote_connectPtr.asFunction<
      int Function(
          ffi.Pointer<git_remote>,
          int,
          ffi.Pointer<git_remote_callbacks>,
          ffi.Pointer<git_proxy_options>,
          ffi.Pointer<git_strarray>)>();

  /// Open a connection to a remote with extended options.
  ///
  /// The transport is selected based on the URL; the direction argument
  /// is due to a limitation of the git protocol which starts up a
  /// specific binary which can only do the one or the other.
  ///
  /// The given options structure will form the defaults for connection
  /// options and callback setup.  Callers may override these defaults
  /// by specifying `git_fetch_options` or `git_push_options` in
  /// subsequent calls.
  ///
  /// @param remote the remote to connect to
  /// @param direction GIT_DIRECTION_FETCH if you want to fetch or
  /// GIT_DIRECTION_PUSH if you want to push
  /// @param opts the remote connection options
  /// @return 0 or an error code
  int git_remote_connect_ext(
    ffi.Pointer<git_remote> remote,
    git_direction direction,
    ffi.Pointer<git_remote_connect_options> opts,
  ) {
    return _git_remote_connect_ext(
      remote,
      direction.value,
      opts,
    );
  }

  late final _git_remote_connect_extPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_remote>, ffi.UnsignedInt,
                  ffi.Pointer<git_remote_connect_options>)>>(
      'git_remote_connect_ext');
  late final _git_remote_connect_ext = _git_remote_connect_extPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, int,
          ffi.Pointer<git_remote_connect_options>)>();

  /// Download and index the packfile.
  ///
  /// Connect to the remote if it hasn't been done yet, negotiate with
  /// the remote git which objects are missing, download and index the
  /// packfile.
  ///
  /// The .idx file will be created and both it and the packfile with be
  /// renamed to their final name.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote
  /// @param refspecs the refspecs to use for this negotiation and
  /// download. Use NULL or an empty array to use the base refspecs
  /// @param opts the options to use for this fetch or NULL
  /// @return 0 or an error code
  int git_remote_download(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
  ) {
    return _git_remote_download(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_downloadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
              ffi.Pointer<git_fetch_options>)>>('git_remote_download');
  late final _git_remote_download = _git_remote_downloadPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_fetch_options>)>();

  /// Create a packfile and send it to the server
  ///
  /// Connect to the remote if it hasn't been done yet, negotiate with
  /// the remote git which objects are missing, create a packfile with
  /// the missing objects and send it.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote
  /// @param refspecs the refspecs to use for this negotiation and
  /// upload. Use NULL or an empty array to use the base refspecs
  /// @param opts the options to use for this push
  /// @return 0 or an error code
  int git_remote_upload(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _git_remote_upload(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_uploadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
              ffi.Pointer<git_push_options>)>>('git_remote_upload');
  late final _git_remote_upload = _git_remote_uploadPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_push_options>)>();

  /// Update the tips to the new state.
  ///
  /// If callbacks are not specified then the callbacks specified to
  /// `git_remote_connect` will be used (if it was called).
  ///
  /// @param remote the remote to update
  /// @param callbacks  pointer to the callback structure to use or NULL
  /// @param update_flags the git_remote_update_flags for these tips.
  /// @param download_tags what the behaviour for downloading tags is for this fetch. This is
  /// ignored for push. This must be the same value passed to `git_remote_download()`.
  /// @param reflog_message The message to insert into the reflogs. If
  /// NULL and fetching, the default is "fetch <name>", where <name> is
  /// the name of the remote (or its url, for in-memory remotes). This
  /// parameter is ignored when pushing.
  /// @return 0 or an error code
  int git_remote_update_tips(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_remote_callbacks> callbacks,
    int update_flags,
    git_remote_autotag_option_t download_tags,
    ffi.Pointer<ffi.Char> reflog_message,
  ) {
    return _git_remote_update_tips(
      remote,
      callbacks,
      update_flags,
      download_tags.value,
      reflog_message,
    );
  }

  late final _git_remote_update_tipsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_remote>,
              ffi.Pointer<git_remote_callbacks>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('git_remote_update_tips');
  late final _git_remote_update_tips = _git_remote_update_tipsPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_remote_callbacks>,
          int, int, ffi.Pointer<ffi.Char>)>();

  /// Download new data and update tips.
  ///
  /// Convenience function to connect to a remote, download the data,
  /// disconnect and update the remote-tracking branches.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote to fetch from
  /// @param refspecs the refspecs to use for this fetch. Pass NULL or an
  /// empty array to use the base refspecs.
  /// @param opts options to use for this fetch or NULL
  /// @param reflog_message The message to insert into the reflogs. If NULL, the
  /// default is "fetch"
  /// @return 0 or an error code
  int git_remote_fetch(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
    ffi.Pointer<ffi.Char> reflog_message,
  ) {
    return _git_remote_fetch(
      remote,
      refspecs,
      opts,
      reflog_message,
    );
  }

  late final _git_remote_fetchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_remote>,
              ffi.Pointer<git_strarray>,
              ffi.Pointer<git_fetch_options>,
              ffi.Pointer<ffi.Char>)>>('git_remote_fetch');
  late final _git_remote_fetch = _git_remote_fetchPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_fetch_options>, ffi.Pointer<ffi.Char>)>();

  /// Prune tracking refs that are no longer present on remote.
  ///
  /// If callbacks are not specified then the callbacks specified to
  /// `git_remote_connect` will be used (if it was called).
  ///
  /// @param remote the remote to prune
  /// @param callbacks callbacks to use for this prune
  /// @return 0 or an error code
  int git_remote_prune(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_remote_callbacks> callbacks,
  ) {
    return _git_remote_prune(
      remote,
      callbacks,
    );
  }

  late final _git_remote_prunePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>,
              ffi.Pointer<git_remote_callbacks>)>>('git_remote_prune');
  late final _git_remote_prune = _git_remote_prunePtr.asFunction<
      int Function(
          ffi.Pointer<git_remote>, ffi.Pointer<git_remote_callbacks>)>();

  /// Perform a push.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote to push to
  /// @param refspecs the refspecs to use for pushing. If NULL or an empty
  /// array, the configured refspecs will be used
  /// @param opts options to use for this push
  /// @return 0 or an error code.
  int git_remote_push(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _git_remote_push(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
              ffi.Pointer<git_push_options>)>>('git_remote_push');
  late final _git_remote_push = _git_remote_pushPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_push_options>)>();

  /// Get the statistics structure that is filled in by the fetch operation.
  ///
  /// @param remote the remote to get statistics for
  /// @return the git_indexer_progress for the remote
  ffi.Pointer<git_indexer_progress> git_remote_stats(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_stats(
      remote,
    );
  }

  late final _git_remote_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_indexer_progress> Function(
              ffi.Pointer<git_remote>)>>('git_remote_stats');
  late final _git_remote_stats = _git_remote_statsPtr.asFunction<
      ffi.Pointer<git_indexer_progress> Function(ffi.Pointer<git_remote>)>();

  /// Retrieve the tag auto-follow setting
  ///
  /// @param remote the remote to query
  /// @return the auto-follow setting
  git_remote_autotag_option_t git_remote_autotag(
    ffi.Pointer<git_remote> remote,
  ) {
    return git_remote_autotag_option_t.fromValue(_git_remote_autotag(
      remote,
    ));
  }

  late final _git_remote_autotagPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<git_remote>)>>(
      'git_remote_autotag');
  late final _git_remote_autotag = _git_remote_autotagPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Set the remote's tag following setting.
  ///
  /// The change will be made in the configuration. No loaded remotes
  /// will be affected.
  ///
  /// @param repo the repository in which to make the change
  /// @param remote the name of the remote
  /// @param value the new value to take.
  /// @return 0, or an error code.
  int git_remote_set_autotag(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    git_remote_autotag_option_t value,
  ) {
    return _git_remote_set_autotag(
      repo,
      remote,
      value.value,
    );
  }

  late final _git_remote_set_autotagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_remote_set_autotag');
  late final _git_remote_set_autotag = _git_remote_set_autotagPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Retrieve the ref-prune setting
  ///
  /// @param remote the remote to query
  /// @return the ref-prune setting
  int git_remote_prune_refs(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_prune_refs(
      remote,
    );
  }

  late final _git_remote_prune_refsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_prune_refs');
  late final _git_remote_prune_refs = _git_remote_prune_refsPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Give the remote a new name
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote are updated.
  ///
  /// The new name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// No loaded instances of a the remote with the old name will change
  /// their name or their list of refspecs.
  ///
  /// @param problems non-default refspecs cannot be renamed and will be
  /// stored here for further processing by the caller. Always free this
  /// strarray on successful return.
  /// @param repo the repository in which to rename
  /// @param name the current name of the remote
  /// @param new_name the new name the remote should bear
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_rename(
    ffi.Pointer<git_strarray> problems,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> new_name,
  ) {
    return _git_remote_rename(
      problems,
      repo,
      name,
      new_name,
    );
  }

  late final _git_remote_renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_rename');
  late final _git_remote_rename = _git_remote_renamePtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Ensure the remote name is well-formed.
  ///
  /// @param valid output pointer to set with validity of given remote name
  /// @param remote_name name to be checked.
  /// @return 0 on success or an error code
  int git_remote_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> remote_name,
  ) {
    return _git_remote_name_is_valid(
      valid,
      remote_name,
    );
  }

  late final _git_remote_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_remote_name_is_valid');
  late final _git_remote_name_is_valid = _git_remote_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Delete an existing persisted remote.
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote will be removed.
  ///
  /// @param repo the repository in which to act
  /// @param name the name of the remote to delete
  /// @return 0 on success, or an error code.
  int git_remote_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_remote_delete(
      repo,
      name,
    );
  }

  late final _git_remote_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_remote_delete');
  late final _git_remote_delete = _git_remote_deletePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Retrieve the name of the remote's default branch
  ///
  /// The default branch of a repository is the branch which HEAD points
  /// to. If the remote does not support reporting this information
  /// directly, it performs the guess as git does; that is, if there are
  /// multiple branches which point to the same commit, the first one is
  /// chosen. If the master branch is a candidate, it wins.
  ///
  /// This function must only be called after connecting.
  ///
  /// @param out the buffer in which to store the reference name
  /// @param remote the remote
  /// @return 0, GIT_ENOTFOUND if the remote does not have any references
  /// or none of them point to HEAD's commit, or an error message.
  int git_remote_default_branch(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_default_branch(
      out,
      remote,
    );
  }

  late final _git_remote_default_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_remote>)>>('git_remote_default_branch');
  late final _git_remote_default_branch =
      _git_remote_default_branchPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_remote>)>();

  /// Initialize git_clone_options structure
  ///
  /// Initializes a `git_clone_options` with default values. Equivalent to creating
  /// an instance with GIT_CLONE_OPTIONS_INIT.
  ///
  /// @param opts The `git_clone_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_clone_options_init(
    ffi.Pointer<git_clone_options> opts,
    int version,
  ) {
    return _git_clone_options_init(
      opts,
      version,
    );
  }

  late final _git_clone_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_clone_options>,
              ffi.UnsignedInt)>>('git_clone_options_init');
  late final _git_clone_options_init = _git_clone_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_clone_options>, int)>();

  /// Clone a remote repository.
  ///
  /// By default this creates its repository and initial remote to match
  /// git's defaults. You can use the options in the callback to
  /// customize how these are created.
  ///
  /// Note that the libgit2 library _must_ be initialized using
  /// `git_libgit2_init` before any APIs can be called, including
  /// this one.
  ///
  /// @param[out] out pointer that will receive the resulting repository object
  /// @param url the remote repository to clone
  /// @param local_path local directory to clone to
  /// @param options configuration options for the clone.  If NULL, the
  /// function works as though GIT_OPTIONS_INIT were passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message)
  int git_clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> local_path,
    ffi.Pointer<git_clone_options> options,
  ) {
    return _git_clone(
      out,
      url,
      local_path,
      options,
    );
  }

  late final _git_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_clone_options>)>>('git_clone');
  late final _git_clone = _git_clonePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_clone_options>)>();

  /// Free a config entry.
  ///
  /// @param entry The entry to free.
  void git_config_entry_free(
    ffi.Pointer<git_config_entry> entry,
  ) {
    return _git_config_entry_free(
      entry,
    );
  }

  late final _git_config_entry_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_config_entry>)>>(
      'git_config_entry_free');
  late final _git_config_entry_free = _git_config_entry_freePtr
      .asFunction<void Function(ffi.Pointer<git_config_entry>)>();

  /// Locate the path to the global configuration file
  ///
  /// The user or global configuration file is usually
  /// located in `$HOME/.gitconfig`.
  ///
  /// This method will try to guess the full path to that
  /// file, if the file exists. The returned path
  /// may be used on any `git_config` call to load the
  /// global configuration file.
  ///
  /// This method will not guess the path to the xdg compatible
  /// config file (`.config/git/config`).
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a global configuration file has been found. Its path will be stored in `out`.
  int git_config_find_global(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_global(
      out,
    );
  }

  late final _git_config_find_globalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_global');
  late final _git_config_find_global = _git_config_find_globalPtr
      .asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Locate the path to the global xdg compatible configuration file
  ///
  /// The xdg compatible configuration file is usually
  /// located in `$HOME/.config/git/config`.
  ///
  /// This method will try to guess the full path to that
  /// file, if the file exists. The returned path
  /// may be used on any `git_config` call to load the
  /// xdg compatible configuration file.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a xdg compatible configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_xdg(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_xdg(
      out,
    );
  }

  late final _git_config_find_xdgPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_xdg');
  late final _git_config_find_xdg =
      _git_config_find_xdgPtr.asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Locate the path to the system configuration file
  ///
  /// If `/etc/gitconfig` doesn't exist, it will look for
  /// `%PROGRAMFILES%\Git\etc\gitconfig`.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a system configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_system(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_system(
      out,
    );
  }

  late final _git_config_find_systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_system');
  late final _git_config_find_system = _git_config_find_systemPtr
      .asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Locate the path to the configuration file in ProgramData
  ///
  /// Look for the file in `%PROGRAMDATA%\Git\config` used by portable git.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a ProgramData configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_programdata(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_programdata(
      out,
    );
  }

  late final _git_config_find_programdataPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_programdata');
  late final _git_config_find_programdata = _git_config_find_programdataPtr
      .asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Open the global, XDG and system configuration files
  ///
  /// Utility wrapper that finds the global, XDG and system configuration files
  /// and opens them into a single prioritized config object that can be
  /// used when accessing default config data outside a repository.
  ///
  /// @param out Pointer to store the config instance
  /// @return 0 or an error code
  int git_config_open_default(
    ffi.Pointer<ffi.Pointer<git_config>> out,
  ) {
    return _git_config_open_default(
      out,
    );
  }

  late final _git_config_open_defaultPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>)>>(
      'git_config_open_default');
  late final _git_config_open_default = _git_config_open_defaultPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_config>>)>();

  /// Allocate a new configuration object
  ///
  /// This object is empty, so you have to add a file to it before you
  /// can do anything with it.
  ///
  /// @param out pointer to the new configuration
  /// @return 0 or an error code
  int git_config_new(
    ffi.Pointer<ffi.Pointer<git_config>> out,
  ) {
    return _git_config_new(
      out,
    );
  }

  late final _git_config_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config>>)>>('git_config_new');
  late final _git_config_new = _git_config_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_config>>)>();

  /// Add an on-disk config file instance to an existing config
  ///
  /// The on-disk file pointed at by `path` will be opened and
  /// parsed; it's expected to be a native Git config file following
  /// the default Git config syntax (see man git-config).
  ///
  /// If the file does not exist, the file will still be added and it
  /// will be created the first time we write to it.
  ///
  /// Note that the configuration object will free the file
  /// automatically.
  ///
  /// Further queries on this config object will access each
  /// of the config file instances in order (instances with
  /// a higher priority level will be accessed first).
  ///
  /// @param cfg the configuration to add the file to
  /// @param path path to the configuration file to add
  /// @param level the priority level of the backend
  /// @param repo optional repository to allow parsing of
  /// conditional includes
  /// @param force replace config file at the given priority level
  /// @return 0 on success, GIT_EEXISTS when adding more than one file
  /// for a given priority level (and force_replace set to 0),
  /// GIT_ENOTFOUND when the file doesn't exist or error code
  int git_config_add_file_ondisk(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> path,
    git_config_level_t level,
    ffi.Pointer<git_repository> repo,
    int force,
  ) {
    return _git_config_add_file_ondisk(
      cfg,
      path,
      level.value,
      repo,
      force,
    );
  }

  late final _git_config_add_file_ondiskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<git_repository>,
              ffi.Int)>>('git_config_add_file_ondisk');
  late final _git_config_add_file_ondisk =
      _git_config_add_file_ondiskPtr.asFunction<
          int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<git_repository>, int)>();

  /// Create a new config instance containing a single on-disk file
  ///
  /// This method is a simple utility wrapper for the following sequence
  /// of calls:
  /// - git_config_new
  /// - git_config_add_file_ondisk
  ///
  /// @param out The configuration instance to create
  /// @param path Path to the on-disk file to open
  /// @return 0 on success, or an error code
  int git_config_open_ondisk(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_config_open_ondisk(
      out,
      path,
    );
  }

  late final _git_config_open_ondiskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<ffi.Char>)>>('git_config_open_ondisk');
  late final _git_config_open_ondisk = _git_config_open_ondiskPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<ffi.Char>)>();

  /// Build a single-level focused config object from a multi-level one.
  ///
  /// The returned config object can be used to perform get/set/delete operations
  /// on a single specific level.
  ///
  /// Getting several times the same level from the same parent multi-level config
  /// will return different config instances, but containing the same config_file
  /// instance.
  ///
  /// @param out The configuration instance to create
  /// @param parent Multi-level config to search for the given level
  /// @param level Configuration level to search for
  /// @return 0, GIT_ENOTFOUND if the passed level cannot be found in the
  /// multi-level parent config, or an error code
  int git_config_open_level(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> parent,
    git_config_level_t level,
  ) {
    return _git_config_open_level(
      out,
      parent,
      level.value,
    );
  }

  late final _git_config_open_levelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_config>, ffi.Int)>>('git_config_open_level');
  late final _git_config_open_level = _git_config_open_levelPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config>>,
          ffi.Pointer<git_config>, int)>();

  /// Open the global/XDG configuration file according to git's rules
  ///
  /// Git allows you to store your global configuration at
  /// `$HOME/.gitconfig` or `$XDG_CONFIG_HOME/git/config`. For backwards
  /// compatibility, the XDG file shouldn't be used unless the use has
  /// created it explicitly. With this function you'll open the correct
  /// one to write to.
  ///
  /// @param out pointer in which to store the config object
  /// @param config the config object in which to look
  /// @return 0 or an error code.
  int git_config_open_global(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> config,
  ) {
    return _git_config_open_global(
      out,
      config,
    );
  }

  late final _git_config_open_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_config>)>>('git_config_open_global');
  late final _git_config_open_global = _git_config_open_globalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<git_config>)>();

  /// Set the write order for configuration backends. By default, the
  /// write ordering does not match the read ordering; for example, the
  /// worktree configuration is a high-priority for reading, but is not
  /// written to unless explicitly chosen.
  ///
  /// @param cfg the configuration to change write order of
  /// @param levels the ordering of levels for writing
  /// @param len the length of the levels array
  /// @return 0 or an error code
  int git_config_set_writeorder(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int> levels,
    int len,
  ) {
    return _git_config_set_writeorder(
      cfg,
      levels,
      len,
    );
  }

  late final _git_config_set_writeorderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Int>,
              ffi.Size)>>('git_config_set_writeorder');
  late final _git_config_set_writeorder =
      _git_config_set_writeorderPtr.asFunction<
          int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Int>, int)>();

  /// Create a snapshot of the configuration
  ///
  /// Create a snapshot of the current state of a configuration, which
  /// allows you to look into a consistent view of the configuration for
  /// looking up complex values (e.g. a remote, submodule).
  ///
  /// The string returned when querying such a config object is valid
  /// until it is freed.
  ///
  /// @param out pointer in which to store the snapshot config object
  /// @param config configuration to snapshot
  /// @return 0 or an error code
  int git_config_snapshot(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> config,
  ) {
    return _git_config_snapshot(
      out,
      config,
    );
  }

  late final _git_config_snapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_config>)>>('git_config_snapshot');
  late final _git_config_snapshot = _git_config_snapshotPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<git_config>)>();

  /// Free the configuration and its associated memory and files
  ///
  /// @param cfg the configuration to free
  void git_config_free(
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_free(
      cfg,
    );
  }

  late final _git_config_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_config>)>>(
          'git_config_free');
  late final _git_config_free =
      _git_config_freePtr.asFunction<void Function(ffi.Pointer<git_config>)>();

  /// Get the git_config_entry of a config variable.
  ///
  /// Free the git_config_entry after use with `git_config_entry_free()`.
  ///
  /// @param out pointer to the variable git_config_entry
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_entry(
    ffi.Pointer<ffi.Pointer<git_config_entry>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_entry(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config_entry>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_entry');
  late final _git_config_get_entry = _git_config_get_entryPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config_entry>>,
          ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>)>();

  /// Get the value of an integer config variable.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_int32(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_int32(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_int32');
  late final _git_config_get_int32 = _git_config_get_int32Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a long integer config variable.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_int64(
    ffi.Pointer<ffi.Int64> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_int64(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_int64');
  late final _git_config_get_int64 = _git_config_get_int64Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a boolean config variable.
  ///
  /// This function uses the usual C convention of 0 being false and
  /// anything else true.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_bool(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_bool(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_bool');
  late final _git_config_get_bool = _git_config_get_boolPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a path config variable.
  ///
  /// A leading '~' will be expanded to the global search path (which
  /// defaults to the user's home directory but can be overridden via
  /// `git_libgit2_opts()`.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out the buffer in which to store the result
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_path(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_path');
  late final _git_config_get_path = _git_config_get_pathPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a string config variable.
  ///
  /// This function can only be used on snapshot config objects. The
  /// string is owned by the config and should not be freed by the
  /// user. The pointer will be valid until the config is freed.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the string
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_string(
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_string(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_string');
  late final _git_config_get_string = _git_config_get_stringPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a string config variable.
  ///
  /// The value of the config will be copied into the buffer.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out buffer in which to store the string
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_string_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_string_buf(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_string_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_string_buf');
  late final _git_config_get_string_buf =
      _git_config_get_string_bufPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>();

  /// Get each value of a multivar in a foreach callback
  ///
  /// The callback will be called on each variable found
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp regular expression to filter which variables we're
  /// interested in. Use NULL to indicate all
  /// @param callback the function to be called on each value of the variable
  /// @param payload opaque pointer to pass to the callback
  /// @return 0 or an error code.
  int git_config_get_multivar_foreach(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_get_multivar_foreach(
      cfg,
      name,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_get_multivar_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_get_multivar_foreach');
  late final _git_config_get_multivar_foreach =
      _git_config_get_multivar_foreachPtr.asFunction<
          int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>();

  /// Get each value of a multivar
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp regular expression to filter which variables we're
  /// interested in. Use NULL to indicate all
  /// @return 0 or an error code.
  int git_config_multivar_iterator_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
  ) {
    return _git_config_multivar_iterator_new(
      out,
      cfg,
      name,
      regexp,
    );
  }

  late final _git_config_multivar_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_multivar_iterator_new');
  late final _git_config_multivar_iterator_new =
      _git_config_multivar_iterator_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Return the current entry and advance the iterator
  ///
  /// The pointers returned by this function are valid until the next call
  /// to `git_config_next` or until the iterator is freed.
  ///
  /// @param entry pointer to store the entry
  /// @param iter the iterator
  /// @return 0 or an error code. GIT_ITEROVER if the iteration has completed
  int git_config_next(
    ffi.Pointer<ffi.Pointer<git_config_entry>> entry,
    ffi.Pointer<git_config_iterator> iter,
  ) {
    return _git_config_next(
      entry,
      iter,
    );
  }

  late final _git_config_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_entry>>,
              ffi.Pointer<git_config_iterator>)>>('git_config_next');
  late final _git_config_next = _git_config_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config_entry>>,
          ffi.Pointer<git_config_iterator>)>();

  /// Free a config iterator
  ///
  /// @param iter the iterator to free
  void git_config_iterator_free(
    ffi.Pointer<git_config_iterator> iter,
  ) {
    return _git_config_iterator_free(
      iter,
    );
  }

  late final _git_config_iterator_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<git_config_iterator>)>>(
      'git_config_iterator_free');
  late final _git_config_iterator_free = _git_config_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_config_iterator>)>();

  /// Set the value of an integer config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value Integer value for the variable
  /// @return 0 or an error code
  int git_config_set_int32(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _git_config_set_int32(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_config_set_int32');
  late final _git_config_set_int32 = _git_config_set_int32Ptr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the value of a long integer config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value Long integer value for the variable
  /// @return 0 or an error code
  int git_config_set_int64(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _git_config_set_int64(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('git_config_set_int64');
  late final _git_config_set_int64 = _git_config_set_int64Ptr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the value of a boolean config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value the value to store
  /// @return 0 or an error code
  int git_config_set_bool(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _git_config_set_bool(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_config_set_bool');
  late final _git_config_set_bool = _git_config_set_boolPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the value of a string config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// A copy of the string is made and the user is free to use it
  /// afterwards.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value the string to store.
  /// @return 0 or an error code
  int git_config_set_string(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_set_string(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_set_string');
  late final _git_config_set_string = _git_config_set_stringPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set a multivar in the local config file.
  ///
  /// The regular expression is applied case-sensitively on the value.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp a regular expression to indicate which values to replace
  /// @param value the new value.
  /// @return 0 or an error code.
  int git_config_set_multivar(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_set_multivar(
      cfg,
      name,
      regexp,
      value,
    );
  }

  late final _git_config_set_multivarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_set_multivar');
  late final _git_config_set_multivar = _git_config_set_multivarPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Delete a config variable from the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg the configuration
  /// @param name the variable to delete
  /// @return 0 or an error code.
  int git_config_delete_entry(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_delete_entry(
      cfg,
      name,
    );
  }

  late final _git_config_delete_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_delete_entry');
  late final _git_config_delete_entry = _git_config_delete_entryPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>)>();

  /// Deletes one or several entries from a multivar in the local config file.
  ///
  /// The regular expression is applied case-sensitively on the value.
  ///
  /// @param cfg where to look for the variables
  /// @param name the variable's name
  /// @param regexp a regular expression to indicate which values to delete
  ///
  /// @return 0 or an error code
  int git_config_delete_multivar(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
  ) {
    return _git_config_delete_multivar(
      cfg,
      name,
      regexp,
    );
  }

  late final _git_config_delete_multivarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_delete_multivar');
  late final _git_config_delete_multivar =
      _git_config_delete_multivarPtr.asFunction<
          int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Perform an operation on each config variable.
  ///
  /// The callback receives the normalized name and value of each variable
  /// in the config backend, and the data pointer passed to this function.
  /// If the callback returns a non-zero value, the function stops iterating
  /// and returns that value to the caller.
  ///
  /// The pointers passed to the callback are only valid as long as the
  /// iteration is ongoing.
  ///
  /// @param cfg where to get the variables from
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_config_foreach(
    ffi.Pointer<git_config> cfg,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_foreach(
      cfg,
      callback,
      payload,
    );
  }

  late final _git_config_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_foreach');
  late final _git_config_foreach = _git_config_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_config>, git_config_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Iterate over all the config variables
  ///
  /// Use `git_config_next` to advance the iteration and
  /// `git_config_iterator_free` when done.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to get the variables from
  /// @return 0 or an error code.
  int git_config_iterator_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_iterator_new(
      out,
      cfg,
    );
  }

  late final _git_config_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>)>>('git_config_iterator_new');
  late final _git_config_iterator_new = _git_config_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>>,
          ffi.Pointer<git_config>)>();

  /// Iterate over all the config variables whose name matches a pattern
  ///
  /// Use `git_config_next` to advance the iteration and
  /// `git_config_iterator_free` when done.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to ge the variables from
  /// @param regexp regular expression to match the names
  /// @return 0 or an error code.
  int git_config_iterator_glob_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> regexp,
  ) {
    return _git_config_iterator_glob_new(
      out,
      cfg,
      regexp,
    );
  }

  late final _git_config_iterator_glob_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_iterator_glob_new');
  late final _git_config_iterator_glob_new =
      _git_config_iterator_glob_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>)>();

  /// Perform an operation on each config variable matching a regular expression.
  ///
  /// This behaves like `git_config_foreach` with an additional filter of a
  /// regular expression that filters which config keys are passed to the
  /// callback.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the case-insensitive parts are lower-case.
  ///
  /// @param cfg where to get the variables from
  /// @param regexp regular expression to match against config names
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 or the return value of the callback which didn't return 0
  int git_config_foreach_match(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> regexp,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_foreach_match(
      cfg,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_foreach_matchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_foreach_match');
  late final _git_config_foreach_match =
      _git_config_foreach_matchPtr.asFunction<
          int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              git_config_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Query the value of a config variable and return it mapped to
  /// an integer constant.
  ///
  /// This is a helper method to easily map different possible values
  /// to a variable to integer constants that easily identify them.
  ///
  /// A mapping array looks as follows:
  ///
  /// git_configmap autocrlf_mapping[] = {
  /// {GIT_CVAR_FALSE, NULL, GIT_AUTO_CRLF_FALSE},
  /// {GIT_CVAR_TRUE, NULL, GIT_AUTO_CRLF_TRUE},
  /// {GIT_CVAR_STRING, "input", GIT_AUTO_CRLF_INPUT},
  /// {GIT_CVAR_STRING, "default", GIT_AUTO_CRLF_DEFAULT}};
  ///
  /// On any "false" value for the variable (e.g. "false", "FALSE", "no"), the
  /// mapping will store `GIT_AUTO_CRLF_FALSE` in the `out` parameter.
  ///
  /// The same thing applies for any "true" value such as "true", "yes" or "1", storing
  /// the `GIT_AUTO_CRLF_TRUE` variable.
  ///
  /// Otherwise, if the value matches the string "input" (with case insensitive comparison),
  /// the given constant will be stored in `out`, and likewise for "default".
  ///
  /// If not a single match can be made to store in `out`, an error code will be
  /// returned.
  ///
  /// @param out place to store the result of the mapping
  /// @param cfg config file to get the variables from
  /// @param name name of the config variable to lookup
  /// @param maps array of `git_configmap` objects specifying the possible mappings
  /// @param map_n number of mapping objects in `maps`
  /// @return 0 on success, error code otherwise
  int git_config_get_mapped(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_configmap> maps,
    int map_n,
  ) {
    return _git_config_get_mapped(
      out,
      cfg,
      name,
      maps,
      map_n,
    );
  }

  late final _git_config_get_mappedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_configmap>,
              ffi.Size)>>('git_config_get_mapped');
  late final _git_config_get_mapped = _git_config_get_mappedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_configmap>, int)>();

  /// Maps a string value to an integer constant
  ///
  /// @param out place to store the result of the parsing
  /// @param maps array of `git_configmap` objects specifying the possible mappings
  /// @param map_n number of mapping objects in `maps`
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_lookup_map_value(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<git_configmap> maps,
    int map_n,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_lookup_map_value(
      out,
      maps,
      map_n,
      value,
    );
  }

  late final _git_config_lookup_map_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_configmap>,
              ffi.Size, ffi.Pointer<ffi.Char>)>>('git_config_lookup_map_value');
  late final _git_config_lookup_map_value =
      _git_config_lookup_map_valuePtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_configmap>, int,
              ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as a bool.
  ///
  /// Valid values for true are: 'true', 'yes', 'on', 1 or any
  /// number different from 0
  /// Valid values for false are: 'false', 'no', 'off', 0
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_parse_bool(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_bool(
      out,
      value,
    );
  }

  late final _git_config_parse_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_bool');
  late final _git_config_parse_bool = _git_config_parse_boolPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as an int32.
  ///
  /// An optional value suffix of 'k', 'm', or 'g' will
  /// cause the value to be multiplied by 1024, 1048576,
  /// or 1073741824 prior to output.
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_parse_int32(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_int32(
      out,
      value,
    );
  }

  late final _git_config_parse_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_int32');
  late final _git_config_parse_int32 = _git_config_parse_int32Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as an int64.
  ///
  /// An optional value suffix of 'k', 'm', or 'g' will
  /// cause the value to be multiplied by 1024, 1048576,
  /// or 1073741824 prior to output.
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_parse_int64(
    ffi.Pointer<ffi.Int64> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_int64(
      out,
      value,
    );
  }

  late final _git_config_parse_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_int64');
  late final _git_config_parse_int64 = _git_config_parse_int64Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as a path.
  ///
  /// A leading '~' will be expanded to the global search path (which
  /// defaults to the user's home directory but can be overridden via
  /// `git_libgit2_opts()`.
  ///
  /// If the value does not begin with a tilde, the input will be
  /// returned.
  ///
  /// @param out placae to store the result of parsing
  /// @param value the path to evaluate
  /// @return 0 or an error code.
  int git_config_parse_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_path(
      out,
      value,
    );
  }

  late final _git_config_parse_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_path');
  late final _git_config_parse_path = _git_config_parse_pathPtr
      .asFunction<int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>)>();

  /// Perform an operation on each config variable in a given config backend,
  /// matching a regular expression.
  ///
  /// This behaves like `git_config_foreach_match` except that only config
  /// entries from the given backend entry are enumerated.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param backend where to get the variables from
  /// @param regexp regular expression to match against config names (can be NULL)
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 or an error code.
  int git_config_backend_foreach_match(
    ffi.Pointer<git_config_backend> backend,
    ffi.Pointer<ffi.Char> regexp,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_backend_foreach_match(
      backend,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_backend_foreach_matchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config_backend>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_backend_foreach_match');
  late final _git_config_backend_foreach_match =
      _git_config_backend_foreach_matchPtr.asFunction<
          int Function(ffi.Pointer<git_config_backend>, ffi.Pointer<ffi.Char>,
              git_config_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Lock the backend with the highest priority
  ///
  /// Locking disallows anybody else from writing to that backend. Any
  /// updates made after locking will not be visible to a reader until
  /// the file is unlocked.
  ///
  /// You can apply the changes by calling `git_transaction_commit()`
  /// before freeing the transaction. Either of these actions will unlock
  /// the config.
  ///
  /// @param tx the resulting transaction, use this to commit or undo the
  /// changes
  /// @param cfg the configuration in which to lock
  /// @return 0 or an error code
  int git_config_lock(
    ffi.Pointer<ffi.Pointer<git_transaction>> tx,
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_lock(
      tx,
      cfg,
    );
  }

  late final _git_config_lockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
              ffi.Pointer<git_config>)>>('git_config_lock');
  late final _git_config_lock = _git_config_lockPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
          ffi.Pointer<git_config>)>();

  /// Initialize git_describe_options structure
  ///
  /// Initializes a `git_describe_options` with default values. Equivalent to creating
  /// an instance with GIT_DESCRIBE_OPTIONS_INIT.
  ///
  /// @param opts The `git_describe_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DESCRIBE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_describe_options_init(
    ffi.Pointer<git_describe_options> opts,
    int version,
  ) {
    return _git_describe_options_init(
      opts,
      version,
    );
  }

  late final _git_describe_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_describe_options>,
              ffi.UnsignedInt)>>('git_describe_options_init');
  late final _git_describe_options_init = _git_describe_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_describe_options>, int)>();

  /// Initialize git_describe_format_options structure
  ///
  /// Initializes a `git_describe_format_options` with default values. Equivalent to creating
  /// an instance with GIT_DESCRIBE_FORMAT_OPTIONS_INIT.
  ///
  /// @param opts The `git_describe_format_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DESCRIBE_FORMAT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_describe_format_options_init(
    ffi.Pointer<git_describe_format_options> opts,
    int version,
  ) {
    return _git_describe_format_options_init(
      opts,
      version,
    );
  }

  late final _git_describe_format_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_describe_format_options>,
              ffi.UnsignedInt)>>('git_describe_format_options_init');
  late final _git_describe_format_options_init =
      _git_describe_format_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_describe_format_options>, int)>();

  /// Describe a commit
  ///
  /// Perform the describe operation on the given committish object.
  ///
  /// @param result pointer to store the result. You must free this once
  /// you're done with it.
  /// @param committish a committish to describe
  /// @param opts the lookup options (or NULL for defaults)
  /// @return 0 or an error code.
  int git_describe_commit(
    ffi.Pointer<ffi.Pointer<git_describe_result>> result,
    ffi.Pointer<git_object> committish,
    ffi.Pointer<git_describe_options> opts,
  ) {
    return _git_describe_commit(
      result,
      committish,
      opts,
    );
  }

  late final _git_describe_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_describe_result>>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_describe_options>)>>('git_describe_commit');
  late final _git_describe_commit = _git_describe_commitPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_describe_result>>,
          ffi.Pointer<git_object>, ffi.Pointer<git_describe_options>)>();

  /// Describe a commit
  ///
  /// Perform the describe operation on the current commit and the
  /// worktree. After performing describe on HEAD, a status is run and the
  /// description is considered to be dirty if there are.
  ///
  /// @param out pointer to store the result. You must free this once
  /// you're done with it.
  /// @param repo the repository in which to perform the describe
  /// @param opts the lookup options (or NULL for defaults)
  /// @return 0 or an error code.
  int git_describe_workdir(
    ffi.Pointer<ffi.Pointer<git_describe_result>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_describe_options> opts,
  ) {
    return _git_describe_workdir(
      out,
      repo,
      opts,
    );
  }

  late final _git_describe_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_describe_result>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_describe_options>)>>('git_describe_workdir');
  late final _git_describe_workdir = _git_describe_workdirPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_describe_result>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_describe_options>)>();

  /// Print the describe result to a buffer
  ///
  /// @param out The buffer to store the result
  /// @param result the result from `git_describe_commit()` or
  /// `git_describe_workdir()`.
  /// @param opts the formatting options (or NULL for defaults)
  /// @return 0 or an error code.
  int git_describe_format(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_describe_result> result,
    ffi.Pointer<git_describe_format_options> opts,
  ) {
    return _git_describe_format(
      out,
      result,
      opts,
    );
  }

  late final _git_describe_formatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_buf>,
                  ffi.Pointer<git_describe_result>,
                  ffi.Pointer<git_describe_format_options>)>>(
      'git_describe_format');
  late final _git_describe_format = _git_describe_formatPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_describe_result>,
          ffi.Pointer<git_describe_format_options>)>();

  /// Free the describe result.
  ///
  /// @param result The result to free.
  void git_describe_result_free(
    ffi.Pointer<git_describe_result> result,
  ) {
    return _git_describe_result_free(
      result,
    );
  }

  late final _git_describe_result_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<git_describe_result>)>>(
      'git_describe_result_free');
  late final _git_describe_result_free = _git_describe_result_freePtr
      .asFunction<void Function(ffi.Pointer<git_describe_result>)>();

  /// Create a diff for a commit in mbox format for sending via email.
  /// The commit must not be a merge commit.
  ///
  /// @param out buffer to store the e-mail patch in
  /// @param commit commit to create a patch for
  /// @param opts email creation options
  /// @return 0 or an error code
  int git_email_create_from_commit(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_email_create_options> opts,
  ) {
    return _git_email_create_from_commit(
      out,
      commit,
      opts,
    );
  }

  late final _git_email_create_from_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
                  ffi.Pointer<git_email_create_options>)>>(
      'git_email_create_from_commit');
  late final _git_email_create_from_commit =
      _git_email_create_from_commitPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
              ffi.Pointer<git_email_create_options>)>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// This function will never return NULL.
  ///
  /// Callers should not rely on this to determine whether an error has
  /// occurred. For error checking, callers should examine the return
  /// codes of libgit2 functions.
  ///
  /// This call can only reliably report error messages when an error
  /// has occurred. (It may contain stale information if it is called
  /// after a different function that succeeds.)
  ///
  /// The memory for this object is managed by libgit2. It should not
  /// be freed.
  ///
  /// @return A pointer to a `git_error` object that describes the error.
  ffi.Pointer<git_error> git_error_last() {
    return _git_error_last();
  }

  late final _git_error_lastPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<git_error> Function()>>(
          'git_error_last');
  late final _git_error_last =
      _git_error_lastPtr.asFunction<ffi.Pointer<git_error> Function()>();

  /// Load the filter list for a given path.
  ///
  /// This will return 0 (success) but set the output git_filter_list to NULL
  /// if no filters are requested for the given file.
  ///
  /// @param filters Output newly created git_filter_list (or NULL)
  /// @param repo Repository object that contains `path`
  /// @param blob The blob to which the filter will be applied (if known)
  /// @param path Relative path of the file to be filtered
  /// @param mode Filtering direction (WT->ODB or ODB->WT)
  /// @param flags Combination of `git_filter_flag_t` flags
  /// @return 0 on success (which could still return NULL if no filters are
  /// needed for the requested file), <0 on error
  int git_filter_list_load(
    ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Char> path,
    git_filter_mode_t mode,
    int flags,
  ) {
    return _git_filter_list_load(
      filters,
      repo,
      blob,
      path,
      mode.value,
      flags,
    );
  }

  late final _git_filter_list_loadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_filter_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Uint32)>>('git_filter_list_load');
  late final _git_filter_list_load = _git_filter_list_loadPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_filter_list>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          int,
          int)>();

  /// Load the filter list for a given path.
  ///
  /// This will return 0 (success) but set the output git_filter_list to NULL
  /// if no filters are requested for the given file.
  ///
  /// @param filters Output newly created git_filter_list (or NULL)
  /// @param repo Repository object that contains `path`
  /// @param blob The blob to which the filter will be applied (if known)
  /// @param path Relative path of the file to be filtered
  /// @param mode Filtering direction (WT->ODB or ODB->WT)
  /// @param opts The `git_filter_options` to use when loading filters
  /// @return 0 on success (which could still return NULL if no filters are
  /// needed for the requested file), <0 on error
  int git_filter_list_load_ext(
    ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Char> path,
    git_filter_mode_t mode,
    ffi.Pointer<git_filter_options> opts,
  ) {
    return _git_filter_list_load_ext(
      filters,
      repo,
      blob,
      path,
      mode.value,
      opts,
    );
  }

  late final _git_filter_list_load_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_filter_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<git_filter_options>)>>('git_filter_list_load_ext');
  late final _git_filter_list_load_ext =
      _git_filter_list_load_extPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_filter_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<git_filter_options>)>();

  /// Query the filter list to see if a given filter (by name) will run.
  /// The built-in filters "crlf" and "ident" can be queried, otherwise this
  /// is the name of the filter specified by the filter attribute.
  ///
  /// This will return 0 if the given filter is not in the list, or 1 if
  /// the filter will be applied.
  ///
  /// @param filters A loaded git_filter_list (or NULL)
  /// @param name The name of the filter to query
  /// @return 1 if the filter is in the list, 0 otherwise
  int git_filter_list_contains(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_filter_list_contains(
      filters,
      name,
    );
  }

  late final _git_filter_list_containsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>)>>('git_filter_list_contains');
  late final _git_filter_list_contains =
      _git_filter_list_containsPtr.asFunction<
          int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<ffi.Char>)>();

  /// Apply filter list to a data buffer.
  ///
  /// @param out Buffer to store the result of the filtering
  /// @param filters A loaded git_filter_list (or NULL)
  /// @param in Buffer containing the data to filter
  /// @param in_len The length of the input buffer
  /// @return 0 on success, an error code otherwise
  int git_filter_list_apply_to_buffer(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<ffi.Char> in$,
    int in_len,
  ) {
    return _git_filter_list_apply_to_buffer(
      out,
      filters,
      in$,
      in_len,
    );
  }

  late final _git_filter_list_apply_to_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_filter_list_apply_to_buffer');
  late final _git_filter_list_apply_to_buffer =
      _git_filter_list_apply_to_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Apply a filter list to the contents of a file on disk
  ///
  /// @param out buffer into which to store the filtered file
  /// @param filters the list of filters to apply
  /// @param repo the repository in which to perform the filtering
  /// @param path the path of the file to filter, a relative path will be
  /// taken as relative to the workdir
  /// @return 0 or an error code.
  int git_filter_list_apply_to_file(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_filter_list_apply_to_file(
      out,
      filters,
      repo,
      path,
    );
  }

  late final _git_filter_list_apply_to_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_filter_list_apply_to_file');
  late final _git_filter_list_apply_to_file =
      _git_filter_list_apply_to_filePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Apply a filter list to the contents of a blob
  ///
  /// @param out buffer into which to store the filtered file
  /// @param filters the list of filters to apply
  /// @param blob the blob to filter
  /// @return 0 or an error code.
  int git_filter_list_apply_to_blob(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_filter_list_apply_to_blob(
      out,
      filters,
      blob,
    );
  }

  late final _git_filter_list_apply_to_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_blob>)>>('git_filter_list_apply_to_blob');
  late final _git_filter_list_apply_to_blob =
      _git_filter_list_apply_to_blobPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_blob>)>();

  /// Apply a filter list to an arbitrary buffer as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param buffer the buffer to filter
  /// @param len the size of the buffer
  /// @param target the stream into which the data will be written
  /// @return 0 or an error code.
  int git_filter_list_stream_buffer(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<ffi.Char> buffer,
    int len,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_buffer(
      filters,
      buffer,
      len,
      target,
    );
  }

  late final _git_filter_list_stream_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<git_writestream>)>>('git_filter_list_stream_buffer');
  late final _git_filter_list_stream_buffer =
      _git_filter_list_stream_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<git_writestream>)>();

  /// Apply a filter list to a file as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param repo the repository in which to perform the filtering
  /// @param path the path of the file to filter, a relative path will be
  /// taken as relative to the workdir
  /// @param target the stream into which the data will be written
  /// @return 0 or an error code.
  int git_filter_list_stream_file(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_file(
      filters,
      repo,
      path,
      target,
    );
  }

  late final _git_filter_list_stream_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_writestream>)>>('git_filter_list_stream_file');
  late final _git_filter_list_stream_file =
      _git_filter_list_stream_filePtr.asFunction<
          int Function(
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_writestream>)>();

  /// Apply a filter list to a blob as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param blob the blob to filter
  /// @param target the stream into which the data will be written
  /// @return 0 or an error code.
  int git_filter_list_stream_blob(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_blob(
      filters,
      blob,
      target,
    );
  }

  late final _git_filter_list_stream_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<git_blob>,
              ffi.Pointer<git_writestream>)>>('git_filter_list_stream_blob');
  late final _git_filter_list_stream_blob =
      _git_filter_list_stream_blobPtr.asFunction<
          int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<git_blob>,
              ffi.Pointer<git_writestream>)>();

  /// Free a git_filter_list
  ///
  /// @param filters A git_filter_list created by `git_filter_list_load`
  void git_filter_list_free(
    ffi.Pointer<git_filter_list> filters,
  ) {
    return _git_filter_list_free(
      filters,
    );
  }

  late final _git_filter_list_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_filter_list>)>>(
      'git_filter_list_free');
  late final _git_filter_list_free = _git_filter_list_freePtr
      .asFunction<void Function(ffi.Pointer<git_filter_list>)>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int git_libgit2_init() {
    return _git_libgit2_init();
  }

  late final _git_libgit2_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('git_libgit2_init');
  late final _git_libgit2_init =
      _git_libgit2_initPtr.asFunction<int Function()>();

  /// Shutdown the global state
  ///
  /// Clean up the global state and threading context after calling it as
  /// many times as `git_libgit2_init()` was called - it will return the
  /// number of remainining initializations that have not been shutdown
  /// (after this one).
  ///
  /// @return the number of remaining initializations of the library, or an
  /// error code.
  int git_libgit2_shutdown() {
    return _git_libgit2_shutdown();
  }

  late final _git_libgit2_shutdownPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('git_libgit2_shutdown');
  late final _git_libgit2_shutdown =
      _git_libgit2_shutdownPtr.asFunction<int Function()>();

  /// Count the number of unique commits between two commit objects
  ///
  /// There is no need for branches containing the commits to have any
  /// upstream relationship, but it helps to think of one as a branch and
  /// the other as its upstream, the `ahead` and `behind` values will be
  /// what git would report for the branches.
  ///
  /// @param ahead number of unique from commits in `upstream`
  /// @param behind number of unique from commits in `local`
  /// @param repo the repository where the commits exist
  /// @param local the commit for local
  /// @param upstream the commit for upstream
  /// @return 0 or an error code.
  int git_graph_ahead_behind(
    ffi.Pointer<ffi.Size> ahead,
    ffi.Pointer<ffi.Size> behind,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> local,
    ffi.Pointer<git_oid> upstream,
  ) {
    return _git_graph_ahead_behind(
      ahead,
      behind,
      repo,
      local,
      upstream,
    );
  }

  late final _git_graph_ahead_behindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_graph_ahead_behind');
  late final _git_graph_ahead_behind = _git_graph_ahead_behindPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_oid>)>();

  /// Determine if a commit is the descendant of another commit.
  ///
  /// Note that a commit is not considered a descendant of itself, in contrast
  /// to `git merge-base --is-ancestor`.
  ///
  /// @param repo the repository where the commits exist
  /// @param commit a previously loaded commit
  /// @param ancestor a potential ancestor commit
  /// @return 1 if the given commit is a descendant of the potential ancestor,
  /// 0 if not, error code otherwise.
  int git_graph_descendant_of(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit,
    ffi.Pointer<git_oid> ancestor,
  ) {
    return _git_graph_descendant_of(
      repo,
      commit,
      ancestor,
    );
  }

  late final _git_graph_descendant_ofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_graph_descendant_of');
  late final _git_graph_descendant_of = _git_graph_descendant_ofPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
          ffi.Pointer<git_oid>)>();

  /// Determine if a commit is reachable from any of a list of commits by
  /// following parent edges.
  ///
  /// @param repo the repository where the commits exist
  /// @param commit a previously loaded commit
  /// @param descendant_array oids of the commits
  /// @param length the number of commits in the provided `descendant_array`
  /// @return 1 if the given commit is an ancestor of any of the given potential
  /// descendants, 0 if not, error code otherwise.
  int git_graph_reachable_from_any(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit,
    ffi.Pointer<git_oid> descendant_array,
    int length,
  ) {
    return _git_graph_reachable_from_any(
      repo,
      commit,
      descendant_array,
      length,
    );
  }

  late final _git_graph_reachable_from_anyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>, ffi.Size)>>('git_graph_reachable_from_any');
  late final _git_graph_reachable_from_any =
      _git_graph_reachable_from_anyPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>, int)>();

  /// Add ignore rules for a repository.
  ///
  /// Excludesfile rules (i.e. .gitignore rules) are generally read from
  /// .gitignore files in the repository tree or from a shared system file
  /// only if a "core.excludesfile" config value is set.  The library also
  /// keeps a set of per-repository internal ignores that can be configured
  /// in-memory and will not persist.  This function allows you to add to
  /// that internal rules list.
  ///
  /// Example usage:
  ///
  /// error = git_ignore_add_rule(myrepo, "*.c\ndir/\nFile with space\n");
  ///
  /// This would add three rules to the ignores.
  ///
  /// @param repo The repository to add ignore rules to.
  /// @param rules Text of rules, the contents to add on a .gitignore file.
  /// It is okay to have multiple rules in the text; if so,
  /// each rule should be terminated with a newline.
  /// @return 0 on success
  int git_ignore_add_rule(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> rules,
  ) {
    return _git_ignore_add_rule(
      repo,
      rules,
    );
  }

  late final _git_ignore_add_rulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_ignore_add_rule');
  late final _git_ignore_add_rule = _git_ignore_add_rulePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Clear ignore rules that were explicitly added.
  ///
  /// Resets to the default internal ignore rules.  This will not turn off
  /// rules in .gitignore files that actually exist in the filesystem.
  ///
  /// The default internal ignores ignore ".", ".." and ".git" entries.
  ///
  /// @param repo The repository to remove ignore rules from.
  /// @return 0 on success
  int git_ignore_clear_internal_rules(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_ignore_clear_internal_rules(
      repo,
    );
  }

  late final _git_ignore_clear_internal_rulesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_ignore_clear_internal_rules');
  late final _git_ignore_clear_internal_rules =
      _git_ignore_clear_internal_rulesPtr
          .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Test if the ignore rules apply to a given path.
  ///
  /// This function checks the ignore rules to see if they would apply to the
  /// given file.  This indicates if the file would be ignored regardless of
  /// whether the file is already in the index or committed to the repository.
  ///
  /// One way to think of this is if you were to do "git check-ignore --no-index"
  /// on the given file, would it be shown or not?
  ///
  /// @param ignored boolean returning 0 if the file is not ignored, 1 if it is
  /// @param repo a repository object
  /// @param path the file to check ignores for, relative to the repo's workdir.
  /// @return 0 if ignore rules could be processed for the file (regardless
  /// of whether it exists or not), or an error < 0 if they could not.
  int git_ignore_path_is_ignored(
    ffi.Pointer<ffi.Int> ignored,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_ignore_path_is_ignored(
      ignored,
      repo,
      path,
    );
  }

  late final _git_ignore_path_is_ignoredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_ignore_path_is_ignored');
  late final _git_ignore_path_is_ignored =
      _git_ignore_path_is_ignoredPtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Allocate a new mailmap object.
  ///
  /// This object is empty, so you'll have to add a mailmap file before you can do
  /// anything with it. The mailmap must be freed with 'git_mailmap_free'.
  ///
  /// @param out pointer to store the new mailmap
  /// @return 0 on success, or an error code
  int git_mailmap_new(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
  ) {
    return _git_mailmap_new(
      out,
    );
  }

  late final _git_mailmap_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_mailmap>>)>>('git_mailmap_new');
  late final _git_mailmap_new = _git_mailmap_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>)>();

  /// Free the mailmap and its associated memory.
  ///
  /// @param mm the mailmap to free
  void git_mailmap_free(
    ffi.Pointer<git_mailmap> mm,
  ) {
    return _git_mailmap_free(
      mm,
    );
  }

  late final _git_mailmap_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_mailmap>)>>(
          'git_mailmap_free');
  late final _git_mailmap_free = _git_mailmap_freePtr
      .asFunction<void Function(ffi.Pointer<git_mailmap>)>();

  /// Add a single entry to the given mailmap object. If the entry already exists,
  /// it will be replaced with the new entry.
  ///
  /// @param mm mailmap to add the entry to
  /// @param real_name the real name to use, or NULL
  /// @param real_email the real email to use, or NULL
  /// @param replace_name the name to replace, or NULL
  /// @param replace_email the email to replace
  /// @return 0 on success, or an error code
  int git_mailmap_add_entry(
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<ffi.Char> real_name,
    ffi.Pointer<ffi.Char> real_email,
    ffi.Pointer<ffi.Char> replace_name,
    ffi.Pointer<ffi.Char> replace_email,
  ) {
    return _git_mailmap_add_entry(
      mm,
      real_name,
      real_email,
      replace_name,
      replace_email,
    );
  }

  late final _git_mailmap_add_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_mailmap>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_mailmap_add_entry');
  late final _git_mailmap_add_entry = _git_mailmap_add_entryPtr.asFunction<
      int Function(
          ffi.Pointer<git_mailmap>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Create a new mailmap instance containing a single mailmap file
  ///
  /// @param out pointer to store the new mailmap
  /// @param buf buffer to parse the mailmap from
  /// @param len the length of the input buffer
  /// @return 0 on success, or an error code
  int git_mailmap_from_buffer(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _git_mailmap_from_buffer(
      out,
      buf,
      len,
    );
  }

  late final _git_mailmap_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('git_mailmap_from_buffer');
  late final _git_mailmap_from_buffer = _git_mailmap_from_bufferPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_mailmap>>, ffi.Pointer<ffi.Char>, int)>();

  /// Create a new mailmap instance from a repository, loading mailmap files based
  /// on the repository's configuration.
  ///
  /// Mailmaps are loaded in the following order:
  /// 1. '.mailmap' in the root of the repository's working directory, if present.
  /// 2. The blob object identified by the 'mailmap.blob' config entry, if set.
  /// [NOTE: 'mailmap.blob' defaults to 'HEAD:.mailmap' in bare repositories]
  /// 3. The path in the 'mailmap.file' config entry, if set.
  ///
  /// @param out pointer to store the new mailmap
  /// @param repo repository to load mailmap information from
  /// @return 0 on success, or an error code
  int git_mailmap_from_repository(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_mailmap_from_repository(
      out,
      repo,
    );
  }

  late final _git_mailmap_from_repositoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>,
              ffi.Pointer<git_repository>)>>('git_mailmap_from_repository');
  late final _git_mailmap_from_repository =
      _git_mailmap_from_repositoryPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>,
              ffi.Pointer<git_repository>)>();

  /// Resolve a name and email to the corresponding real name and email.
  ///
  /// The lifetime of the strings are tied to `mm`, `name`, and `email` parameters.
  ///
  /// @param real_name pointer to store the real name
  /// @param real_email pointer to store the real email
  /// @param mm the mailmap to perform a lookup with (may be NULL)
  /// @param name the name to look up
  /// @param email the email to look up
  /// @return 0 on success, or an error code
  int git_mailmap_resolve(
    ffi.Pointer<ffi.Pointer<ffi.Char>> real_name,
    ffi.Pointer<ffi.Pointer<ffi.Char>> real_email,
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
  ) {
    return _git_mailmap_resolve(
      real_name,
      real_email,
      mm,
      name,
      email,
    );
  }

  late final _git_mailmap_resolvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_mailmap>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_mailmap_resolve');
  late final _git_mailmap_resolve = _git_mailmap_resolvePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_mailmap>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Resolve a signature to use real names and emails with a mailmap.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature
  /// @param mm mailmap to resolve with
  /// @param sig signature to resolve
  /// @return 0 or an error code
  int git_mailmap_resolve_signature(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_mailmap_resolve_signature(
      out,
      mm,
      sig,
    );
  }

  late final _git_mailmap_resolve_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_mailmap>,
              ffi.Pointer<git_signature>)>>('git_mailmap_resolve_signature');
  late final _git_mailmap_resolve_signature =
      _git_mailmap_resolve_signaturePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_mailmap>, ffi.Pointer<git_signature>)>();

  /// Clean up excess whitespace and make sure there is a trailing newline in the message.
  ///
  /// Optionally, it can remove lines which start with the comment character.
  ///
  /// @param out The user-allocated git_buf which will be filled with the
  /// cleaned up message.
  ///
  /// @param message The message to be prettified.
  ///
  /// @param strip_comments Non-zero to remove comment lines, 0 to leave them in.
  ///
  /// @param comment_char Comment character. Lines starting with this character
  /// are considered to be comments and removed if `strip_comments` is non-zero.
  ///
  /// @return 0 or an error code.
  int git_message_prettify(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Char> message,
    int strip_comments,
    int comment_char,
  ) {
    return _git_message_prettify(
      out,
      message,
      strip_comments,
      comment_char,
    );
  }

  late final _git_message_prettifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Char)>>('git_message_prettify');
  late final _git_message_prettify = _git_message_prettifyPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Parse trailers out of a message, filling the array pointed to by +arr+.
  ///
  /// Trailers are key/value pairs in the last paragraph of a message, not
  /// including any patches or conflicts that may be present.
  ///
  /// @param arr A pre-allocated git_message_trailer_array struct to be filled in
  /// with any trailers found during parsing.
  /// @param message The message to be parsed
  /// @return 0 on success, or non-zero on error.
  int git_message_trailers(
    ffi.Pointer<git_message_trailer_array> arr,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _git_message_trailers(
      arr,
      message,
    );
  }

  late final _git_message_trailersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_message_trailer_array>,
              ffi.Pointer<ffi.Char>)>>('git_message_trailers');
  late final _git_message_trailers = _git_message_trailersPtr.asFunction<
      int Function(
          ffi.Pointer<git_message_trailer_array>, ffi.Pointer<ffi.Char>)>();

  /// Clean's up any allocated memory in the git_message_trailer_array filled by
  /// a call to git_message_trailers.
  ///
  /// @param arr The trailer to free.
  void git_message_trailer_array_free(
    ffi.Pointer<git_message_trailer_array> arr,
  ) {
    return _git_message_trailer_array_free(
      arr,
    );
  }

  late final _git_message_trailer_array_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_message_trailer_array>)>>(
      'git_message_trailer_array_free');
  late final _git_message_trailer_array_free =
      _git_message_trailer_array_freePtr
          .asFunction<void Function(ffi.Pointer<git_message_trailer_array>)>();

  /// Creates a new iterator for notes
  ///
  /// The iterator must be freed manually by the user.
  ///
  /// @param out pointer to the iterator
  /// @param repo repository where to look up the note
  /// @param notes_ref canonical name of the reference to use (optional); defaults to
  /// "refs/notes/commits"
  ///
  /// @return 0 or an error code
  int git_note_iterator_new(
    ffi.Pointer<ffi.Pointer<git_note_iterator>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
  ) {
    return _git_note_iterator_new(
      out,
      repo,
      notes_ref,
    );
  }

  late final _git_note_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_note_iterator>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_note_iterator_new');
  late final _git_note_iterator_new = _git_note_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_note_iterator>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Creates a new iterator for notes from a commit
  ///
  /// The iterator must be freed manually by the user.
  ///
  /// @param out pointer to the iterator
  /// @param notes_commit a pointer to the notes commit object
  ///
  /// @return 0 or an error code
  int git_note_commit_iterator_new(
    ffi.Pointer<ffi.Pointer<git_note_iterator>> out,
    ffi.Pointer<git_commit> notes_commit,
  ) {
    return _git_note_commit_iterator_new(
      out,
      notes_commit,
    );
  }

  late final _git_note_commit_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_note_iterator>>,
              ffi.Pointer<git_commit>)>>('git_note_commit_iterator_new');
  late final _git_note_commit_iterator_new =
      _git_note_commit_iterator_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_note_iterator>>,
              ffi.Pointer<git_commit>)>();

  /// Frees an git_note_iterator
  ///
  /// @param it pointer to the iterator
  void git_note_iterator_free(
    ffi.Pointer<git_note_iterator> it,
  ) {
    return _git_note_iterator_free(
      it,
    );
  }

  late final _git_note_iterator_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<git_note_iterator>)>>(
      'git_note_iterator_free');
  late final _git_note_iterator_free = _git_note_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_note_iterator>)>();

  /// Return the current item (note_id and annotated_id) and advance the iterator
  /// internally to the next value
  ///
  /// @param note_id id of blob containing the message
  /// @param annotated_id id of the git object being annotated
  /// @param it pointer to the iterator
  ///
  /// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
  /// (negative value)
  int git_note_next(
    ffi.Pointer<git_oid> note_id,
    ffi.Pointer<git_oid> annotated_id,
    ffi.Pointer<git_note_iterator> it,
  ) {
    return _git_note_next(
      note_id,
      annotated_id,
      it,
    );
  }

  late final _git_note_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_note_iterator>)>>('git_note_next');
  late final _git_note_next = _git_note_nextPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>,
          ffi.Pointer<git_note_iterator>)>();

  /// Read the note for an object
  ///
  /// The note must be freed manually by the user.
  ///
  /// @param out pointer to the read note; NULL in case of error
  /// @param repo repository where to look up the note
  /// @param notes_ref canonical name of the reference to use (optional); defaults to
  /// "refs/notes/commits"
  /// @param oid OID of the git object to read the note from
  ///
  /// @return 0 or an error code
  int git_note_read(
    ffi.Pointer<ffi.Pointer<git_note>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_read(
      out,
      repo,
      notes_ref,
      oid,
    );
  }

  late final _git_note_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_note>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>)>>('git_note_read');
  late final _git_note_read = _git_note_readPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_note>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_oid>)>();

  /// Read the note for an object from a note commit
  ///
  /// The note must be freed manually by the user.
  ///
  /// @param out pointer to the read note; NULL in case of error
  /// @param repo repository where to look up the note
  /// @param notes_commit a pointer to the notes commit object
  /// @param oid OID of the git object to read the note from
  ///
  /// @return 0 or an error code
  int git_note_commit_read(
    ffi.Pointer<ffi.Pointer<git_note>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> notes_commit,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_commit_read(
      out,
      repo,
      notes_commit,
      oid,
    );
  }

  late final _git_note_commit_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_note>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_oid>)>>('git_note_commit_read');
  late final _git_note_commit_read = _git_note_commit_readPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_note>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_oid>)>();

  /// Get the note author
  ///
  /// @param note the note
  /// @return the author
  ffi.Pointer<git_signature> git_note_author(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_author(
      note,
    );
  }

  late final _git_note_authorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_note>)>>('git_note_author');
  late final _git_note_author = _git_note_authorPtr
      .asFunction<ffi.Pointer<git_signature> Function(ffi.Pointer<git_note>)>();

  /// Get the note committer
  ///
  /// @param note the note
  /// @return the committer
  ffi.Pointer<git_signature> git_note_committer(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_committer(
      note,
    );
  }

  late final _git_note_committerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_note>)>>('git_note_committer');
  late final _git_note_committer = _git_note_committerPtr
      .asFunction<ffi.Pointer<git_signature> Function(ffi.Pointer<git_note>)>();

  /// Get the note message
  ///
  /// @param note the note
  /// @return the note message
  ffi.Pointer<ffi.Char> git_note_message(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_message(
      note,
    );
  }

  late final _git_note_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_note>)>>('git_note_message');
  late final _git_note_message = _git_note_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_note>)>();

  /// Get the note object's id
  ///
  /// @param note the note
  /// @return the note object's id
  ffi.Pointer<git_oid> git_note_id(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_id(
      note,
    );
  }

  late final _git_note_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_note>)>>('git_note_id');
  late final _git_note_id = _git_note_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_note>)>();

  /// Add a note for an object
  ///
  /// @param out pointer to store the OID (optional); NULL in case of error
  /// @param repo repository where to store the note
  /// @param notes_ref canonical name of the reference to use (optional);
  /// defaults to "refs/notes/commits"
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to decorate
  /// @param note Content of the note to add for object oid
  /// @param force Overwrite existing note
  ///
  /// @return 0 or an error code
  int git_note_create(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Char> note,
    int force,
  ) {
    return _git_note_create(
      out,
      repo,
      notes_ref,
      author,
      committer,
      oid,
      note,
      force,
    );
  }

  late final _git_note_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_note_create');
  late final _git_note_create = _git_note_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Add a note for an object from a commit
  ///
  /// This function will create a notes commit for a given object,
  /// the commit is a dangling commit, no reference is created.
  ///
  /// @param notes_commit_out pointer to store the commit (optional);
  /// NULL in case of error
  /// @param notes_blob_out a point to the id of a note blob (optional)
  /// @param repo repository where the note will live
  /// @param parent Pointer to parent note
  /// or NULL if this shall start a new notes tree
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to decorate
  /// @param note Content of the note to add for object oid
  /// @param allow_note_overwrite Overwrite existing note
  ///
  /// @return 0 or an error code
  int git_note_commit_create(
    ffi.Pointer<git_oid> notes_commit_out,
    ffi.Pointer<git_oid> notes_blob_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> parent,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Char> note,
    int allow_note_overwrite,
  ) {
    return _git_note_commit_create(
      notes_commit_out,
      notes_blob_out,
      repo,
      parent,
      author,
      committer,
      oid,
      note,
      allow_note_overwrite,
    );
  }

  late final _git_note_commit_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_note_commit_create');
  late final _git_note_commit_create = _git_note_commit_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Remove the note for an object
  ///
  /// @param repo repository where the note lives
  /// @param notes_ref canonical name of the reference to use (optional);
  /// defaults to "refs/notes/commits"
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to remove the note from
  ///
  /// @return 0 or an error code
  int git_note_remove(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_remove(
      repo,
      notes_ref,
      author,
      committer,
      oid,
    );
  }

  late final _git_note_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>)>>('git_note_remove');
  late final _git_note_remove = _git_note_removePtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>)>();

  /// Remove the note for an object
  ///
  /// @param notes_commit_out pointer to store the new notes commit (optional);
  /// NULL in case of error.
  /// When removing a note a new tree containing all notes
  /// sans the note to be removed is created and a new commit
  /// pointing to that tree is also created.
  /// In the case where the resulting tree is an empty tree
  /// a new commit pointing to this empty tree will be returned.
  /// @param repo repository where the note lives
  /// @param notes_commit a pointer to the notes commit object
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to remove the note from
  ///
  /// @return 0 or an error code
  int git_note_commit_remove(
    ffi.Pointer<git_oid> notes_commit_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> notes_commit,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_commit_remove(
      notes_commit_out,
      repo,
      notes_commit,
      author,
      committer,
      oid,
    );
  }

  late final _git_note_commit_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>)>>('git_note_commit_remove');
  late final _git_note_commit_remove = _git_note_commit_removePtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>)>();

  /// Free a git_note object
  ///
  /// @param note git_note object
  void git_note_free(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_free(
      note,
    );
  }

  late final _git_note_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_note>)>>(
          'git_note_free');
  late final _git_note_free =
      _git_note_freePtr.asFunction<void Function(ffi.Pointer<git_note>)>();

  /// Get the default notes reference for a repository
  ///
  /// @param out buffer in which to store the name of the default notes reference
  /// @param repo The Git repository
  ///
  /// @return 0 or an error code
  int git_note_default_ref(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_note_default_ref(
      out,
      repo,
    );
  }

  late final _git_note_default_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>)>>('git_note_default_ref');
  late final _git_note_default_ref = _git_note_default_refPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>)>();

  /// Loop over all the notes within a specified namespace
  /// and issue a callback for each one.
  ///
  /// @param repo Repository where to find the notes.
  ///
  /// @param notes_ref Reference to read from (optional); defaults to
  /// "refs/notes/commits".
  ///
  /// @param note_cb Callback to invoke per found annotation.  Return non-zero
  /// to stop looping.
  ///
  /// @param payload Extra parameter to callback function.
  ///
  /// @return 0 on success, non-zero callback return value, or error code
  int git_note_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    git_note_foreach_cb note_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_note_foreach(
      repo,
      notes_ref,
      note_cb,
      payload,
    );
  }

  late final _git_note_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              git_note_foreach_cb, ffi.Pointer<ffi.Void>)>>('git_note_foreach');
  late final _git_note_foreach = _git_note_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          git_note_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Create a backend for a directory containing packfiles.
  ///
  /// @param[out] out location to store the odb backend pointer
  /// @param objects_dir the Git repository's objects directory
  /// @param opts the options to use when creating the pack backend
  /// @return 0 or an error code
  int git_odb_backend_pack(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Char> objects_dir,
    ffi.Pointer<git_odb_backend_pack_options> opts,
  ) {
    return _git_odb_backend_pack(
      out,
      objects_dir,
      opts,
    );
  }

  late final _git_odb_backend_packPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_odb_backend>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_odb_backend_pack_options>)>>(
      'git_odb_backend_pack');
  late final _git_odb_backend_pack = _git_odb_backend_packPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_odb_backend_pack_options>)>();

  /// Create a backend for a single packfile.
  ///
  /// @param[out] out location to store the odb backend pointer
  /// @param index_file path to the packfile's .idx file
  /// @param opts the options to use when creating the pack backend
  /// @return 0 or an error code
  int git_odb_backend_one_pack(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Char> index_file,
    ffi.Pointer<git_odb_backend_pack_options> opts,
  ) {
    return _git_odb_backend_one_pack(
      out,
      index_file,
      opts,
    );
  }

  late final _git_odb_backend_one_packPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_odb_backend>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_odb_backend_pack_options>)>>(
      'git_odb_backend_one_pack');
  late final _git_odb_backend_one_pack =
      _git_odb_backend_one_packPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_odb_backend>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_odb_backend_pack_options>)>();

  /// Create a backend for loose objects
  ///
  /// @param[out] out location to store the odb backend pointer
  /// @param objects_dir the Git repository's objects directory
  /// @param opts options for the loose object backend or NULL
  ///
  /// @return 0 or an error code
  int git_odb_backend_loose(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Char> objects_dir,
    ffi.Pointer<git_odb_backend_loose_options> opts,
  ) {
    return _git_odb_backend_loose(
      out,
      objects_dir,
      opts,
    );
  }

  late final _git_odb_backend_loosePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_odb_backend>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_odb_backend_loose_options>)>>(
      'git_odb_backend_loose');
  late final _git_odb_backend_loose = _git_odb_backend_loosePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_odb_backend_loose_options>)>();

  /// Get the repository associated with this patch. May be NULL.
  ///
  /// @param patch the patch
  /// @return a pointer to the repository
  ffi.Pointer<git_repository> git_patch_owner(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_owner(
      patch,
    );
  }

  late final _git_patch_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_patch>)>>('git_patch_owner');
  late final _git_patch_owner = _git_patch_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_patch>)>();

  /// Return a patch for an entry in the diff list.
  ///
  /// The `git_patch` is a newly created object contains the text diffs
  /// for the delta.  You have to call `git_patch_free()` when you are
  /// done with it.  You can use the patch object to loop over all the hunks
  /// and lines in the diff of the one delta.
  ///
  /// For an unchanged file or a binary file, no `git_patch` will be
  /// created, the output will be set to NULL, and the `binary` flag will be
  /// set true in the `git_diff_delta` structure.
  ///
  /// It is okay to pass NULL for either of the output parameters; if you pass
  /// NULL for the `git_patch`, then the text diff will not be calculated.
  ///
  /// @param out Output parameter for the delta patch object
  /// @param diff Diff list object
  /// @param idx Index into diff list
  /// @return 0 on success, other value < 0 on error
  int git_patch_from_diff(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_diff> diff,
    int idx,
  ) {
    return _git_patch_from_diff(
      out,
      diff,
      idx,
    );
  }

  late final _git_patch_from_diffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<git_diff>, ffi.Size)>>('git_patch_from_diff');
  late final _git_patch_from_diff = _git_patch_from_diffPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_patch>>, ffi.Pointer<git_diff>, int)>();

  /// Directly generate a patch from the difference between two blobs.
  ///
  /// This is just like `git_diff_blobs()` except it generates a patch object
  /// for the difference instead of directly making callbacks.  You can use the
  /// standard `git_patch` accessor functions to read the patch data, and
  /// you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param new_blob Blob for new side of diff, or NULL for empty blob
  /// @param new_as_path Treat new blob as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_blobs(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<git_blob> new_blob,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_blobs(
      out,
      old_blob,
      old_as_path,
      new_blob,
      new_as_path,
      opts,
    );
  }

  late final _git_patch_from_blobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>)>>('git_patch_from_blobs');
  late final _git_patch_from_blobs = _git_patch_from_blobsPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_patch>>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>)>();

  /// Directly generate a patch from the difference between a blob and a buffer.
  ///
  /// This is just like `git_diff_blob_to_buffer()` except it generates a patch
  /// object for the difference instead of directly making callbacks.  You can
  /// use the standard `git_patch` accessor functions to read the patch
  /// data, and you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param buffer Raw data for new side of diff, or NULL for empty
  /// @param buffer_len Length of raw data for new side of diff
  /// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_blob_and_buffer(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_len,
    ffi.Pointer<ffi.Char> buffer_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_blob_and_buffer(
      out,
      old_blob,
      old_as_path,
      buffer,
      buffer_len,
      buffer_as_path,
      opts,
    );
  }

  late final _git_patch_from_blob_and_bufferPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_patch>>,
                  ffi.Pointer<git_blob>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_diff_options>)>>(
      'git_patch_from_blob_and_buffer');
  late final _git_patch_from_blob_and_buffer =
      _git_patch_from_blob_and_bufferPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>)>();

  /// Directly generate a patch from the difference between two buffers.
  ///
  /// This is just like `git_diff_buffers()` except it generates a patch
  /// object for the difference instead of directly making callbacks.  You can
  /// use the standard `git_patch` accessor functions to read the patch
  /// data, and you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_buffer Raw data for old side of diff, or NULL for empty
  /// @param old_len Length of the raw data for old side of the diff
  /// @param old_as_path Treat old buffer as if it had this filename; can be NULL
  /// @param new_buffer Raw data for new side of diff, or NULL for empty
  /// @param new_len Length of raw data for new side of diff
  /// @param new_as_path Treat buffer as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_buffers(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<ffi.Void> old_buffer,
    int old_len,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Void> new_buffer,
    int new_len,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_buffers(
      out,
      old_buffer,
      old_len,
      old_as_path,
      new_buffer,
      new_len,
      new_as_path,
      opts,
    );
  }

  late final _git_patch_from_buffersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>)>>('git_patch_from_buffers');
  late final _git_patch_from_buffers = _git_patch_from_buffersPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_patch>>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>)>();

  /// Free a git_patch object.
  ///
  /// @param patch The patch to free.
  void git_patch_free(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_free(
      patch,
    );
  }

  late final _git_patch_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_patch>)>>(
          'git_patch_free');
  late final _git_patch_free =
      _git_patch_freePtr.asFunction<void Function(ffi.Pointer<git_patch>)>();

  /// Get the delta associated with a patch.  This delta points to internal
  /// data and you do not have to release it when you are done with it.
  ///
  /// @param patch The patch in which to get the delta.
  /// @return The delta associated with the patch.
  ffi.Pointer<git_diff_delta> git_patch_get_delta(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_get_delta(
      patch,
    );
  }

  late final _git_patch_get_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_patch>)>>('git_patch_get_delta');
  late final _git_patch_get_delta = _git_patch_get_deltaPtr.asFunction<
      ffi.Pointer<git_diff_delta> Function(ffi.Pointer<git_patch>)>();

  /// Get the number of hunks in a patch
  ///
  /// @param patch The patch in which to get the number of hunks.
  /// @return The number of hunks of the patch.
  int git_patch_num_hunks(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_num_hunks(
      patch,
    );
  }

  late final _git_patch_num_hunksPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_patch>)>>(
          'git_patch_num_hunks');
  late final _git_patch_num_hunks = _git_patch_num_hunksPtr
      .asFunction<int Function(ffi.Pointer<git_patch>)>();

  /// Get line counts of each type in a patch.
  ///
  /// This helps imitate a diff --numstat type of output.  For that purpose,
  /// you only need the `total_additions` and `total_deletions` values, but we
  /// include the `total_context` line count in case you want the total number
  /// of lines of diff output that will be generated.
  ///
  /// All outputs are optional. Pass NULL if you don't need a particular count.
  ///
  /// @param total_context Count of context lines in output, can be NULL.
  /// @param total_additions Count of addition lines in output, can be NULL.
  /// @param total_deletions Count of deletion lines in output, can be NULL.
  /// @param patch The git_patch object
  /// @return 0 on success, <0 on error
  int git_patch_line_stats(
    ffi.Pointer<ffi.Size> total_context,
    ffi.Pointer<ffi.Size> total_additions,
    ffi.Pointer<ffi.Size> total_deletions,
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_line_stats(
      total_context,
      total_additions,
      total_deletions,
      patch,
    );
  }

  late final _git_patch_line_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_patch>)>>('git_patch_line_stats');
  late final _git_patch_line_stats = _git_patch_line_statsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<git_patch>)>();

  /// Get the information about a hunk in a patch
  ///
  /// Given a patch and a hunk index into the patch, this returns detailed
  /// information about that hunk.  Any of the output pointers can be passed
  /// as NULL if you don't care about that particular piece of information.
  ///
  /// @param out Output pointer to git_diff_hunk of hunk
  /// @param lines_in_hunk Output count of total lines in this hunk
  /// @param patch Input pointer to patch object
  /// @param hunk_idx Input index of hunk to get information about
  /// @return 0 on success, GIT_ENOTFOUND if hunk_idx out of range, <0 on error
  int git_patch_get_hunk(
    ffi.Pointer<ffi.Pointer<git_diff_hunk>> out,
    ffi.Pointer<ffi.Size> lines_in_hunk,
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
  ) {
    return _git_patch_get_hunk(
      out,
      lines_in_hunk,
      patch,
      hunk_idx,
    );
  }

  late final _git_patch_get_hunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff_hunk>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_patch>,
              ffi.Size)>>('git_patch_get_hunk');
  late final _git_patch_get_hunk = _git_patch_get_hunkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_diff_hunk>>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<git_patch>, int)>();

  /// Get the number of lines in a hunk.
  ///
  /// @param patch The git_patch object
  /// @param hunk_idx Index of the hunk
  /// @return Number of lines in hunk or GIT_ENOTFOUND if invalid hunk index
  int git_patch_num_lines_in_hunk(
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
  ) {
    return _git_patch_num_lines_in_hunk(
      patch,
      hunk_idx,
    );
  }

  late final _git_patch_num_lines_in_hunkPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<git_patch>, ffi.Size)>>(
      'git_patch_num_lines_in_hunk');
  late final _git_patch_num_lines_in_hunk = _git_patch_num_lines_in_hunkPtr
      .asFunction<int Function(ffi.Pointer<git_patch>, int)>();

  /// Get data about a line in a hunk of a patch.
  ///
  /// Given a patch, a hunk index, and a line index in the hunk, this
  /// will return a lot of details about that line.  If you pass a hunk
  /// index larger than the number of hunks or a line index larger than
  /// the number of lines in the hunk, this will return -1.
  ///
  /// @param out The git_diff_line data for this line
  /// @param patch The patch to look in
  /// @param hunk_idx The index of the hunk
  /// @param line_of_hunk The index of the line in the hunk
  /// @return 0 on success, <0 on failure
  int git_patch_get_line_in_hunk(
    ffi.Pointer<ffi.Pointer<git_diff_line>> out,
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
    int line_of_hunk,
  ) {
    return _git_patch_get_line_in_hunk(
      out,
      patch,
      hunk_idx,
      line_of_hunk,
    );
  }

  late final _git_patch_get_line_in_hunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff_line>>,
              ffi.Pointer<git_patch>,
              ffi.Size,
              ffi.Size)>>('git_patch_get_line_in_hunk');
  late final _git_patch_get_line_in_hunk =
      _git_patch_get_line_in_hunkPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_diff_line>>,
              ffi.Pointer<git_patch>, int, int)>();

  /// Look up size of patch diff data in bytes
  ///
  /// This returns the raw size of the patch data.  This only includes the
  /// actual data from the lines of the diff, not the file or hunk headers.
  ///
  /// If you pass `include_context` as true (non-zero), this will be the size
  /// of all of the diff output; if you pass it as false (zero), this will
  /// only include the actual changed lines (as if `context_lines` was 0).
  ///
  /// @param patch A git_patch representing changes to one file
  /// @param include_context Include context lines in size if non-zero
  /// @param include_hunk_headers Include hunk header lines if non-zero
  /// @param include_file_headers Include file header lines if non-zero
  /// @return The number of bytes of data
  int git_patch_size(
    ffi.Pointer<git_patch> patch,
    int include_context,
    int include_hunk_headers,
    int include_file_headers,
  ) {
    return _git_patch_size(
      patch,
      include_context,
      include_hunk_headers,
      include_file_headers,
    );
  }

  late final _git_patch_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<git_patch>, ffi.Int, ffi.Int,
              ffi.Int)>>('git_patch_size');
  late final _git_patch_size = _git_patch_sizePtr
      .asFunction<int Function(ffi.Pointer<git_patch>, int, int, int)>();

  /// Serialize the patch to text via callback.
  ///
  /// Returning a non-zero value from the callback will terminate the iteration
  /// and return that value to the caller.
  ///
  /// @param patch A git_patch representing changes to one file
  /// @param print_cb Callback function to output lines of the patch.  Will be
  /// called for file headers, hunk headers, and diff lines.
  /// @param payload Reference pointer that will be passed to your callbacks.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_patch_print(
    ffi.Pointer<git_patch> patch,
    git_diff_line_cb print_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_patch_print(
      patch,
      print_cb,
      payload,
    );
  }

  late final _git_patch_printPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_patch>, git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_patch_print');
  late final _git_patch_print = _git_patch_printPtr.asFunction<
      int Function(
          ffi.Pointer<git_patch>, git_diff_line_cb, ffi.Pointer<ffi.Void>)>();

  /// Get the content of a patch as a single diff text.
  ///
  /// @param out The git_buf to be filled in
  /// @param patch A git_patch representing changes to one file
  /// @return 0 on success, <0 on failure.
  int git_patch_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_to_buf(
      out,
      patch,
    );
  }

  late final _git_patch_to_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_patch>)>>('git_patch_to_buf');
  late final _git_patch_to_buf = _git_patch_to_bufPtr
      .asFunction<int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_patch>)>();

  /// Compile a pathspec
  ///
  /// @param out Output of the compiled pathspec
  /// @param pathspec A git_strarray of the paths to match
  /// @return 0 on success, <0 on failure
  int git_pathspec_new(
    ffi.Pointer<ffi.Pointer<git_pathspec>> out,
    ffi.Pointer<git_strarray> pathspec,
  ) {
    return _git_pathspec_new(
      out,
      pathspec,
    );
  }

  late final _git_pathspec_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_pathspec>>,
              ffi.Pointer<git_strarray>)>>('git_pathspec_new');
  late final _git_pathspec_new = _git_pathspec_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_pathspec>>, ffi.Pointer<git_strarray>)>();

  /// Free a pathspec
  ///
  /// @param ps The compiled pathspec
  void git_pathspec_free(
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_free(
      ps,
    );
  }

  late final _git_pathspec_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_pathspec>)>>(
          'git_pathspec_free');
  late final _git_pathspec_free = _git_pathspec_freePtr
      .asFunction<void Function(ffi.Pointer<git_pathspec>)>();

  /// Try to match a path against a pathspec
  ///
  /// Unlike most of the other pathspec matching functions, this will not
  /// fall back on the native case-sensitivity for your platform.  You must
  /// explicitly pass flags to control case sensitivity or else this will
  /// fall back on being case sensitive.
  ///
  /// @param ps The compiled pathspec
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param path The pathname to attempt to match
  /// @return 1 is path matches spec, 0 if it does not
  int git_pathspec_matches_path(
    ffi.Pointer<git_pathspec> ps,
    int flags,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_pathspec_matches_path(
      ps,
      flags,
      path,
    );
  }

  late final _git_pathspec_matches_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_pathspec>, ffi.Uint32,
              ffi.Pointer<ffi.Char>)>>('git_pathspec_matches_path');
  late final _git_pathspec_matches_path =
      _git_pathspec_matches_pathPtr.asFunction<
          int Function(
              ffi.Pointer<git_pathspec>, int, ffi.Pointer<ffi.Char>)>();

  /// Match a pathspec against the working directory of a repository.
  ///
  /// This matches the pathspec against the current files in the working
  /// directory of the repository.  It is an error to invoke this on a bare
  /// repo.  This handles git ignores (i.e. ignored files will not be
  /// considered to match the `pathspec` unless the file is tracked in the
  /// index).
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param repo The repository in which to match; bare repo is an error
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag was given
  int git_pathspec_match_workdir(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_workdir(
      out,
      repo,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_workdir');
  late final _git_pathspec_match_workdir =
      _git_pathspec_match_workdirPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_repository>, int, ffi.Pointer<git_pathspec>)>();

  /// Match a pathspec against entries in an index.
  ///
  /// This matches the pathspec against the files in the repository index.
  ///
  /// NOTE: At the moment, the case sensitivity of this match is controlled
  /// by the current case-sensitivity of the index object itself and the
  /// USE_CASE and IGNORE_CASE flags will have no effect.  This behavior will
  /// be corrected in a future release.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param index The index to match against
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_index(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_index> index,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_index(
      out,
      index,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_index>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_index');
  late final _git_pathspec_match_index =
      _git_pathspec_match_indexPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_index>, int, ffi.Pointer<git_pathspec>)>();

  /// Match a pathspec against files in a tree.
  ///
  /// This matches the pathspec against the files in the given tree.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param tree The root-level tree to match against
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_tree(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_tree> tree,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_tree(
      out,
      tree,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_tree>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_tree');
  late final _git_pathspec_match_tree = _git_pathspec_match_treePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
          ffi.Pointer<git_tree>, int, ffi.Pointer<git_pathspec>)>();

  /// Match a pathspec against files in a diff list.
  ///
  /// This matches the pathspec against the files in the given diff list.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param diff A generated diff list
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_diff(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_diff> diff,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_diff(
      out,
      diff,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_diffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_diff>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_diff');
  late final _git_pathspec_match_diff = _git_pathspec_match_diffPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
          ffi.Pointer<git_diff>, int, ffi.Pointer<git_pathspec>)>();

  /// Free memory associates with a git_pathspec_match_list
  ///
  /// @param m The git_pathspec_match_list to be freed
  void git_pathspec_match_list_free(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_free(
      m,
    );
  }

  late final _git_pathspec_match_list_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_pathspec_match_list>)>>(
      'git_pathspec_match_list_free');
  late final _git_pathspec_match_list_free = _git_pathspec_match_list_freePtr
      .asFunction<void Function(ffi.Pointer<git_pathspec_match_list>)>();

  /// Get the number of items in a match list.
  ///
  /// @param m The git_pathspec_match_list object
  /// @return Number of items in match list
  int git_pathspec_match_list_entrycount(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_entrycount(
      m,
    );
  }

  late final _git_pathspec_match_list_entrycountPtr = _lookup<
          ffi.NativeFunction<
              ffi.Size Function(ffi.Pointer<git_pathspec_match_list>)>>(
      'git_pathspec_match_list_entrycount');
  late final _git_pathspec_match_list_entrycount =
      _git_pathspec_match_list_entrycountPtr
          .asFunction<int Function(ffi.Pointer<git_pathspec_match_list>)>();

  /// Get a matching filename by position.
  ///
  /// This routine cannot be used if the match list was generated by
  /// `git_pathspec_match_diff`.  If so, it will always return NULL.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the list
  /// @return The filename of the match
  ffi.Pointer<ffi.Char> git_pathspec_match_list_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_pathspec_match_list>,
              ffi.Size)>>('git_pathspec_match_list_entry');
  late final _git_pathspec_match_list_entry =
      _git_pathspec_match_list_entryPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_pathspec_match_list>, int)>();

  /// Get a matching diff delta by position.
  ///
  /// This routine can only be used if the match list was generated by
  /// `git_pathspec_match_diff`.  Otherwise it will always return NULL.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the list
  /// @return The filename of the match
  ffi.Pointer<git_diff_delta> git_pathspec_match_list_diff_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_diff_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_diff_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_pathspec_match_list>,
              ffi.Size)>>('git_pathspec_match_list_diff_entry');
  late final _git_pathspec_match_list_diff_entry =
      _git_pathspec_match_list_diff_entryPtr.asFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_pathspec_match_list>, int)>();

  /// Get the number of pathspec items that did not match.
  ///
  /// This will be zero unless you passed GIT_PATHSPEC_FIND_FAILURES when
  /// generating the git_pathspec_match_list.
  ///
  /// @param m The git_pathspec_match_list object
  /// @return Number of items in original pathspec that had no matches
  int git_pathspec_match_list_failed_entrycount(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_failed_entrycount(
      m,
    );
  }

  late final _git_pathspec_match_list_failed_entrycountPtr = _lookup<
          ffi.NativeFunction<
              ffi.Size Function(ffi.Pointer<git_pathspec_match_list>)>>(
      'git_pathspec_match_list_failed_entrycount');
  late final _git_pathspec_match_list_failed_entrycount =
      _git_pathspec_match_list_failed_entrycountPtr
          .asFunction<int Function(ffi.Pointer<git_pathspec_match_list>)>();

  /// Get an original pathspec string that had no matches.
  ///
  /// This will be return NULL for positions out of range.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the failed items
  /// @return The pathspec pattern that didn't match anything
  ffi.Pointer<ffi.Char> git_pathspec_match_list_failed_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_failed_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_failed_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_pathspec_match_list>,
              ffi.Size)>>('git_pathspec_match_list_failed_entry');
  late final _git_pathspec_match_list_failed_entry =
      _git_pathspec_match_list_failed_entryPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_pathspec_match_list>, int)>();

  /// Initialize git_rebase_options structure
  ///
  /// Initializes a `git_rebase_options` with default values. Equivalent to
  /// creating an instance with `GIT_REBASE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_rebase_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REBASE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_rebase_options_init(
    ffi.Pointer<git_rebase_options> opts,
    int version,
  ) {
    return _git_rebase_options_init(
      opts,
      version,
    );
  }

  late final _git_rebase_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_rebase_options>,
              ffi.UnsignedInt)>>('git_rebase_options_init');
  late final _git_rebase_options_init = _git_rebase_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_rebase_options>, int)>();

  /// Initializes a rebase operation to rebase the changes in `branch`
  /// relative to `upstream` onto another branch.  To begin the rebase
  /// process, call `git_rebase_next`.  When you have finished with this
  /// object, call `git_rebase_free`.
  ///
  /// @param out Pointer to store the rebase object
  /// @param repo The repository to perform the rebase
  /// @param branch The terminal commit to rebase, or NULL to rebase the
  /// current branch
  /// @param upstream The commit to begin rebasing from, or NULL to rebase all
  /// reachable commits
  /// @param onto The branch to rebase onto, or NULL to rebase onto the given
  /// upstream
  /// @param opts Options to specify how rebase is performed, or NULL
  /// @return Zero on success; -1 on failure.
  int git_rebase_init(
    ffi.Pointer<ffi.Pointer<git_rebase>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> branch,
    ffi.Pointer<git_annotated_commit> upstream,
    ffi.Pointer<git_annotated_commit> onto,
    ffi.Pointer<git_rebase_options> opts,
  ) {
    return _git_rebase_init(
      out,
      repo,
      branch,
      upstream,
      onto,
      opts,
    );
  }

  late final _git_rebase_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_rebase>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Pointer<git_rebase_options>)>>('git_rebase_init');
  late final _git_rebase_init = _git_rebase_initPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_rebase>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_annotated_commit>,
          ffi.Pointer<git_annotated_commit>,
          ffi.Pointer<git_annotated_commit>,
          ffi.Pointer<git_rebase_options>)>();

  /// Opens an existing rebase that was previously started by either an
  /// invocation of `git_rebase_init` or by another client.
  ///
  /// @param out Pointer to store the rebase object
  /// @param repo The repository that has a rebase in-progress
  /// @param opts Options to specify how rebase is performed
  /// @return Zero on success; -1 on failure.
  int git_rebase_open(
    ffi.Pointer<ffi.Pointer<git_rebase>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_rebase_options> opts,
  ) {
    return _git_rebase_open(
      out,
      repo,
      opts,
    );
  }

  late final _git_rebase_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_rebase>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_rebase_options>)>>('git_rebase_open');
  late final _git_rebase_open = _git_rebase_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_rebase>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_rebase_options>)>();

  /// Gets the original `HEAD` ref name for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The original `HEAD` ref name
  ffi.Pointer<ffi.Char> git_rebase_orig_head_name(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_orig_head_name(
      rebase,
    );
  }

  late final _git_rebase_orig_head_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_orig_head_name');
  late final _git_rebase_orig_head_name = _git_rebase_orig_head_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the original `HEAD` id for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The original `HEAD` id
  ffi.Pointer<git_oid> git_rebase_orig_head_id(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_orig_head_id(
      rebase,
    );
  }

  late final _git_rebase_orig_head_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_orig_head_id');
  late final _git_rebase_orig_head_id = _git_rebase_orig_head_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the `onto` ref name for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The `onto` ref name
  ffi.Pointer<ffi.Char> git_rebase_onto_name(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_onto_name(
      rebase,
    );
  }

  late final _git_rebase_onto_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_onto_name');
  late final _git_rebase_onto_name = _git_rebase_onto_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the `onto` id for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The `onto` id
  ffi.Pointer<git_oid> git_rebase_onto_id(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_onto_id(
      rebase,
    );
  }

  late final _git_rebase_onto_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_onto_id');
  late final _git_rebase_onto_id = _git_rebase_onto_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the count of rebase operations that are to be applied.
  ///
  /// @param rebase The in-progress rebase
  /// @return The number of rebase operations in total
  int git_rebase_operation_entrycount(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_operation_entrycount(
      rebase,
    );
  }

  late final _git_rebase_operation_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_operation_entrycount');
  late final _git_rebase_operation_entrycount =
      _git_rebase_operation_entrycountPtr
          .asFunction<int Function(ffi.Pointer<git_rebase>)>();

  /// Gets the index of the rebase operation that is currently being applied.
  /// If the first operation has not yet been applied (because you have
  /// called `init` but not yet `next`) then this returns
  /// `GIT_REBASE_NO_OPERATION`.
  ///
  /// @param rebase The in-progress rebase
  /// @return The index of the rebase operation currently being applied.
  int git_rebase_operation_current(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_operation_current(
      rebase,
    );
  }

  late final _git_rebase_operation_currentPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_operation_current');
  late final _git_rebase_operation_current = _git_rebase_operation_currentPtr
      .asFunction<int Function(ffi.Pointer<git_rebase>)>();

  /// Gets the rebase operation specified by the given index.
  ///
  /// @param rebase The in-progress rebase
  /// @param idx The index of the rebase operation to retrieve
  /// @return The rebase operation or NULL if `idx` was out of bounds
  ffi.Pointer<git_rebase_operation> git_rebase_operation_byindex(
    ffi.Pointer<git_rebase> rebase,
    int idx,
  ) {
    return _git_rebase_operation_byindex(
      rebase,
      idx,
    );
  }

  late final _git_rebase_operation_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_rebase_operation> Function(ffi.Pointer<git_rebase>,
              ffi.Size)>>('git_rebase_operation_byindex');
  late final _git_rebase_operation_byindex =
      _git_rebase_operation_byindexPtr.asFunction<
          ffi.Pointer<git_rebase_operation> Function(
              ffi.Pointer<git_rebase>, int)>();

  /// Performs the next rebase operation and returns the information about it.
  /// If the operation is one that applies a patch (which is any operation except
  /// GIT_REBASE_OPERATION_EXEC) then the patch will be applied and the index and
  /// working directory will be updated with the changes.  If there are conflicts,
  /// you will need to address those before committing the changes.
  ///
  /// @param operation Pointer to store the rebase operation that is to be performed next
  /// @param rebase The rebase in progress
  /// @return Zero on success; -1 on failure.
  int git_rebase_next(
    ffi.Pointer<ffi.Pointer<git_rebase_operation>> operation,
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_next(
      operation,
      rebase,
    );
  }

  late final _git_rebase_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_rebase_operation>>,
              ffi.Pointer<git_rebase>)>>('git_rebase_next');
  late final _git_rebase_next = _git_rebase_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_rebase_operation>>,
          ffi.Pointer<git_rebase>)>();

  /// Gets the index produced by the last operation, which is the result
  /// of `git_rebase_next` and which will be committed by the next
  /// invocation of `git_rebase_commit`.  This is useful for resolving
  /// conflicts in an in-memory rebase before committing them.  You must
  /// call `git_index_free` when you are finished with this.
  ///
  /// This is only applicable for in-memory rebases; for rebases within
  /// a working directory, the changes were applied to the repository's
  /// index.
  ///
  /// @param index The result index of the last operation.
  /// @param rebase The in-progress rebase.
  /// @return 0 or an error code
  int git_rebase_inmemory_index(
    ffi.Pointer<ffi.Pointer<git_index>> index,
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_inmemory_index(
      index,
      rebase,
    );
  }

  late final _git_rebase_inmemory_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_rebase>)>>('git_rebase_inmemory_index');
  late final _git_rebase_inmemory_index =
      _git_rebase_inmemory_indexPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_index>>, ffi.Pointer<git_rebase>)>();

  /// Commits the current patch.  You must have resolved any conflicts that
  /// were introduced during the patch application from the `git_rebase_next`
  /// invocation.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  /// @param rebase The rebase that is in-progress
  /// @param author The author of the updated commit, or NULL to keep the
  /// author from the original commit
  /// @param committer The committer of the rebase
  /// @param message_encoding The encoding for the message in the commit,
  /// represented with a standard encoding name.  If message is NULL,
  /// this should also be NULL, and the encoding from the original
  /// commit will be maintained.  If message is specified, this may be
  /// NULL to indicate that "UTF-8" is to be used.
  /// @param message The message for this commit, or NULL to use the message
  /// from the original commit.
  /// @return Zero on success, GIT_EUNMERGED if there are unmerged changes in
  /// the index, GIT_EAPPLIED if the current commit has already
  /// been applied to the upstream and there is nothing to commit,
  /// -1 on failure.
  int git_rebase_commit(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_rebase> rebase,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _git_rebase_commit(
      id,
      rebase,
      author,
      committer,
      message_encoding,
      message,
    );
  }

  late final _git_rebase_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_rebase>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_rebase_commit');
  late final _git_rebase_commit = _git_rebase_commitPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_rebase>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Aborts a rebase that is currently in progress, resetting the repository
  /// and working directory to their state before rebase began.
  ///
  /// @param rebase The rebase that is in-progress
  /// @return Zero on success; GIT_ENOTFOUND if a rebase is not in progress,
  /// -1 on other errors.
  int git_rebase_abort(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_abort(
      rebase,
    );
  }

  late final _git_rebase_abortPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_abort');
  late final _git_rebase_abort =
      _git_rebase_abortPtr.asFunction<int Function(ffi.Pointer<git_rebase>)>();

  /// Finishes a rebase that is currently in progress once all patches have
  /// been applied.
  ///
  /// @param rebase The rebase that is in-progress
  /// @param signature The identity that is finishing the rebase (optional)
  /// @return Zero on success; -1 on error
  int git_rebase_finish(
    ffi.Pointer<git_rebase> rebase,
    ffi.Pointer<git_signature> signature,
  ) {
    return _git_rebase_finish(
      rebase,
      signature,
    );
  }

  late final _git_rebase_finishPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_rebase>,
              ffi.Pointer<git_signature>)>>('git_rebase_finish');
  late final _git_rebase_finish = _git_rebase_finishPtr.asFunction<
      int Function(ffi.Pointer<git_rebase>, ffi.Pointer<git_signature>)>();

  /// Frees the `git_rebase` object.
  ///
  /// @param rebase The rebase object
  void git_rebase_free(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_free(
      rebase,
    );
  }

  late final _git_rebase_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_free');
  late final _git_rebase_free =
      _git_rebase_freePtr.asFunction<void Function(ffi.Pointer<git_rebase>)>();

  /// Create a new reference database with no backends.
  ///
  /// Before the Ref DB can be used for read/writing, a custom database
  /// backend must be manually set using `git_refdb_set_backend()`
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param repo the repository
  /// @return 0 or an error code
  int git_refdb_new(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_refdb_new(
      out,
      repo,
    );
  }

  late final _git_refdb_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>>,
              ffi.Pointer<git_repository>)>>('git_refdb_new');
  late final _git_refdb_new = _git_refdb_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refdb>>, ffi.Pointer<git_repository>)>();

  /// Create a new reference database and automatically add
  /// the default backends:
  ///
  /// - git_refdb_dir: read and write loose and packed refs
  /// from disk, assuming the repository dir as the folder
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param repo the repository
  /// @return 0 or an error code
  int git_refdb_open(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_refdb_open(
      out,
      repo,
    );
  }

  late final _git_refdb_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>>,
              ffi.Pointer<git_repository>)>>('git_refdb_open');
  late final _git_refdb_open = _git_refdb_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refdb>>, ffi.Pointer<git_repository>)>();

  /// Suggests that the given refdb compress or optimize its references.
  /// This mechanism is implementation specific.  For on-disk reference
  /// databases, for example, this may pack all loose references.
  ///
  /// @param refdb The reference database to optimize.
  /// @return 0 or an error code.
  int git_refdb_compress(
    ffi.Pointer<git_refdb> refdb,
  ) {
    return _git_refdb_compress(
      refdb,
    );
  }

  late final _git_refdb_compressPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_refdb>)>>(
          'git_refdb_compress');
  late final _git_refdb_compress =
      _git_refdb_compressPtr.asFunction<int Function(ffi.Pointer<git_refdb>)>();

  /// Close an open reference database.
  ///
  /// @param refdb reference database pointer or NULL
  void git_refdb_free(
    ffi.Pointer<git_refdb> refdb,
  ) {
    return _git_refdb_free(
      refdb,
    );
  }

  late final _git_refdb_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_refdb>)>>(
          'git_refdb_free');
  late final _git_refdb_free =
      _git_refdb_freePtr.asFunction<void Function(ffi.Pointer<git_refdb>)>();

  /// Read the reflog for the given reference
  ///
  /// If there is no reflog file for the given
  /// reference yet, an empty reflog object will
  /// be returned.
  ///
  /// The reflog must be freed manually by using
  /// git_reflog_free().
  ///
  /// @param out pointer to reflog
  /// @param repo the repository
  /// @param name reference to look up
  /// @return 0 or an error code
  int git_reflog_read(
    ffi.Pointer<ffi.Pointer<git_reflog>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reflog_read(
      out,
      repo,
      name,
    );
  }

  late final _git_reflog_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reflog>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_read');
  late final _git_reflog_read = _git_reflog_readPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reflog>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Write an existing in-memory reflog object back to disk
  /// using an atomic file lock.
  ///
  /// @param reflog an existing reflog object
  /// @return 0 or an error code
  int git_reflog_write(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_write(
      reflog,
    );
  }

  late final _git_reflog_writePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reflog>)>>(
          'git_reflog_write');
  late final _git_reflog_write =
      _git_reflog_writePtr.asFunction<int Function(ffi.Pointer<git_reflog>)>();

  /// Add a new entry to the in-memory reflog.
  ///
  /// `msg` is optional and can be NULL.
  ///
  /// @param reflog an existing reflog object
  /// @param id the OID the reference is now pointing to
  /// @param committer the signature of the committer
  /// @param msg the reflog message
  /// @return 0 or an error code
  int git_reflog_append(
    ffi.Pointer<git_reflog> reflog,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> msg,
  ) {
    return _git_reflog_append(
      reflog,
      id,
      committer,
      msg,
    );
  }

  late final _git_reflog_appendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_reflog>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_append');
  late final _git_reflog_append = _git_reflog_appendPtr.asFunction<
      int Function(ffi.Pointer<git_reflog>, ffi.Pointer<git_oid>,
          ffi.Pointer<git_signature>, ffi.Pointer<ffi.Char>)>();

  /// Rename a reflog
  ///
  /// The reflog to be renamed is expected to already exist
  ///
  /// The new name will be checked for validity.
  /// See `git_reference_create_symbolic()` for rules about valid names.
  ///
  /// @param repo the repository
  /// @param old_name the old name of the reference
  /// @param name the new name of the reference
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_reflog_rename(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> old_name,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reflog_rename(
      repo,
      old_name,
      name,
    );
  }

  late final _git_reflog_renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_rename');
  late final _git_reflog_rename = _git_reflog_renamePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Delete the reflog for the given reference
  ///
  /// @param repo the repository
  /// @param name the reflog to delete
  /// @return 0 or an error code
  int git_reflog_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reflog_delete(
      repo,
      name,
    );
  }

  late final _git_reflog_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_delete');
  late final _git_reflog_delete = _git_reflog_deletePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Get the number of log entries in a reflog
  ///
  /// @param reflog the previously loaded reflog
  /// @return the number of log entries
  int git_reflog_entrycount(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_entrycount(
      reflog,
    );
  }

  late final _git_reflog_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_reflog>)>>(
          'git_reflog_entrycount');
  late final _git_reflog_entrycount = _git_reflog_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_reflog>)>();

  /// Lookup an entry by its index
  ///
  /// Requesting the reflog entry with an index of 0 (zero) will
  /// return the most recently created entry.
  ///
  /// @param reflog a previously loaded reflog
  /// @param idx the position of the entry to lookup. Should be greater than or
  /// equal to 0 (zero) and less than `git_reflog_entrycount()`.
  /// @return the entry; NULL if not found
  ffi.Pointer<git_reflog_entry> git_reflog_entry_byindex(
    ffi.Pointer<git_reflog> reflog,
    int idx,
  ) {
    return _git_reflog_entry_byindex(
      reflog,
      idx,
    );
  }

  late final _git_reflog_entry_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_reflog_entry> Function(
              ffi.Pointer<git_reflog>, ffi.Size)>>('git_reflog_entry_byindex');
  late final _git_reflog_entry_byindex =
      _git_reflog_entry_byindexPtr.asFunction<
          ffi.Pointer<git_reflog_entry> Function(
              ffi.Pointer<git_reflog>, int)>();

  /// Remove an entry from the reflog by its index
  ///
  /// To ensure there's no gap in the log history, set `rewrite_previous_entry`
  /// param value to 1. When deleting entry `n`, member old_oid of entry `n-1`
  /// (if any) will be updated with the value of member new_oid of entry `n+1`.
  ///
  /// @param reflog a previously loaded reflog.
  ///
  /// @param idx the position of the entry to remove. Should be greater than or
  /// equal to 0 (zero) and less than `git_reflog_entrycount()`.
  ///
  /// @param rewrite_previous_entry 1 to rewrite the history; 0 otherwise.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if the entry doesn't exist
  /// or an error code.
  int git_reflog_drop(
    ffi.Pointer<git_reflog> reflog,
    int idx,
    int rewrite_previous_entry,
  ) {
    return _git_reflog_drop(
      reflog,
      idx,
      rewrite_previous_entry,
    );
  }

  late final _git_reflog_dropPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_reflog>, ffi.Size, ffi.Int)>>('git_reflog_drop');
  late final _git_reflog_drop = _git_reflog_dropPtr
      .asFunction<int Function(ffi.Pointer<git_reflog>, int, int)>();

  /// Get the old oid
  ///
  /// @param entry a reflog entry
  /// @return the old oid
  ffi.Pointer<git_oid> git_reflog_entry_id_old(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_id_old(
      entry,
    );
  }

  late final _git_reflog_entry_id_oldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_id_old');
  late final _git_reflog_entry_id_old = _git_reflog_entry_id_oldPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Get the new oid
  ///
  /// @param entry a reflog entry
  /// @return the new oid at this time
  ffi.Pointer<git_oid> git_reflog_entry_id_new(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_id_new(
      entry,
    );
  }

  late final _git_reflog_entry_id_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_id_new');
  late final _git_reflog_entry_id_new = _git_reflog_entry_id_newPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Get the committer of this entry
  ///
  /// @param entry a reflog entry
  /// @return the committer
  ffi.Pointer<git_signature> git_reflog_entry_committer(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_committer(
      entry,
    );
  }

  late final _git_reflog_entry_committerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_committer');
  late final _git_reflog_entry_committer =
      _git_reflog_entry_committerPtr.asFunction<
          ffi.Pointer<git_signature> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Get the log message
  ///
  /// @param entry a reflog entry
  /// @return the log msg
  ffi.Pointer<ffi.Char> git_reflog_entry_message(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_message(
      entry,
    );
  }

  late final _git_reflog_entry_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_message');
  late final _git_reflog_entry_message =
      _git_reflog_entry_messagePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Free the reflog
  ///
  /// @param reflog reflog to free
  void git_reflog_free(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_free(
      reflog,
    );
  }

  late final _git_reflog_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_reflog>)>>(
          'git_reflog_free');
  late final _git_reflog_free =
      _git_reflog_freePtr.asFunction<void Function(ffi.Pointer<git_reflog>)>();

  /// Sets the current head to the specified commit oid and optionally
  /// resets the index and working tree to match.
  ///
  /// SOFT reset means the Head will be moved to the commit.
  ///
  /// MIXED reset will trigger a SOFT reset, plus the index will be replaced
  /// with the content of the commit tree.
  ///
  /// HARD reset will trigger a MIXED reset and the working directory will be
  /// replaced with the content of the index.  (Untracked and ignored files
  /// will be left alone, however.)
  ///
  /// TODO: Implement remaining kinds of resets.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target Committish to which the Head should be moved to. This object
  /// must belong to the given `repo` and can either be a git_commit or a
  /// git_tag. When a git_tag is being passed, it should be dereferenceable
  /// to a git_commit which oid will be used as the target of the branch.
  ///
  /// @param reset_type Kind of reset operation to perform.
  ///
  /// @param checkout_opts Optional checkout options to be used for a HARD reset.
  /// The checkout_strategy field will be overridden (based on reset_type).
  /// This parameter can be used to propagate notify and progress callbacks.
  ///
  /// @return 0 on success or an error code
  int git_reset(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> target,
    git_reset_t reset_type,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_reset(
      repo,
      target,
      reset_type.value,
      checkout_opts,
    );
  }

  late final _git_resetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_object>,
              ffi.UnsignedInt,
              ffi.Pointer<git_checkout_options>)>>('git_reset');
  late final _git_reset = _git_resetPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>, int,
          ffi.Pointer<git_checkout_options>)>();

  /// Sets the current head to the specified commit oid and optionally
  /// resets the index and working tree to match.
  ///
  /// This behaves like `git_reset()` but takes an annotated commit,
  /// which lets you specify which extended sha syntax string was
  /// specified by a user, allowing for more exact reflog messages.
  ///
  /// See the documentation for `git_reset()`.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target Annotated commit to which the Head should be moved to.
  /// This object must belong to the given `repo`, it will be dereferenced
  /// to a git_commit which oid will be used as the target of the branch.
  ///
  /// @param reset_type Kind of reset operation to perform.
  ///
  /// @param checkout_opts Optional checkout options to be used for a HARD reset.
  /// The checkout_strategy field will be overridden (based on reset_type).
  /// This parameter can be used to propagate notify and progress callbacks.
  ///
  /// @return 0 on success or an error code
  int git_reset_from_annotated(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> target,
    git_reset_t reset_type,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_reset_from_annotated(
      repo,
      target,
      reset_type.value,
      checkout_opts,
    );
  }

  late final _git_reset_from_annotatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>,
              ffi.UnsignedInt,
              ffi.Pointer<git_checkout_options>)>>('git_reset_from_annotated');
  late final _git_reset_from_annotated =
      _git_reset_from_annotatedPtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>,
              int,
              ffi.Pointer<git_checkout_options>)>();

  /// Updates some entries in the index from the target commit tree.
  ///
  /// The scope of the updated entries is determined by the paths
  /// being passed in the `pathspec` parameters.
  ///
  /// Passing a NULL `target` will result in removing
  /// entries in the index matching the provided pathspecs.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target The committish which content will be used to reset the content
  /// of the index.
  ///
  /// @param pathspecs List of pathspecs to operate on.
  ///
  /// @return 0 on success or an error code < 0
  int git_reset_default(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_strarray> pathspecs,
  ) {
    return _git_reset_default(
      repo,
      target,
      pathspecs,
    );
  }

  late final _git_reset_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
              ffi.Pointer<git_strarray>)>>('git_reset_default');
  late final _git_reset_default = _git_reset_defaultPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
          ffi.Pointer<git_strarray>)>();

  /// Initialize git_revert_options structure
  ///
  /// Initializes a `git_revert_options` with default values. Equivalent to
  /// creating an instance with `GIT_REVERT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_revert_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REVERT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_revert_options_init(
    ffi.Pointer<git_revert_options> opts,
    int version,
  ) {
    return _git_revert_options_init(
      opts,
      version,
    );
  }

  late final _git_revert_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revert_options>,
              ffi.UnsignedInt)>>('git_revert_options_init');
  late final _git_revert_options_init = _git_revert_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_revert_options>, int)>();

  /// Reverts the given commit against the given "our" commit, producing an
  /// index that reflects the result of the revert.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo the repository that contains the given commits
  /// @param revert_commit the commit to revert
  /// @param our_commit the commit to revert against (eg, HEAD)
  /// @param mainline the parent of the revert commit, if it is a merge
  /// @param merge_options the merge options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_revert_commit(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> revert_commit,
    ffi.Pointer<git_commit> our_commit,
    int mainline,
    ffi.Pointer<git_merge_options> merge_options,
  ) {
    return _git_revert_commit(
      out,
      repo,
      revert_commit,
      our_commit,
      mainline,
      merge_options,
    );
  }

  late final _git_revert_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_commit>,
              ffi.UnsignedInt,
              ffi.Pointer<git_merge_options>)>>('git_revert_commit');
  late final _git_revert_commit = _git_revert_commitPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_commit>,
          int,
          ffi.Pointer<git_merge_options>)>();

  /// Reverts the given commit, producing changes in the index and working directory.
  ///
  /// @param repo the repository to revert
  /// @param commit the commit to revert
  /// @param given_opts the revert options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_revert(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_revert_options> given_opts,
  ) {
    return _git_revert(
      repo,
      commit,
      given_opts,
    );
  }

  late final _git_revertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
              ffi.Pointer<git_revert_options>)>>('git_revert');
  late final _git_revert = _git_revertPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
          ffi.Pointer<git_revert_options>)>();

  /// Find a single object, as specified by a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// The returned object should be released with `git_object_free` when no
  /// longer needed.
  ///
  /// @param out pointer to output object
  /// @param repo the repository to search in
  /// @param spec the textual specification for an object
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC or an error code
  int git_revparse_single(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> spec,
  ) {
    return _git_revparse_single(
      out,
      repo,
      spec,
    );
  }

  late final _git_revparse_singlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_revparse_single');
  late final _git_revparse_single = _git_revparse_singlePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Find a single object and intermediate reference by a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// In some cases (`@{<-n>}` or `<branchname>@{upstream}`), the expression may
  /// point to an intermediate reference. When such expressions are being passed
  /// in, `reference_out` will be valued as well.
  ///
  /// The returned object should be released with `git_object_free` and the
  /// returned reference with `git_reference_free` when no longer needed.
  ///
  /// @param object_out pointer to output object
  /// @param reference_out pointer to output reference or NULL
  /// @param repo the repository to search in
  /// @param spec the textual specification for an object
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC
  /// or an error code
  int git_revparse_ext(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<ffi.Pointer<git_reference>> reference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> spec,
  ) {
    return _git_revparse_ext(
      object_out,
      reference_out,
      repo,
      spec,
    );
  }

  late final _git_revparse_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_revparse_ext');
  late final _git_revparse_ext = _git_revparse_extPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Parse a revision string for `from`, `to`, and intent.
  ///
  /// See `man gitrevisions` or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// @param revspec Pointer to an user-allocated git_revspec struct where
  /// the result of the rev-parse will be stored
  /// @param repo the repository to search in
  /// @param spec the rev-parse spec to parse
  /// @return 0 on success, GIT_INVALIDSPEC, GIT_ENOTFOUND, GIT_EAMBIGUOUS or an error code
  int git_revparse(
    ffi.Pointer<git_revspec> revspec,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> spec,
  ) {
    return _git_revparse(
      revspec,
      repo,
      spec,
    );
  }

  late final _git_revparsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_revspec>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_revparse');
  late final _git_revparse = _git_revparsePtr.asFunction<
      int Function(ffi.Pointer<git_revspec>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Allocate a new revision walker to iterate through a repo.
  ///
  /// This revision walker uses a custom memory pool and an internal
  /// commit cache, so it is relatively expensive to allocate.
  ///
  /// For maximum performance, this revision walker should be
  /// reused for different walks.
  ///
  /// This revision walker is *not* thread safe: it may only be
  /// used to walk a repository on a single thread; however,
  /// it is possible to have several revision walkers in
  /// several different threads walking the same repository.
  ///
  /// @param out pointer to the new revision walker
  /// @param repo the repo to walk through
  /// @return 0 or an error code
  int git_revwalk_new(
    ffi.Pointer<ffi.Pointer<git_revwalk>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_revwalk_new(
      out,
      repo,
    );
  }

  late final _git_revwalk_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_revwalk>>,
              ffi.Pointer<git_repository>)>>('git_revwalk_new');
  late final _git_revwalk_new = _git_revwalk_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_revwalk>>,
          ffi.Pointer<git_repository>)>();

  /// Reset the revision walker for reuse.
  ///
  /// This will clear all the pushed and hidden commits, and
  /// leave the walker in a blank state (just like at
  /// creation) ready to receive new commit pushes and
  /// start a new walk.
  ///
  /// The revision walk is automatically reset when a walk
  /// is over.
  ///
  /// @param walker handle to reset.
  /// @return 0 or an error code
  int git_revwalk_reset(
    ffi.Pointer<git_revwalk> walker,
  ) {
    return _git_revwalk_reset(
      walker,
    );
  }

  late final _git_revwalk_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_reset');
  late final _git_revwalk_reset = _git_revwalk_resetPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Add a new root for the traversal
  ///
  /// The pushed commit will be marked as one of the roots from which to
  /// start the walk. This commit may not be walked if it or a child is
  /// hidden.
  ///
  /// At least one commit must be pushed onto the walker before a walk
  /// can be started.
  ///
  /// The given id must belong to a committish on the walked
  /// repository.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param id the oid of the commit to start from.
  /// @return 0 or an error code
  int git_revwalk_push(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_revwalk_push(
      walk,
      id,
    );
  }

  late final _git_revwalk_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<git_oid>)>>('git_revwalk_push');
  late final _git_revwalk_push = _git_revwalk_pushPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<git_oid>)>();

  /// Push matching references
  ///
  /// The OIDs pointed to by the references that match the given glob
  /// pattern will be pushed to the revision walker.
  ///
  /// A leading 'refs/' is implied if not present as well as a trailing
  /// '/\*' if the glob lacks '?', '\*' or '['.
  ///
  /// Any references matching this glob which do not point to a
  /// committish will be ignored.
  ///
  /// @param walk the walker being used for the traversal
  /// @param glob the glob pattern references should match
  /// @return 0 or an error code
  int git_revwalk_push_glob(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> glob,
  ) {
    return _git_revwalk_push_glob(
      walk,
      glob,
    );
  }

  late final _git_revwalk_push_globPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_push_glob');
  late final _git_revwalk_push_glob = _git_revwalk_push_globPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Push the repository's HEAD
  ///
  /// @param walk the walker being used for the traversal
  /// @return 0 or an error code
  int git_revwalk_push_head(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_push_head(
      walk,
    );
  }

  late final _git_revwalk_push_headPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_push_head');
  late final _git_revwalk_push_head = _git_revwalk_push_headPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Mark a commit (and its ancestors) uninteresting for the output.
  ///
  /// The given id must belong to a committish on the walked
  /// repository.
  ///
  /// The resolved commit and all its parents will be hidden from the
  /// output on the revision walk.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param commit_id the oid of commit that will be ignored during the traversal
  /// @return 0 or an error code
  int git_revwalk_hide(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<git_oid> commit_id,
  ) {
    return _git_revwalk_hide(
      walk,
      commit_id,
    );
  }

  late final _git_revwalk_hidePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<git_oid>)>>('git_revwalk_hide');
  late final _git_revwalk_hide = _git_revwalk_hidePtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<git_oid>)>();

  /// Hide matching references.
  ///
  /// The OIDs pointed to by the references that match the given glob
  /// pattern and their ancestors will be hidden from the output on the
  /// revision walk.
  ///
  /// A leading 'refs/' is implied if not present as well as a trailing
  /// '/\*' if the glob lacks '?', '\*' or '['.
  ///
  /// Any references matching this glob which do not point to a
  /// committish will be ignored.
  ///
  /// @param walk the walker being used for the traversal
  /// @param glob the glob pattern references should match
  /// @return 0 or an error code
  int git_revwalk_hide_glob(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> glob,
  ) {
    return _git_revwalk_hide_glob(
      walk,
      glob,
    );
  }

  late final _git_revwalk_hide_globPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_hide_glob');
  late final _git_revwalk_hide_glob = _git_revwalk_hide_globPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Hide the repository's HEAD
  ///
  /// @param walk the walker being used for the traversal
  /// @return 0 or an error code
  int git_revwalk_hide_head(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_hide_head(
      walk,
    );
  }

  late final _git_revwalk_hide_headPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_hide_head');
  late final _git_revwalk_hide_head = _git_revwalk_hide_headPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Push the OID pointed to by a reference
  ///
  /// The reference must point to a committish.
  ///
  /// @param walk the walker being used for the traversal
  /// @param refname the reference to push
  /// @return 0 or an error code
  int git_revwalk_push_ref(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_revwalk_push_ref(
      walk,
      refname,
    );
  }

  late final _git_revwalk_push_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_push_ref');
  late final _git_revwalk_push_ref = _git_revwalk_push_refPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Hide the OID pointed to by a reference
  ///
  /// The reference must point to a committish.
  ///
  /// @param walk the walker being used for the traversal
  /// @param refname the reference to hide
  /// @return 0 or an error code
  int git_revwalk_hide_ref(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_revwalk_hide_ref(
      walk,
      refname,
    );
  }

  late final _git_revwalk_hide_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_hide_ref');
  late final _git_revwalk_hide_ref = _git_revwalk_hide_refPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Get the next commit from the revision walk.
  ///
  /// The initial call to this method is *not* blocking when
  /// iterating through a repo with a time-sorting mode.
  ///
  /// Iterating with Topological or inverted modes makes the initial
  /// call blocking to preprocess the commit list, but this block should be
  /// mostly unnoticeable on most repositories (topological preprocessing
  /// times at 0.3s on the git.git repo).
  ///
  /// The revision walker is reset when the walk is over.
  ///
  /// @param out Pointer where to store the oid of the next commit
  /// @param walk the walker to pop the commit from.
  /// @return 0 if the next commit was found;
  /// GIT_ITEROVER if there are no commits left to iterate
  int git_revwalk_next(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_next(
      out,
      walk,
    );
  }

  late final _git_revwalk_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_revwalk>)>>('git_revwalk_next');
  late final _git_revwalk_next = _git_revwalk_nextPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_revwalk>)>();

  /// Change the sorting mode when iterating through the
  /// repository's contents.
  ///
  /// Changing the sorting mode resets the walker.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param sort_mode combination of GIT_SORT_XXX flags
  /// @return 0 or an error code
  int git_revwalk_sorting(
    ffi.Pointer<git_revwalk> walk,
    int sort_mode,
  ) {
    return _git_revwalk_sorting(
      walk,
      sort_mode,
    );
  }

  late final _git_revwalk_sortingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.UnsignedInt)>>('git_revwalk_sorting');
  late final _git_revwalk_sorting = _git_revwalk_sortingPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>, int)>();

  /// Push and hide the respective endpoints of the given range.
  ///
  /// The range should be of the form
  /// <commit>..<commit>
  /// where each <commit> is in the form accepted by 'git_revparse_single'.
  /// The left-hand commit will be hidden and the right-hand commit pushed.
  ///
  /// @param walk the walker being used for the traversal
  /// @param range the range
  /// @return 0 or an error code
  int git_revwalk_push_range(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> range,
  ) {
    return _git_revwalk_push_range(
      walk,
      range,
    );
  }

  late final _git_revwalk_push_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_push_range');
  late final _git_revwalk_push_range = _git_revwalk_push_rangePtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Simplify the history by first-parent
  ///
  /// No parents other than the first for each commit will be enqueued.
  ///
  /// @param walk The revision walker.
  /// @return 0 or an error code
  int git_revwalk_simplify_first_parent(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_simplify_first_parent(
      walk,
    );
  }

  late final _git_revwalk_simplify_first_parentPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_simplify_first_parent');
  late final _git_revwalk_simplify_first_parent =
      _git_revwalk_simplify_first_parentPtr
          .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Free a revision walker previously allocated.
  ///
  /// @param walk traversal handle to close. If NULL nothing occurs.
  void git_revwalk_free(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_free(
      walk,
    );
  }

  late final _git_revwalk_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_free');
  late final _git_revwalk_free = _git_revwalk_freePtr
      .asFunction<void Function(ffi.Pointer<git_revwalk>)>();

  /// Return the repository on which this walker
  /// is operating.
  ///
  /// @param walk the revision walker
  /// @return the repository being walked
  ffi.Pointer<git_repository> git_revwalk_repository(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_repository(
      walk,
    );
  }

  late final _git_revwalk_repositoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_revwalk>)>>('git_revwalk_repository');
  late final _git_revwalk_repository = _git_revwalk_repositoryPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_revwalk>)>();

  /// Adds, changes or removes a callback function to hide a commit and its parents
  ///
  /// @param walk the revision walker
  /// @param hide_cb  callback function to hide a commit and its parents
  /// @param payload  data payload to be passed to callback function
  /// @return 0 or an error code.
  int git_revwalk_add_hide_cb(
    ffi.Pointer<git_revwalk> walk,
    git_revwalk_hide_cb hide_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_revwalk_add_hide_cb(
      walk,
      hide_cb,
      payload,
    );
  }

  late final _git_revwalk_add_hide_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>, git_revwalk_hide_cb,
              ffi.Pointer<ffi.Void>)>>('git_revwalk_add_hide_cb');
  late final _git_revwalk_add_hide_cb = _git_revwalk_add_hide_cbPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, git_revwalk_hide_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Create a new action signature.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// Note: angle brackets ('<' and '>') characters are not allowed
  /// to be used in either the `name` or the `email` parameter.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @param time time (in seconds from epoch) when the action happened
  /// @param offset timezone offset (in minutes) for the time
  /// @return 0 or an error code
  int git_signature_new(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
    int time,
    int offset,
  ) {
    return _git_signature_new(
      out,
      name,
      email,
      time,
      offset,
    );
  }

  late final _git_signature_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              git_time_t,
              ffi.Int)>>('git_signature_new');
  late final _git_signature_new = _git_signature_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Create a new action signature with a timestamp of 'now'.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @return 0 or an error code
  int git_signature_now(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
  ) {
    return _git_signature_now(
      out,
      name,
      email,
    );
  }

  late final _git_signature_nowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_signature_now');
  late final _git_signature_now = _git_signature_nowPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Create a new author and/or committer signatures with default
  /// information based on the configuration and environment variables.
  ///
  /// If `author_out` is set, it will be populated with the author
  /// information. The `GIT_AUTHOR_NAME` and `GIT_AUTHOR_EMAIL`
  /// environment variables will be honored, and `user.name` and
  /// `user.email` configuration options will be honored if the
  /// environment variables are unset. For timestamps, `GIT_AUTHOR_DATE`
  /// will be used, otherwise the current time will be used.
  ///
  /// If `committer_out` is set, it will be populated with the
  /// committer information. The `GIT_COMMITTER_NAME` and
  /// `GIT_COMMITTER_EMAIL` environment variables will be honored,
  /// and `user.name` and `user.email` configuration options will
  /// be honored if the environment variables are unset. For timestamps,
  /// `GIT_COMMITTER_DATE` will be used, otherwise the current time will
  /// be used.
  ///
  /// If neither `GIT_AUTHOR_DATE` nor `GIT_COMMITTER_DATE` are set,
  /// both timestamps will be set to the same time.
  ///
  /// It will return `GIT_ENOTFOUND` if either the `user.name` or
  /// `user.email` are not set and there is no fallback from an environment
  /// variable. One of `author_out` or `committer_out` must be set.
  ///
  /// @param author_out pointer to set the author signature, or NULL
  /// @param committer_out pointer to set the committer signature, or NULL
  /// @param repo repository pointer
  /// @return 0 on success, GIT_ENOTFOUND if config is missing, or error code
  int git_signature_default_from_env(
    ffi.Pointer<ffi.Pointer<git_signature>> author_out,
    ffi.Pointer<ffi.Pointer<git_signature>> committer_out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_signature_default_from_env(
      author_out,
      committer_out,
      repo,
    );
  }

  late final _git_signature_default_from_envPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_repository>)>>('git_signature_default_from_env');
  late final _git_signature_default_from_env =
      _git_signature_default_from_envPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_repository>)>();

  /// Create a new action signature with default user and now timestamp.
  ///
  /// This looks up the user.name and user.email from the configuration and
  /// uses the current time as the timestamp, and creates a new signature
  /// based on that information.  It will return GIT_ENOTFOUND if either the
  /// user.name or user.email are not set.
  ///
  /// Note that these do not examine environment variables, only the
  /// configuration files. Use `git_signature_default_from_env` to
  /// consider the environment variables.
  ///
  /// @param out new signature
  /// @param repo repository pointer
  /// @return 0 on success, GIT_ENOTFOUND if config is missing, or error code
  int git_signature_default(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_signature_default(
      out,
      repo,
    );
  }

  late final _git_signature_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_repository>)>>('git_signature_default');
  late final _git_signature_default = _git_signature_defaultPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<git_repository>)>();

  /// Create a new signature by parsing the given buffer, which is
  /// expected to be in the format "Real Name <email> timestamp tzoffset",
  /// where `timestamp` is the number of seconds since the Unix epoch and
  /// `tzoffset` is the timezone offset in `hhmm` format (note the lack
  /// of a colon separator).
  ///
  /// @param out new signature
  /// @param buf signature string
  /// @return 0 on success, GIT_EINVALID if the signature is not parseable, or an error code
  int git_signature_from_buffer(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Char> buf,
  ) {
    return _git_signature_from_buffer(
      out,
      buf,
    );
  }

  late final _git_signature_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>)>>('git_signature_from_buffer');
  late final _git_signature_from_buffer =
      _git_signature_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a copy of an existing signature.  All internal strings are also
  /// duplicated.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param sig signature to duplicate
  /// @return 0 or an error code
  int git_signature_dup(
    ffi.Pointer<ffi.Pointer<git_signature>> dest,
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_signature_dup(
      dest,
      sig,
    );
  }

  late final _git_signature_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_signature>)>>('git_signature_dup');
  late final _git_signature_dup = _git_signature_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<git_signature>)>();

  /// Free an existing signature.
  ///
  /// Because the signature is not an opaque structure, it is legal to free it
  /// manually, but be sure to free the "name" and "email" strings in addition
  /// to the structure itself.
  ///
  /// @param sig signature to free
  void git_signature_free(
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_signature_free(
      sig,
    );
  }

  late final _git_signature_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_signature>)>>(
      'git_signature_free');
  late final _git_signature_free = _git_signature_freePtr
      .asFunction<void Function(ffi.Pointer<git_signature>)>();

  /// Save the local modifications to a new stash.
  ///
  /// @param out Object id of the commit containing the stashed state.
  /// This commit is also the target of the direct reference refs/stash.
  /// @param repo The owning repository.
  /// @param stasher The identity of the person performing the stashing.
  /// @param message Optional description along with the stashed state.
  /// @param flags Flags to control the stashing process. (see GIT_STASH_* above)
  /// @return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
  /// or error code.
  int git_stash_save(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_signature> stasher,
    ffi.Pointer<ffi.Char> message,
    int flags,
  ) {
    return _git_stash_save(
      out,
      repo,
      stasher,
      message,
      flags,
    );
  }

  late final _git_stash_savePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint32)>>('git_stash_save');
  late final _git_stash_save = _git_stash_savePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_signature>, ffi.Pointer<ffi.Char>, int)>();

  /// Initialize git_stash_save_options structure
  ///
  /// Initializes a `git_stash_save_options` with default values. Equivalent to
  /// creating an instance with `GIT_STASH_SAVE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_stash_save_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STASH_SAVE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_stash_save_options_init(
    ffi.Pointer<git_stash_save_options> opts,
    int version,
  ) {
    return _git_stash_save_options_init(
      opts,
      version,
    );
  }

  late final _git_stash_save_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_stash_save_options>,
              ffi.UnsignedInt)>>('git_stash_save_options_init');
  late final _git_stash_save_options_init = _git_stash_save_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_stash_save_options>, int)>();

  /// Save the local modifications to a new stash, with options.
  ///
  /// @param out Object id of the commit containing the stashed state.
  /// This commit is also the target of the direct reference refs/stash.
  /// @param repo The owning repository.
  /// @param opts The stash options.
  /// @return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
  /// or error code.
  int git_stash_save_with_opts(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_stash_save_options> opts,
  ) {
    return _git_stash_save_with_opts(
      out,
      repo,
      opts,
    );
  }

  late final _git_stash_save_with_optsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_oid>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<git_stash_save_options>)>>(
      'git_stash_save_with_opts');
  late final _git_stash_save_with_opts =
      _git_stash_save_with_optsPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<git_stash_save_options>)>();

  /// Initialize git_stash_apply_options structure
  ///
  /// Initializes a `git_stash_apply_options` with default values. Equivalent to
  /// creating an instance with `GIT_STASH_APPLY_OPTIONS_INIT`.
  ///
  /// @param opts The `git_stash_apply_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STASH_APPLY_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_stash_apply_options_init(
    ffi.Pointer<git_stash_apply_options> opts,
    int version,
  ) {
    return _git_stash_apply_options_init(
      opts,
      version,
    );
  }

  late final _git_stash_apply_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_stash_apply_options>,
              ffi.UnsignedInt)>>('git_stash_apply_options_init');
  late final _git_stash_apply_options_init = _git_stash_apply_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_stash_apply_options>, int)>();

  /// Apply a single stashed state from the stash list.
  ///
  /// If local changes in the working directory conflict with changes in the
  /// stash then GIT_EMERGECONFLICT will be returned.  In this case, the index
  /// will always remain unmodified and all files in the working directory will
  /// remain unmodified.  However, if you are restoring untracked files or
  /// ignored files and there is a conflict when applying the modified files,
  /// then those files will remain in the working directory.
  ///
  /// If passing the GIT_STASH_APPLY_REINSTATE_INDEX flag and there would be
  /// conflicts when reinstating the index, the function will return
  /// GIT_EMERGECONFLICT and both the working directory and index will be left
  /// unmodified.
  ///
  /// @param repo The owning repository.
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  /// @param options Optional options to control how stashes are applied.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the
  /// given index, GIT_EMERGECONFLICT if changes exist in the working
  /// directory, or an error code
  int git_stash_apply(
    ffi.Pointer<git_repository> repo,
    int index,
    ffi.Pointer<git_stash_apply_options> options,
  ) {
    return _git_stash_apply(
      repo,
      index,
      options,
    );
  }

  late final _git_stash_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Size,
              ffi.Pointer<git_stash_apply_options>)>>('git_stash_apply');
  late final _git_stash_apply = _git_stash_applyPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_stash_apply_options>)>();

  /// Loop over all the stashed states and issue a callback for each one.
  ///
  /// If the callback returns a non-zero value, this will stop looping.
  ///
  /// @param repo Repository where to find the stash.
  ///
  /// @param callback Callback to invoke per found stashed state. The most
  /// recent stash state will be enumerated first.
  ///
  /// @param payload Extra parameter to callback function.
  ///
  /// @return 0 on success, non-zero callback return value, or error code.
  int git_stash_foreach(
    ffi.Pointer<git_repository> repo,
    git_stash_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_stash_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_stash_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_stash_cb,
              ffi.Pointer<ffi.Void>)>>('git_stash_foreach');
  late final _git_stash_foreach = _git_stash_foreachPtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>, git_stash_cb, ffi.Pointer<ffi.Void>)>();

  /// Remove a single stashed state from the stash list.
  ///
  /// @param repo The owning repository.
  ///
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
  /// index, or error code.
  int git_stash_drop(
    ffi.Pointer<git_repository> repo,
    int index,
  ) {
    return _git_stash_drop(
      repo,
      index,
    );
  }

  late final _git_stash_dropPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>, ffi.Size)>>('git_stash_drop');
  late final _git_stash_drop = _git_stash_dropPtr
      .asFunction<int Function(ffi.Pointer<git_repository>, int)>();

  /// Apply a single stashed state from the stash list and remove it from the list
  /// if successful.
  ///
  /// @param repo The owning repository.
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  /// @param options Optional options to control how stashes are applied.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
  /// index, or error code. (see git_stash_apply() above for details)
  int git_stash_pop(
    ffi.Pointer<git_repository> repo,
    int index,
    ffi.Pointer<git_stash_apply_options> options,
  ) {
    return _git_stash_pop(
      repo,
      index,
      options,
    );
  }

  late final _git_stash_popPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Size,
              ffi.Pointer<git_stash_apply_options>)>>('git_stash_pop');
  late final _git_stash_pop = _git_stash_popPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_stash_apply_options>)>();

  /// Initialize git_status_options structure
  ///
  /// Initializes a `git_status_options` with default values. Equivalent to
  /// creating an instance with `GIT_STATUS_OPTIONS_INIT`.
  ///
  /// @param opts The `git_status_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_status_options_init(
    ffi.Pointer<git_status_options> opts,
    int version,
  ) {
    return _git_status_options_init(
      opts,
      version,
    );
  }

  late final _git_status_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_status_options>,
              ffi.UnsignedInt)>>('git_status_options_init');
  late final _git_status_options_init = _git_status_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_status_options>, int)>();

  /// Gather file statuses and run a callback for each one.
  ///
  /// The callback is passed the path of the file, the status (a combination of
  /// the `git_status_t` values above) and the `payload` data pointer passed
  /// into this function.
  ///
  /// If the callback returns a non-zero value, this function will stop looping
  /// and return that value to caller.
  ///
  /// @param repo A repository object
  /// @param callback The function to call on each file
  /// @param payload Pointer to pass through to callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_status_foreach(
    ffi.Pointer<git_repository> repo,
    git_status_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_status_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_status_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_status_cb,
              ffi.Pointer<ffi.Void>)>>('git_status_foreach');
  late final _git_status_foreach = _git_status_foreachPtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>, git_status_cb, ffi.Pointer<ffi.Void>)>();

  /// Gather file status information and run callbacks as requested.
  ///
  /// This is an extended version of the `git_status_foreach()` API that
  /// allows for more granular control over which paths will be processed and
  /// in what order.  See the `git_status_options` structure for details
  /// about the additional controls that this makes available.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @param callback The function to call on each file
  /// @param payload Pointer to pass through to callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_status_foreach_ext(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
    git_status_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_status_foreach_ext(
      repo,
      opts,
      callback,
      payload,
    );
  }

  late final _git_status_foreach_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_status_options>,
              git_status_cb,
              ffi.Pointer<ffi.Void>)>>('git_status_foreach_ext');
  late final _git_status_foreach_ext = _git_status_foreach_extPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_status_options>,
          git_status_cb, ffi.Pointer<ffi.Void>)>();

  /// Get file status for a single file.
  ///
  /// This tries to get status for the filename that you give.  If no files
  /// match that name (in either the HEAD, index, or working directory), this
  /// returns GIT_ENOTFOUND.
  ///
  /// If the name matches multiple files (for example, if the `path` names a
  /// directory or if running on a case- insensitive filesystem and yet the
  /// HEAD has two entries that both match the path), then this returns
  /// GIT_EAMBIGUOUS because it cannot give correct results.
  ///
  /// This does not do any sort of rename detection.  Renames require a set of
  /// targets and because of the path filtering, there is not enough
  /// information to check renames correctly.  To check file status with rename
  /// detection, there is no choice but to do a full `git_status_list_new` and
  /// scan through looking for the path that you are interested in.
  ///
  /// @param status_flags Output combination of git_status_t values for file
  /// @param repo A repository object
  /// @param path The exact path to retrieve status for relative to the
  /// repository working directory
  /// @return 0 on success, GIT_ENOTFOUND if the file is not found in the HEAD,
  /// index, and work tree, GIT_EAMBIGUOUS if `path` matches multiple files
  /// or if it refers to a folder, and -1 on other errors.
  int git_status_file(
    ffi.Pointer<ffi.UnsignedInt> status_flags,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_status_file(
      status_flags,
      repo,
      path,
    );
  }

  late final _git_status_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_status_file');
  late final _git_status_file = _git_status_filePtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Gather file status information and populate the `git_status_list`.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param out Pointer to store the status results in
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @return 0 on success or error code
  int git_status_list_new(
    ffi.Pointer<ffi.Pointer<git_status_list>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
  ) {
    return _git_status_list_new(
      out,
      repo,
      opts,
    );
  }

  late final _git_status_list_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_status_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_status_options>)>>('git_status_list_new');
  late final _git_status_list_new = _git_status_list_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_status_list>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_status_options>)>();

  /// Gets the count of status entries in this list.
  ///
  /// If there are no changes in status (at least according the options given
  /// when the status list was created), this can return 0.
  ///
  /// @param statuslist Existing status list object
  /// @return the number of status entries
  int git_status_list_entrycount(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_entrycount(
      statuslist,
    );
  }

  late final _git_status_list_entrycountPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_status_list>)>>(
      'git_status_list_entrycount');
  late final _git_status_list_entrycount = _git_status_list_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_status_list>)>();

  /// Get a pointer to one of the entries in the status list.
  ///
  /// The entry is not modifiable and should not be freed.
  ///
  /// @param statuslist Existing status list object
  /// @param idx Position of the entry
  /// @return Pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_status_entry> git_status_byindex(
    ffi.Pointer<git_status_list> statuslist,
    int idx,
  ) {
    return _git_status_byindex(
      statuslist,
      idx,
    );
  }

  late final _git_status_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_status_entry> Function(
              ffi.Pointer<git_status_list>, ffi.Size)>>('git_status_byindex');
  late final _git_status_byindex = _git_status_byindexPtr.asFunction<
      ffi.Pointer<git_status_entry> Function(
          ffi.Pointer<git_status_list>, int)>();

  /// Free an existing status list
  ///
  /// @param statuslist Existing status list object
  void git_status_list_free(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_free(
      statuslist,
    );
  }

  late final _git_status_list_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_status_list>)>>(
      'git_status_list_free');
  late final _git_status_list_free = _git_status_list_freePtr
      .asFunction<void Function(ffi.Pointer<git_status_list>)>();

  /// Test if the ignore rules apply to a given file.
  ///
  /// This function checks the ignore rules to see if they would apply to the
  /// given file.  This indicates if the file would be ignored regardless of
  /// whether the file is already in the index or committed to the repository.
  ///
  /// One way to think of this is if you were to do "git add ." on the
  /// directory containing the file, would it be added or not?
  ///
  /// @param ignored Boolean returning 0 if the file is not ignored, 1 if it is
  /// @param repo A repository object
  /// @param path The file to check ignores for, rooted at the repo's workdir.
  /// @return 0 if ignore rules could be processed for the file (regardless
  /// of whether it exists or not), or an error < 0 if they could not.
  int git_status_should_ignore(
    ffi.Pointer<ffi.Int> ignored,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_status_should_ignore(
      ignored,
      repo,
      path,
    );
  }

  late final _git_status_should_ignorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_status_should_ignore');
  late final _git_status_should_ignore =
      _git_status_should_ignorePtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Initialize git_submodule_update_options structure
  ///
  /// Initializes a `git_submodule_update_options` with default values. Equivalent to
  /// creating an instance with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_submodule_update_options` struct to initialize.
  /// @param version The struct version; pass `GIT_SUBMODULE_UPDATE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_submodule_update_options_init(
    ffi.Pointer<git_submodule_update_options> opts,
    int version,
  ) {
    return _git_submodule_update_options_init(
      opts,
      version,
    );
  }

  late final _git_submodule_update_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_submodule_update_options>,
              ffi.UnsignedInt)>>('git_submodule_update_options_init');
  late final _git_submodule_update_options_init =
      _git_submodule_update_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_submodule_update_options>, int)>();

  /// Update a submodule. This will clone a missing submodule and
  /// checkout the subrepository to the commit specified in the index of
  /// the containing repository. If the submodule repository doesn't contain
  /// the target commit (e.g. because fetchRecurseSubmodules isn't set), then
  /// the submodule is fetched using the fetch options supplied in options.
  ///
  /// @param submodule Submodule object
  /// @param init If the submodule is not initialized, setting this flag to true
  /// will initialize the submodule before updating. Otherwise, this will
  /// return an error if attempting to update an uninitialized repository.
  /// but setting this to true forces them to be updated.
  /// @param options configuration options for the update.  If NULL, the
  /// function works as though GIT_SUBMODULE_UPDATE_OPTIONS_INIT was passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message).
  int git_submodule_update(
    ffi.Pointer<git_submodule> submodule,
    int init,
    ffi.Pointer<git_submodule_update_options> options,
  ) {
    return _git_submodule_update(
      submodule,
      init,
      options,
    );
  }

  late final _git_submodule_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_submodule>, ffi.Int,
                  ffi.Pointer<git_submodule_update_options>)>>(
      'git_submodule_update');
  late final _git_submodule_update = _git_submodule_updatePtr.asFunction<
      int Function(ffi.Pointer<git_submodule>, int,
          ffi.Pointer<git_submodule_update_options>)>();

  /// Lookup submodule information by name or path.
  ///
  /// Given either the submodule name or path (they are usually the same), this
  /// returns a structure describing the submodule.
  ///
  /// There are two expected error scenarios:
  ///
  /// - The submodule is not mentioned in the HEAD, the index, and the config,
  /// but does "exist" in the working directory (i.e. there is a subdirectory
  /// that appears to be a Git repository).  In this case, this function
  /// returns GIT_EEXISTS to indicate a sub-repository exists but not in a
  /// state where a git_submodule can be instantiated.
  /// - The submodule is not mentioned in the HEAD, index, or config and the
  /// working directory doesn't contain a value git repo at that path.
  /// There may or may not be anything else at that path, but nothing that
  /// looks like a submodule.  In this case, this returns GIT_ENOTFOUND.
  ///
  /// You must call `git_submodule_free` when done with the submodule.
  ///
  /// @param out Output ptr to submodule; pass NULL to just get return code
  /// @param repo The parent repository
  /// @param name The name of or path to the submodule; trailing slashes okay
  /// @return 0 on success, GIT_ENOTFOUND if submodule does not exist,
  /// GIT_EEXISTS if a repository is found in working directory only,
  /// -1 on other errors.
  int git_submodule_lookup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_submodule_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_submodule_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_submodule>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_lookup');
  late final _git_submodule_lookup = _git_submodule_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_submodule>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Create an in-memory copy of a submodule. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the submodule.
  /// @param source Original submodule to copy.
  /// @return 0
  int git_submodule_dup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_submodule> source,
  ) {
    return _git_submodule_dup(
      out,
      source,
    );
  }

  late final _git_submodule_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_submodule>>,
              ffi.Pointer<git_submodule>)>>('git_submodule_dup');
  late final _git_submodule_dup = _git_submodule_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_submodule>>,
          ffi.Pointer<git_submodule>)>();

  /// Release a submodule
  ///
  /// @param submodule Submodule object
  void git_submodule_free(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_free(
      submodule,
    );
  }

  late final _git_submodule_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_submodule>)>>(
      'git_submodule_free');
  late final _git_submodule_free = _git_submodule_freePtr
      .asFunction<void Function(ffi.Pointer<git_submodule>)>();

  /// Iterate over all tracked submodules of a repository.
  ///
  /// See the note on `git_submodule` above.  This iterates over the tracked
  /// submodules as described therein.
  ///
  /// If you are concerned about items in the working directory that look like
  /// submodules but are not tracked, the diff API will generate a diff record
  /// for workdir items that look like submodules but are not tracked, showing
  /// them as added in the workdir.  Also, the status API will treat the entire
  /// subdirectory of a contained git repo as a single GIT_STATUS_WT_NEW item.
  ///
  /// @param repo The repository
  /// @param callback Function to be called with the name of each submodule.
  /// Return a non-zero value to terminate the iteration.
  /// @param payload Extra data to pass to callback
  /// @return 0 on success, -1 on error, or non-zero return value of callback
  int git_submodule_foreach(
    ffi.Pointer<git_repository> repo,
    git_submodule_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_submodule_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_submodule_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_submodule_cb,
              ffi.Pointer<ffi.Void>)>>('git_submodule_foreach');
  late final _git_submodule_foreach = _git_submodule_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, git_submodule_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Set up a new git submodule for checkout.
  ///
  /// This does "git submodule add" up to the fetch and checkout of the
  /// submodule contents.  It preps a new submodule, creates an entry in
  /// .gitmodules and creates an empty initialized repository either at the
  /// given path in the working directory or in .git/modules with a gitlink
  /// from the working directory to the new repo.
  ///
  /// To fully emulate "git submodule add" call this function, then open the
  /// submodule repo and perform the clone step as needed (if you don't need
  /// anything custom see `git_submodule_add_clone()`). Lastly, call
  /// `git_submodule_add_finalize()` to wrap up adding the new submodule and
  /// .gitmodules to the index to be ready to commit.
  ///
  /// You must call `git_submodule_free` on the submodule object when done.
  ///
  /// @param out The newly created submodule ready to open for clone
  /// @param repo The repository in which you want to create the submodule
  /// @param url URL for the submodule's remote
  /// @param path Path at which the submodule should be created
  /// @param use_gitlink Should workdir contain a gitlink to the repo in
  /// .git/modules vs. repo directly in workdir.
  /// @return 0 on success, GIT_EEXISTS if submodule already exists,
  /// -1 on other errors.
  int git_submodule_add_setup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> path,
    int use_gitlink,
  ) {
    return _git_submodule_add_setup(
      out,
      repo,
      url,
      path,
      use_gitlink,
    );
  }

  late final _git_submodule_add_setupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_submodule>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_submodule_add_setup');
  late final _git_submodule_add_setup = _git_submodule_add_setupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_submodule>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Perform the clone step for a newly created submodule.
  ///
  /// This performs the necessary `git_clone` to setup a newly-created submodule.
  ///
  /// @param out The newly created repository object. Optional.
  /// @param submodule The submodule currently waiting for its clone.
  /// @param opts The options to use.
  ///
  /// @return 0 on success, -1 on other errors (see git_clone).
  int git_submodule_clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_submodule> submodule,
    ffi.Pointer<git_submodule_update_options> opts,
  ) {
    return _git_submodule_clone(
      out,
      submodule,
      opts,
    );
  }

  late final _git_submodule_clonePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_repository>>,
                  ffi.Pointer<git_submodule>,
                  ffi.Pointer<git_submodule_update_options>)>>(
      'git_submodule_clone');
  late final _git_submodule_clone = _git_submodule_clonePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<git_submodule>,
          ffi.Pointer<git_submodule_update_options>)>();

  /// Resolve the setup of a new git submodule.
  ///
  /// This should be called on a submodule once you have called add setup
  /// and done the clone of the submodule.  This adds the .gitmodules file
  /// and the newly cloned submodule to the index to be ready to be committed
  /// (but doesn't actually do the commit).
  ///
  /// @param submodule The submodule to finish adding.
  /// @return 0 or an error code.
  int git_submodule_add_finalize(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_add_finalize(
      submodule,
    );
  }

  late final _git_submodule_add_finalizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_submodule>)>>(
          'git_submodule_add_finalize');
  late final _git_submodule_add_finalize = _git_submodule_add_finalizePtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Add current submodule HEAD commit to index of superproject.
  ///
  /// @param submodule The submodule to add to the index
  /// @param write_index Boolean if this should immediately write the index
  /// file.  If you pass this as false, you will have to get the
  /// git_index and explicitly call `git_index_write()` on it to
  /// save the change.
  /// @return 0 on success, <0 on failure
  int git_submodule_add_to_index(
    ffi.Pointer<git_submodule> submodule,
    int write_index,
  ) {
    return _git_submodule_add_to_index(
      submodule,
      write_index,
    );
  }

  late final _git_submodule_add_to_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_submodule>,
              ffi.Int)>>('git_submodule_add_to_index');
  late final _git_submodule_add_to_index = _git_submodule_add_to_indexPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>, int)>();

  /// Get the containing repository for a submodule.
  ///
  /// This returns a pointer to the repository that contains the submodule.
  /// This is a just a reference to the repository that was passed to the
  /// original `git_submodule_lookup()` call, so if that repository has been
  /// freed, then this may be a dangling reference.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to `git_repository`
  ffi.Pointer<git_repository> git_submodule_owner(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_owner(
      submodule,
    );
  }

  late final _git_submodule_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_owner');
  late final _git_submodule_owner = _git_submodule_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_submodule>)>();

  /// Get the name of submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule name
  ffi.Pointer<ffi.Char> git_submodule_name(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_name(
      submodule,
    );
  }

  late final _git_submodule_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_name');
  late final _git_submodule_name = _git_submodule_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Get the path to the submodule.
  ///
  /// The path is almost always the same as the submodule name, but the
  /// two are actually not required to match.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule path
  ffi.Pointer<ffi.Char> git_submodule_path(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_path(
      submodule,
    );
  }

  late final _git_submodule_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_path');
  late final _git_submodule_path = _git_submodule_pathPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Get the URL for the submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule url
  ffi.Pointer<ffi.Char> git_submodule_url(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_url(
      submodule,
    );
  }

  late final _git_submodule_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_url');
  late final _git_submodule_url = _git_submodule_urlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Resolve a submodule url relative to the given repository.
  ///
  /// @param out buffer to store the absolute submodule url in
  /// @param repo Pointer to repository object
  /// @param url Relative url
  /// @return 0 or an error code
  int git_submodule_resolve_url(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_submodule_resolve_url(
      out,
      repo,
      url,
    );
  }

  late final _git_submodule_resolve_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_resolve_url');
  late final _git_submodule_resolve_url =
      _git_submodule_resolve_urlPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the branch for the submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule branch
  ffi.Pointer<ffi.Char> git_submodule_branch(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_branch(
      submodule,
    );
  }

  late final _git_submodule_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_branch');
  late final _git_submodule_branch = _git_submodule_branchPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Set the branch for the submodule in the configuration
  ///
  /// After calling this, you may wish to call `git_submodule_sync()` to
  /// write the changes to the checked out submodule repository.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param branch Branch that should be used for the submodule
  /// @return 0 on success, <0 on failure
  int git_submodule_set_branch(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> branch,
  ) {
    return _git_submodule_set_branch(
      repo,
      name,
      branch,
    );
  }

  late final _git_submodule_set_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_set_branch');
  late final _git_submodule_set_branch =
      _git_submodule_set_branchPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Set the URL for the submodule in the configuration
  ///
  ///
  /// After calling this, you may wish to call `git_submodule_sync()` to
  /// write the changes to the checked out submodule repository.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param url URL that should be used for the submodule
  /// @return 0 on success, <0 on failure
  int git_submodule_set_url(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_submodule_set_url(
      repo,
      name,
      url,
    );
  }

  late final _git_submodule_set_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_set_url');
  late final _git_submodule_set_url = _git_submodule_set_urlPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the OID for the submodule in the index.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not in index.
  ffi.Pointer<git_oid> git_submodule_index_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_index_id(
      submodule,
    );
  }

  late final _git_submodule_index_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_index_id');
  late final _git_submodule_index_id = _git_submodule_index_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule>)>();

  /// Get the OID for the submodule in the current HEAD tree.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not in the HEAD.
  ffi.Pointer<git_oid> git_submodule_head_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_head_id(
      submodule,
    );
  }

  late final _git_submodule_head_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_head_id');
  late final _git_submodule_head_id = _git_submodule_head_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule>)>();

  /// Get the OID for the submodule in the current working directory.
  ///
  /// This returns the OID that corresponds to looking up 'HEAD' in the checked
  /// out submodule.  If there are pending changes in the index or anything
  /// else, this won't notice that.  You should call `git_submodule_status()`
  /// for a more complete picture about the state of the working directory.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not checked out.
  ffi.Pointer<git_oid> git_submodule_wd_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_wd_id(
      submodule,
    );
  }

  late final _git_submodule_wd_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_wd_id');
  late final _git_submodule_wd_id = _git_submodule_wd_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule>)>();

  /// Get the ignore rule that will be used for the submodule.
  ///
  /// These values control the behavior of `git_submodule_status()` for this
  /// submodule.  There are four ignore values:
  ///
  /// - **GIT_SUBMODULE_IGNORE_NONE** will consider any change to the contents
  /// of the submodule from a clean checkout to be dirty, including the
  /// addition of untracked files.  This is the default if unspecified.
  /// - **GIT_SUBMODULE_IGNORE_UNTRACKED** examines the contents of the
  /// working tree (i.e. call `git_status_foreach()` on the submodule) but
  /// UNTRACKED files will not count as making the submodule dirty.
  /// - **GIT_SUBMODULE_IGNORE_DIRTY** means to only check if the HEAD of the
  /// submodule has moved for status.  This is fast since it does not need to
  /// scan the working tree of the submodule at all.
  /// - **GIT_SUBMODULE_IGNORE_ALL** means not to open the submodule repo.
  /// The working directory will be consider clean so long as there is a
  /// checked out version present.
  ///
  /// @param submodule The submodule to check
  /// @return The current git_submodule_ignore_t valyue what will be used for
  /// this submodule.
  git_submodule_ignore_t git_submodule_ignore(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return git_submodule_ignore_t.fromValue(_git_submodule_ignore(
      submodule,
    ));
  }

  late final _git_submodule_ignorePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_submodule>)>>(
          'git_submodule_ignore');
  late final _git_submodule_ignore = _git_submodule_ignorePtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Set the ignore rule for the submodule in the configuration
  ///
  /// This does not affect any currently-loaded instances.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submdule
  /// @param ignore The new value for the ignore rule
  /// @return 0 or an error code
  int git_submodule_set_ignore(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    git_submodule_ignore_t ignore,
  ) {
    return _git_submodule_set_ignore(
      repo,
      name,
      ignore.value,
    );
  }

  late final _git_submodule_set_ignorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_submodule_set_ignore');
  late final _git_submodule_set_ignore =
      _git_submodule_set_ignorePtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the update rule that will be used for the submodule.
  ///
  /// This value controls the behavior of the `git submodule update` command.
  /// There are four useful values documented with `git_submodule_update_t`.
  ///
  /// @param submodule The submodule to check
  /// @return The current git_submodule_update_t value that will be used
  /// for this submodule.
  git_submodule_update_t git_submodule_update_strategy(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return git_submodule_update_t.fromValue(_git_submodule_update_strategy(
      submodule,
    ));
  }

  late final _git_submodule_update_strategyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_update_strategy');
  late final _git_submodule_update_strategy = _git_submodule_update_strategyPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Set the update rule for the submodule in the configuration
  ///
  /// This setting won't affect any existing instances.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param update The new value to use
  /// @return 0 or an error code
  int git_submodule_set_update(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    git_submodule_update_t update,
  ) {
    return _git_submodule_set_update(
      repo,
      name,
      update.value,
    );
  }

  late final _git_submodule_set_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_submodule_set_update');
  late final _git_submodule_set_update =
      _git_submodule_set_updatePtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Read the fetchRecurseSubmodules rule for a submodule.
  ///
  /// This accesses the submodule.<name>.fetchRecurseSubmodules value for
  /// the submodule that controls fetching behavior for the submodule.
  ///
  /// Note that at this time, libgit2 does not honor this setting and the
  /// fetch functionality current ignores submodules.
  ///
  /// @param submodule the submodule to examine
  /// @return the submodule recursion configuration
  git_submodule_recurse_t git_submodule_fetch_recurse_submodules(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return git_submodule_recurse_t
        .fromValue(_git_submodule_fetch_recurse_submodules(
      submodule,
    ));
  }

  late final _git_submodule_fetch_recurse_submodulesPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<git_submodule>)>>(
      'git_submodule_fetch_recurse_submodules');
  late final _git_submodule_fetch_recurse_submodules =
      _git_submodule_fetch_recurse_submodulesPtr
          .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Set the fetchRecurseSubmodules rule for a submodule in the configuration
  ///
  /// This setting won't affect any existing instances.
  ///
  /// @param repo the repository to affect
  /// @param name the submodule to configure
  /// @param fetch_recurse_submodules the submodule recursion configuration
  /// @return old value for fetchRecurseSubmodules
  int git_submodule_set_fetch_recurse_submodules(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    git_submodule_recurse_t fetch_recurse_submodules,
  ) {
    return _git_submodule_set_fetch_recurse_submodules(
      repo,
      name,
      fetch_recurse_submodules.value,
    );
  }

  late final _git_submodule_set_fetch_recurse_submodulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_submodule_set_fetch_recurse_submodules');
  late final _git_submodule_set_fetch_recurse_submodules =
      _git_submodule_set_fetch_recurse_submodulesPtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Copy submodule info into ".git/config" file.
  ///
  /// Just like "git submodule init", this copies information about the
  /// submodule into ".git/config".  You can use the accessor functions
  /// above to alter the in-memory git_submodule object and control what
  /// is written to the config, overriding what is in .gitmodules.
  ///
  /// @param submodule The submodule to write into the superproject config
  /// @param overwrite By default, existing entries will not be overwritten,
  /// but setting this to true forces them to be updated.
  /// @return 0 on success, <0 on failure.
  int git_submodule_init(
    ffi.Pointer<git_submodule> submodule,
    int overwrite,
  ) {
    return _git_submodule_init(
      submodule,
      overwrite,
    );
  }

  late final _git_submodule_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_submodule>, ffi.Int)>>('git_submodule_init');
  late final _git_submodule_init = _git_submodule_initPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>, int)>();

  /// Set up the subrepository for a submodule in preparation for clone.
  ///
  /// This function can be called to init and set up a submodule
  /// repository from a submodule in preparation to clone it from
  /// its remote.
  ///
  /// @param out Output pointer to the created git repository.
  /// @param sm The submodule to create a new subrepository from.
  /// @param use_gitlink Should the workdir contain a gitlink to
  /// the repo in .git/modules vs. repo directly in workdir.
  /// @return 0 on success, <0 on failure.
  int git_submodule_repo_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_submodule> sm,
    int use_gitlink,
  ) {
    return _git_submodule_repo_init(
      out,
      sm,
      use_gitlink,
    );
  }

  late final _git_submodule_repo_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_submodule>, ffi.Int)>>('git_submodule_repo_init');
  late final _git_submodule_repo_init = _git_submodule_repo_initPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<git_submodule>, int)>();

  /// Copy submodule remote info into submodule repo.
  ///
  /// This copies the information about the submodules URL into the checked out
  /// submodule config, acting like "git submodule sync".  This is useful if
  /// you have altered the URL for the submodule (or it has been altered by a
  /// fetch of upstream changes) and you need to update your local repo.
  ///
  /// @param submodule The submodule to copy.
  /// @return 0 or an error code.
  int git_submodule_sync(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_sync(
      submodule,
    );
  }

  late final _git_submodule_syncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_submodule>)>>(
          'git_submodule_sync');
  late final _git_submodule_sync = _git_submodule_syncPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Open the repository for a submodule.
  ///
  /// This is a newly opened repository object.  The caller is responsible for
  /// calling `git_repository_free()` on it when done.  Multiple calls to this
  /// function will return distinct `git_repository` objects.  This will only
  /// work if the submodule is checked out into the working directory.
  ///
  /// @param repo Pointer to the submodule repo which was opened
  /// @param submodule Submodule to be opened
  /// @return 0 on success, <0 if submodule repo could not be opened.
  int git_submodule_open(
    ffi.Pointer<ffi.Pointer<git_repository>> repo,
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_open(
      repo,
      submodule,
    );
  }

  late final _git_submodule_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_submodule>)>>('git_submodule_open');
  late final _git_submodule_open = _git_submodule_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<git_submodule>)>();

  /// Reread submodule info from config, index, and HEAD.
  ///
  /// Call this to reread cached submodule information for this submodule if
  /// you have reason to believe that it has changed.
  ///
  /// @param submodule The submodule to reload
  /// @param force Force reload even if the data doesn't seem out of date
  /// @return 0 on success, <0 on error
  int git_submodule_reload(
    ffi.Pointer<git_submodule> submodule,
    int force,
  ) {
    return _git_submodule_reload(
      submodule,
      force,
    );
  }

  late final _git_submodule_reloadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_submodule>, ffi.Int)>>('git_submodule_reload');
  late final _git_submodule_reload = _git_submodule_reloadPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>, int)>();

  /// Get the status for a submodule.
  ///
  /// This looks at a submodule and tries to determine the status.  It
  /// will return a combination of the `GIT_SUBMODULE_STATUS` values above.
  /// How deeply it examines the working directory to do this will depend
  /// on the `git_submodule_ignore_t` value for the submodule.
  ///
  /// @param status Combination of `GIT_SUBMODULE_STATUS` flags
  /// @param repo the repository in which to look
  /// @param name name of the submodule
  /// @param ignore the ignore rules to follow
  /// @return 0 on success, <0 on error
  int git_submodule_status(
    ffi.Pointer<ffi.UnsignedInt> status,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    git_submodule_ignore_t ignore,
  ) {
    return _git_submodule_status(
      status,
      repo,
      name,
      ignore.value,
    );
  }

  late final _git_submodule_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_submodule_status');
  late final _git_submodule_status = _git_submodule_statusPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Get the locations of submodule information.
  ///
  /// This is a bit like a very lightweight version of `git_submodule_status`.
  /// It just returns a made of the first four submodule status values (i.e.
  /// the ones like GIT_SUBMODULE_STATUS_IN_HEAD, etc) that tell you where the
  /// submodule data comes from (i.e. the HEAD commit, gitmodules file, etc.).
  /// This can be useful if you want to know if the submodule is present in the
  /// working directory at this point in time, etc.
  ///
  /// @param location_status Combination of first four `GIT_SUBMODULE_STATUS` flags
  /// @param submodule Submodule for which to get status
  /// @return 0 on success, <0 on error
  int git_submodule_location(
    ffi.Pointer<ffi.UnsignedInt> location_status,
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_location(
      location_status,
      submodule,
    );
  }

  late final _git_submodule_locationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_submodule>)>>('git_submodule_location');
  late final _git_submodule_location = _git_submodule_locationPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<git_submodule>)>();

  /// Lookup a tag object from the repository.
  ///
  /// @param out pointer to the looked up tag
  /// @param repo the repo to use when locating the tag.
  /// @param id identity of the tag to locate.
  /// @return 0 or an error code
  int git_tag_lookup(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tag_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_tag_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tag>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_tag_lookup');
  late final _git_tag_lookup = _git_tag_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tag>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a tag object from the repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param out pointer to the looked up tag
  /// @param repo the repo to use when locating the tag.
  /// @param id identity of the tag to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_tag_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_tag_lookup_prefix(
      out,
      repo,
      id,
      len,
    );
  }

  late final _git_tag_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tag>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_tag_lookup_prefix');
  late final _git_tag_lookup_prefix = _git_tag_lookup_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tag>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open tag
  ///
  /// You can no longer use the git_tag pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you are through with a tag to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tag the tag to close
  void git_tag_free(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_free(
      tag,
    );
  }

  late final _git_tag_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_tag>)>>(
          'git_tag_free');
  late final _git_tag_free =
      _git_tag_freePtr.asFunction<void Function(ffi.Pointer<git_tag>)>();

  /// Get the id of a tag.
  ///
  /// @param tag a previously loaded tag.
  /// @return object identity for the tag.
  ffi.Pointer<git_oid> git_tag_id(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_id(
      tag,
    );
  }

  late final _git_tag_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag>)>>('git_tag_id');
  late final _git_tag_id = _git_tag_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag>)>();

  /// Get the repository that contains the tag.
  ///
  /// @param tag A previously loaded tag.
  /// @return Repository that contains this tag.
  ffi.Pointer<git_repository> git_tag_owner(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_owner(
      tag,
    );
  }

  late final _git_tag_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_tag>)>>('git_tag_owner');
  late final _git_tag_owner = _git_tag_ownerPtr
      .asFunction<ffi.Pointer<git_repository> Function(ffi.Pointer<git_tag>)>();

  /// Get the tagged object of a tag
  ///
  /// This method performs a repository lookup for the
  /// given object and returns it
  ///
  /// @param target_out pointer where to store the target
  /// @param tag a previously loaded tag.
  /// @return 0 or an error code
  int git_tag_target(
    ffi.Pointer<ffi.Pointer<git_object>> target_out,
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target(
      target_out,
      tag,
    );
  }

  late final _git_tag_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_tag>)>>('git_tag_target');
  late final _git_tag_target = _git_tag_targetPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>, ffi.Pointer<git_tag>)>();

  /// Get the OID of the tagged object of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return pointer to the OID
  ffi.Pointer<git_oid> git_tag_target_id(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target_id(
      tag,
    );
  }

  late final _git_tag_target_idPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag>)>>(
      'git_tag_target_id');
  late final _git_tag_target_id = _git_tag_target_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag>)>();

  /// Get the type of a tag's tagged object
  ///
  /// @param tag a previously loaded tag.
  /// @return type of the tagged object
  git_object_t git_tag_target_type(
    ffi.Pointer<git_tag> tag,
  ) {
    return git_object_t.fromValue(_git_tag_target_type(
      tag,
    ));
  }

  late final _git_tag_target_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_tag>)>>(
          'git_tag_target_type');
  late final _git_tag_target_type =
      _git_tag_target_typePtr.asFunction<int Function(ffi.Pointer<git_tag>)>();

  /// Get the name of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return name of the tag
  ffi.Pointer<ffi.Char> git_tag_name(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_name(
      tag,
    );
  }

  late final _git_tag_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_tag>)>>('git_tag_name');
  late final _git_tag_name = _git_tag_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tag>)>();

  /// Get the tagger (author) of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return reference to the tag's author or NULL when unspecified
  ffi.Pointer<git_signature> git_tag_tagger(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_tagger(
      tag,
    );
  }

  late final _git_tag_taggerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_tag>)>>('git_tag_tagger');
  late final _git_tag_tagger = _git_tag_taggerPtr
      .asFunction<ffi.Pointer<git_signature> Function(ffi.Pointer<git_tag>)>();

  /// Get the message of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return message of the tag or NULL when unspecified
  ffi.Pointer<ffi.Char> git_tag_message(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_message(
      tag,
    );
  }

  late final _git_tag_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_tag>)>>('git_tag_message');
  late final _git_tag_message = _git_tag_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tag>)>();

  /// Create a new tag in the repository from an object
  ///
  /// A new reference will also be created pointing to
  /// this tag object. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The message will not be cleaned up. This can be achieved
  /// through `git_message_prettify()`.
  ///
  /// The tag name will be checked for validity. You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// @param oid Pointer where to store the OID of the
  /// newly created tag. If the tag already exists, this parameter
  /// will be the oid of the existing tag, and the function will
  /// return a GIT_EEXISTS error code.
  ///
  /// @param repo Repository where to store the tag
  ///
  /// @param tag_name Name for the tag; this name is validated
  /// for consistency. It should also not conflict with an
  /// already existing tag name
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param tagger Signature of the tagger for this tag, and
  /// of the tagging time
  ///
  /// @param message Full message for this tag
  ///
  /// @param force Overwrite existing references
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  /// A tag object is written to the ODB, and a proper reference
  /// is written in the /refs/tags folder, pointing to it
  int git_tag_create(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_signature> tagger,
    ffi.Pointer<ffi.Char> message,
    int force,
  ) {
    return _git_tag_create(
      oid,
      repo,
      tag_name,
      target,
      tagger,
      message,
      force,
    );
  }

  late final _git_tag_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_tag_create');
  late final _git_tag_create = _git_tag_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_object>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Create a new tag in the object database pointing to a git_object
  ///
  /// The message will not be cleaned up. This can be achieved
  /// through `git_message_prettify()`.
  ///
  /// @param oid Pointer where to store the OID of the
  /// newly created tag
  ///
  /// @param repo Repository where to store the tag
  ///
  /// @param tag_name Name for the tag
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param tagger Signature of the tagger for this tag, and
  /// of the tagging time
  ///
  /// @param message Full message for this tag
  ///
  /// @return 0 on success or an error code
  int git_tag_annotation_create(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_signature> tagger,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _git_tag_annotation_create(
      oid,
      repo,
      tag_name,
      target,
      tagger,
      message,
    );
  }

  late final _git_tag_annotation_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_tag_annotation_create');
  late final _git_tag_annotation_create =
      _git_tag_annotation_createPtr.asFunction<
          int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new tag in the repository from a buffer
  ///
  /// @param oid Pointer where to store the OID of the newly created tag
  /// @param repo Repository where to store the tag
  /// @param buffer Raw tag data
  /// @param force Overwrite existing tags
  /// @return 0 on success; error code otherwise
  int git_tag_create_from_buffer(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> buffer,
    int force,
  ) {
    return _git_tag_create_from_buffer(
      oid,
      repo,
      buffer,
      force,
    );
  }

  late final _git_tag_create_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_tag_create_from_buffer');
  late final _git_tag_create_from_buffer =
      _git_tag_create_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Create a new lightweight tag pointing at a target object
  ///
  /// A new direct reference will be created pointing to
  /// this target object. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The tag name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param oid Pointer where to store the OID of the provided
  /// target object. If the tag already exists, this parameter
  /// will be filled with the oid of the existing pointed object
  /// and the function will return a GIT_EEXISTS error code.
  ///
  /// @param repo Repository where to store the lightweight tag
  ///
  /// @param tag_name Name for the tag; this name is validated
  /// for consistency. It should also not conflict with an
  /// already existing tag name
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param force Overwrite existing references
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  /// A proper reference is written in the /refs/tags folder,
  /// pointing to the provided target object
  int git_tag_create_lightweight(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
    ffi.Pointer<git_object> target,
    int force,
  ) {
    return _git_tag_create_lightweight(
      oid,
      repo,
      tag_name,
      target,
      force,
    );
  }

  late final _git_tag_create_lightweightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Int)>>('git_tag_create_lightweight');
  late final _git_tag_create_lightweight =
      _git_tag_create_lightweightPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_object>, int)>();

  /// Delete an existing tag reference.
  ///
  /// The tag name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param repo Repository where lives the tag
  ///
  /// @param tag_name Name of the tag to be deleted;
  /// this name is validated for consistency.
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_tag_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
  ) {
    return _git_tag_delete(
      repo,
      tag_name,
    );
  }

  late final _git_tag_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_tag_delete');
  late final _git_tag_delete = _git_tag_deletePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Fill a list with all the tags in the Repository
  ///
  /// The string array will be filled with the names of the
  /// matching tags; these values are owned by the user and
  /// should be free'd manually when no longer needed, using
  /// `git_strarray_free`.
  ///
  /// @param tag_names Pointer to a git_strarray structure where
  /// the tag names will be stored
  /// @param repo Repository where to find the tags
  /// @return 0 or an error code
  int git_tag_list(
    ffi.Pointer<git_strarray> tag_names,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_tag_list(
      tag_names,
      repo,
    );
  }

  late final _git_tag_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_tag_list');
  late final _git_tag_list = _git_tag_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Fill a list with all the tags in the Repository
  /// which name match a defined pattern
  ///
  /// If an empty pattern is provided, all the tags
  /// will be returned.
  ///
  /// The string array will be filled with the names of the
  /// matching tags; these values are owned by the user and
  /// should be free'd manually when no longer needed, using
  /// `git_strarray_free`.
  ///
  /// @param tag_names Pointer to a git_strarray structure where
  /// the tag names will be stored
  /// @param pattern Standard fnmatch pattern
  /// @param repo Repository where to find the tags
  /// @return 0 or an error code
  int git_tag_list_match(
    ffi.Pointer<git_strarray> tag_names,
    ffi.Pointer<ffi.Char> pattern,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_tag_list_match(
      tag_names,
      pattern,
      repo,
    );
  }

  late final _git_tag_list_matchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_repository>)>>('git_tag_list_match');
  late final _git_tag_list_match = _git_tag_list_matchPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_repository>)>();

  /// Call callback `cb' for each tag in the repository
  ///
  /// @param repo Repository
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success or an error code
  int git_tag_foreach(
    ffi.Pointer<git_repository> repo,
    git_tag_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_tag_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_tag_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_tag_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_tag_foreach');
  late final _git_tag_foreach = _git_tag_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, git_tag_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Recursively peel a tag until a non tag git_object is found
  ///
  /// The retrieved `tag_target` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// @param tag_target_out Pointer to the peeled git_object
  /// @param tag The tag to be processed
  /// @return 0 or an error code
  int git_tag_peel(
    ffi.Pointer<ffi.Pointer<git_object>> tag_target_out,
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_peel(
      tag_target_out,
      tag,
    );
  }

  late final _git_tag_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_tag>)>>('git_tag_peel');
  late final _git_tag_peel = _git_tag_peelPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>, ffi.Pointer<git_tag>)>();

  /// Create an in-memory copy of a tag. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the tag
  /// @param source Original tag to copy
  /// @return 0
  int git_tag_dup(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_tag> source,
  ) {
    return _git_tag_dup(
      out,
      source,
    );
  }

  late final _git_tag_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tag>>,
              ffi.Pointer<git_tag>)>>('git_tag_dup');
  late final _git_tag_dup = _git_tag_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tag>>, ffi.Pointer<git_tag>)>();

  /// Determine whether a tag name is valid, meaning that (when prefixed
  /// with `refs/tags/`) that it is a valid reference name, and that any
  /// additional tag name restrictions are imposed (eg, it cannot start
  /// with a `-`).
  ///
  /// @param valid output pointer to set with validity of given tag name
  /// @param name a tag name to test
  /// @return 0 on success or an error code
  int git_tag_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_tag_name_is_valid(
      valid,
      name,
    );
  }

  late final _git_tag_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_tag_name_is_valid');
  late final _git_tag_name_is_valid = _git_tag_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Create a new transaction object
  ///
  /// This does not lock anything, but sets up the transaction object to
  /// know from which repository to lock.
  ///
  /// @param out the resulting transaction
  /// @param repo the repository in which to lock
  /// @return 0 or an error code
  int git_transaction_new(
    ffi.Pointer<ffi.Pointer<git_transaction>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_transaction_new(
      out,
      repo,
    );
  }

  late final _git_transaction_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
              ffi.Pointer<git_repository>)>>('git_transaction_new');
  late final _git_transaction_new = _git_transaction_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
          ffi.Pointer<git_repository>)>();

  /// Lock a reference
  ///
  /// Lock the specified reference. This is the first step to updating a
  /// reference.
  ///
  /// @param tx the transaction
  /// @param refname the reference to lock
  /// @return 0 or an error message
  int git_transaction_lock_ref(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_transaction_lock_ref(
      tx,
      refname,
    );
  }

  late final _git_transaction_lock_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_lock_ref');
  late final _git_transaction_lock_ref =
      _git_transaction_lock_refPtr.asFunction<
          int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>)>();

  /// Set the target of a reference
  ///
  /// Set the target of the specified reference. This reference must be
  /// locked.
  ///
  /// @param tx the transaction
  /// @param refname reference to update
  /// @param target target to set the reference to
  /// @param sig signature to use in the reflog; pass NULL to read the identity from the config
  /// @param msg message to use in the reflog
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_target(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<git_oid> target,
    ffi.Pointer<git_signature> sig,
    ffi.Pointer<ffi.Char> msg,
  ) {
    return _git_transaction_set_target(
      tx,
      refname,
      target,
      sig,
      msg,
    );
  }

  late final _git_transaction_set_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_set_target');
  late final _git_transaction_set_target =
      _git_transaction_set_targetPtr.asFunction<
          int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>();

  /// Set the target of a reference
  ///
  /// Set the target of the specified reference. This reference must be
  /// locked.
  ///
  /// @param tx the transaction
  /// @param refname reference to update
  /// @param target target to set the reference to
  /// @param sig signature to use in the reflog; pass NULL to read the identity from the config
  /// @param msg message to use in the reflog
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_symbolic_target(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<git_signature> sig,
    ffi.Pointer<ffi.Char> msg,
  ) {
    return _git_transaction_set_symbolic_target(
      tx,
      refname,
      target,
      sig,
      msg,
    );
  }

  late final _git_transaction_set_symbolic_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_set_symbolic_target');
  late final _git_transaction_set_symbolic_target =
      _git_transaction_set_symbolic_targetPtr.asFunction<
          int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>();

  /// Set the reflog of a reference
  ///
  /// Set the specified reference's reflog. If this is combined with
  /// setting the target, that update won't be written to the reflog.
  ///
  /// @param tx the transaction
  /// @param refname the reference whose reflog to set
  /// @param reflog the reflog as it should be written out
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_reflog(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_transaction_set_reflog(
      tx,
      refname,
      reflog,
    );
  }

  late final _git_transaction_set_reflogPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_reflog>)>>('git_transaction_set_reflog');
  late final _git_transaction_set_reflog =
      _git_transaction_set_reflogPtr.asFunction<
          int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_reflog>)>();

  /// Remove a reference
  ///
  /// @param tx the transaction
  /// @param refname the reference to remove
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_remove(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_transaction_remove(
      tx,
      refname,
    );
  }

  late final _git_transaction_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_remove');
  late final _git_transaction_remove = _git_transaction_removePtr.asFunction<
      int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>)>();

  /// Commit the changes from the transaction
  ///
  /// Perform the changes that have been queued. The updates will be made
  /// one by one, and the first failure will stop the processing.
  ///
  /// @param tx the transaction
  /// @return 0 or an error code
  int git_transaction_commit(
    ffi.Pointer<git_transaction> tx,
  ) {
    return _git_transaction_commit(
      tx,
    );
  }

  late final _git_transaction_commitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_transaction>)>>(
      'git_transaction_commit');
  late final _git_transaction_commit = _git_transaction_commitPtr
      .asFunction<int Function(ffi.Pointer<git_transaction>)>();

  /// Free the resources allocated by this transaction
  ///
  /// If any references remain locked, they will be unlocked without any
  /// changes made to them.
  ///
  /// @param tx the transaction
  void git_transaction_free(
    ffi.Pointer<git_transaction> tx,
  ) {
    return _git_transaction_free(
      tx,
    );
  }

  late final _git_transaction_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_transaction>)>>(
      'git_transaction_free');
  late final _git_transaction_free = _git_transaction_freePtr
      .asFunction<void Function(ffi.Pointer<git_transaction>)>();

  /// List names of linked working trees
  ///
  /// The returned list should be released with `git_strarray_free`
  /// when no longer needed.
  ///
  /// @param out pointer to the array of working tree names
  /// @param repo the repo to use when listing working trees
  /// @return 0 or an error code
  int git_worktree_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_worktree_list(
      out,
      repo,
    );
  }

  late final _git_worktree_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_worktree_list');
  late final _git_worktree_list = _git_worktree_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Lookup a working tree by its name for a given repository
  ///
  /// @param out Output pointer to looked up worktree or `NULL`
  /// @param repo The repository containing worktrees
  /// @param name Name of the working tree to look up
  /// @return 0 or an error code
  int git_worktree_lookup(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_worktree_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_worktree_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_worktree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_worktree_lookup');
  late final _git_worktree_lookup = _git_worktree_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_worktree>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Open a worktree of a given repository
  ///
  /// If a repository is not the main tree but a worktree, this
  /// function will look up the worktree inside the parent
  /// repository and create a new `git_worktree` structure.
  ///
  /// @param out Out-pointer for the newly allocated worktree
  /// @param repo Repository to look up worktree for
  /// @return 0 or an error code
  int git_worktree_open_from_repository(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_worktree_open_from_repository(
      out,
      repo,
    );
  }

  late final _git_worktree_open_from_repositoryPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<git_worktree>>,
                  ffi.Pointer<git_repository>)>>(
      'git_worktree_open_from_repository');
  late final _git_worktree_open_from_repository =
      _git_worktree_open_from_repositoryPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_worktree>>,
              ffi.Pointer<git_repository>)>();

  /// Free a previously allocated worktree
  ///
  /// @param wt worktree handle to close. If NULL nothing occurs.
  void git_worktree_free(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_free(
      wt,
    );
  }

  late final _git_worktree_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_worktree>)>>(
          'git_worktree_free');
  late final _git_worktree_free = _git_worktree_freePtr
      .asFunction<void Function(ffi.Pointer<git_worktree>)>();

  /// Check if worktree is valid
  ///
  /// A valid worktree requires both the git data structures inside
  /// the linked parent repository and the linked working copy to be
  /// present.
  ///
  /// @param wt Worktree to check
  /// @return 0 when worktree is valid, error-code otherwise
  int git_worktree_validate(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_validate(
      wt,
    );
  }

  late final _git_worktree_validatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_worktree>)>>(
          'git_worktree_validate');
  late final _git_worktree_validate = _git_worktree_validatePtr
      .asFunction<int Function(ffi.Pointer<git_worktree>)>();

  /// Initialize git_worktree_add_options structure
  ///
  /// Initializes a `git_worktree_add_options` with default values. Equivalent to
  /// creating an instance with `GIT_WORKTREE_ADD_OPTIONS_INIT`.
  ///
  /// @param opts The `git_worktree_add_options` struct to initialize.
  /// @param version The struct version; pass `GIT_WORKTREE_ADD_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_worktree_add_options_init(
    ffi.Pointer<git_worktree_add_options> opts,
    int version,
  ) {
    return _git_worktree_add_options_init(
      opts,
      version,
    );
  }

  late final _git_worktree_add_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree_add_options>,
              ffi.UnsignedInt)>>('git_worktree_add_options_init');
  late final _git_worktree_add_options_init = _git_worktree_add_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_worktree_add_options>, int)>();

  /// Add a new working tree
  ///
  /// Add a new working tree for the repository, that is create the
  /// required data structures inside the repository and check out
  /// the current HEAD at `path`
  ///
  /// @param out Output pointer containing new working tree
  /// @param repo Repository to create working tree for
  /// @param name Name of the working tree
  /// @param path Path to create working tree at
  /// @param opts Options to modify default behavior. May be NULL
  /// @return 0 or an error code
  int git_worktree_add(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_worktree_add_options> opts,
  ) {
    return _git_worktree_add(
      out,
      repo,
      name,
      path,
      opts,
    );
  }

  late final _git_worktree_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_worktree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_worktree_add_options>)>>('git_worktree_add');
  late final _git_worktree_add = _git_worktree_addPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_worktree>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_worktree_add_options>)>();

  /// Lock worktree if not already locked
  ///
  /// Lock a worktree, optionally specifying a reason why the linked
  /// working tree is being locked.
  ///
  /// @param wt Worktree to lock
  /// @param reason Reason why the working tree is being locked
  /// @return 0 on success, non-zero otherwise
  int git_worktree_lock(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<ffi.Char> reason,
  ) {
    return _git_worktree_lock(
      wt,
      reason,
    );
  }

  late final _git_worktree_lockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree>,
              ffi.Pointer<ffi.Char>)>>('git_worktree_lock');
  late final _git_worktree_lock = _git_worktree_lockPtr.asFunction<
      int Function(ffi.Pointer<git_worktree>, ffi.Pointer<ffi.Char>)>();

  /// Unlock a locked worktree
  ///
  /// @param wt Worktree to unlock
  /// @return 0 on success, 1 if worktree was not locked, error-code
  /// otherwise
  int git_worktree_unlock(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_unlock(
      wt,
    );
  }

  late final _git_worktree_unlockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_worktree>)>>(
          'git_worktree_unlock');
  late final _git_worktree_unlock = _git_worktree_unlockPtr
      .asFunction<int Function(ffi.Pointer<git_worktree>)>();

  /// Check if worktree is locked
  ///
  /// A worktree may be locked if the linked working tree is stored
  /// on a portable device which is not available.
  ///
  /// @param reason Buffer to store reason in. If NULL no reason is stored.
  /// @param wt Worktree to check
  /// @return 0 when the working tree not locked, a value greater
  /// than zero if it is locked, less than zero if there was an
  /// error
  int git_worktree_is_locked(
    ffi.Pointer<git_buf> reason,
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_is_locked(
      reason,
      wt,
    );
  }

  late final _git_worktree_is_lockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_worktree>)>>('git_worktree_is_locked');
  late final _git_worktree_is_locked = _git_worktree_is_lockedPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_worktree>)>();

  /// Retrieve the name of the worktree
  ///
  /// @param wt Worktree to get the name for
  /// @return The worktree's name. The pointer returned is valid for the
  /// lifetime of the git_worktree
  ffi.Pointer<ffi.Char> git_worktree_name(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_name(
      wt,
    );
  }

  late final _git_worktree_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_worktree>)>>('git_worktree_name');
  late final _git_worktree_name = _git_worktree_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_worktree>)>();

  /// Retrieve the filesystem path for the worktree
  ///
  /// @param wt Worktree to get the path for
  /// @return The worktree's filesystem path. The pointer returned
  /// is valid for the lifetime of the git_worktree.
  ffi.Pointer<ffi.Char> git_worktree_path(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_path(
      wt,
    );
  }

  late final _git_worktree_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_worktree>)>>('git_worktree_path');
  late final _git_worktree_path = _git_worktree_pathPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_worktree>)>();

  /// Initialize git_worktree_prune_options structure
  ///
  /// Initializes a `git_worktree_prune_options` with default values. Equivalent to
  /// creating an instance with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_worktree_prune_options` struct to initialize.
  /// @param version The struct version; pass `GIT_WORKTREE_PRUNE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_worktree_prune_options_init(
    ffi.Pointer<git_worktree_prune_options> opts,
    int version,
  ) {
    return _git_worktree_prune_options_init(
      opts,
      version,
    );
  }

  late final _git_worktree_prune_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree_prune_options>,
              ffi.UnsignedInt)>>('git_worktree_prune_options_init');
  late final _git_worktree_prune_options_init =
      _git_worktree_prune_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_worktree_prune_options>, int)>();

  /// Is the worktree prunable with the given options?
  ///
  /// A worktree is not prunable in the following scenarios:
  ///
  /// - the worktree is linking to a valid on-disk worktree. The
  /// `valid` member will cause this check to be ignored.
  /// - the worktree is locked. The `locked` flag will cause this
  /// check to be ignored.
  ///
  /// If the worktree is not valid and not locked or if the above
  /// flags have been passed in, this function will return a
  /// positive value. If the worktree is not prunable, an error
  /// message will be set (visible in `giterr_last`) with details about
  /// why.
  ///
  /// @param wt Worktree to check.
  /// @param opts The prunable options.
  /// @return 1 if the worktree is prunable, 0 otherwise, or an error code.
  int git_worktree_is_prunable(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<git_worktree_prune_options> opts,
  ) {
    return _git_worktree_is_prunable(
      wt,
      opts,
    );
  }

  late final _git_worktree_is_prunablePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_worktree>,
                  ffi.Pointer<git_worktree_prune_options>)>>(
      'git_worktree_is_prunable');
  late final _git_worktree_is_prunable =
      _git_worktree_is_prunablePtr.asFunction<
          int Function(ffi.Pointer<git_worktree>,
              ffi.Pointer<git_worktree_prune_options>)>();

  /// Prune working tree
  ///
  /// Prune the working tree, that is remove the git data
  /// structures on disk. The repository will only be pruned of
  /// `git_worktree_is_prunable` succeeds.
  ///
  /// @param wt Worktree to prune
  /// @param opts Specifies which checks to override. See
  /// `git_worktree_is_prunable`. May be NULL
  /// @return 0 or an error code
  int git_worktree_prune(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<git_worktree_prune_options> opts,
  ) {
    return _git_worktree_prune(
      wt,
      opts,
    );
  }

  late final _git_worktree_prunePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree>,
              ffi.Pointer<git_worktree_prune_options>)>>('git_worktree_prune');
  late final _git_worktree_prune = _git_worktree_prunePtr.asFunction<
      int Function(ffi.Pointer<git_worktree>,
          ffi.Pointer<git_worktree_prune_options>)>();

  /// Get the count of filename conflict entries currently in the index.
  ///
  /// @param index an existing index object
  /// @return integer of count of current filename conflict entries
  int git_index_name_entrycount(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_name_entrycount(
      index,
    );
  }

  late final _git_index_name_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_index>)>>(
          'git_index_name_entrycount');
  late final _git_index_name_entrycount = _git_index_name_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Get a filename conflict entry from the index.
  ///
  /// The returned entry is read-only and should not be modified
  /// or freed by the caller.
  ///
  /// @param index an existing index object
  /// @param n the position of the entry
  /// @return a pointer to the filename conflict entry; NULL if out of bounds
  ffi.Pointer<git_index_name_entry> git_index_name_get_byindex(
    ffi.Pointer<git_index> index,
    int n,
  ) {
    return _git_index_name_get_byindex(
      index,
      n,
    );
  }

  late final _git_index_name_get_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_index_name_entry> Function(
              ffi.Pointer<git_index>, ffi.Size)>>('git_index_name_get_byindex');
  late final _git_index_name_get_byindex =
      _git_index_name_get_byindexPtr.asFunction<
          ffi.Pointer<git_index_name_entry> Function(
              ffi.Pointer<git_index>, int)>();

  /// Record the filenames involved in a rename conflict.
  ///
  /// @param index an existing index object
  /// @param ancestor the path of the file as it existed in the ancestor
  /// @param ours the path of the file as it existed in our tree
  /// @param theirs the path of the file as it existed in their tree
  /// @return 0 on success, or an error code
  int git_index_name_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> ancestor,
    ffi.Pointer<ffi.Char> ours,
    ffi.Pointer<ffi.Char> theirs,
  ) {
    return _git_index_name_add(
      index,
      ancestor,
      ours,
      theirs,
    );
  }

  late final _git_index_name_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_index_name_add');
  late final _git_index_name_add = _git_index_name_addPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Remove all filename conflict entries.
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_name_clear(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_name_clear(
      index,
    );
  }

  late final _git_index_name_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_name_clear');
  late final _git_index_name_clear = _git_index_name_clearPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Get the count of resolve undo entries currently in the index.
  ///
  /// @param index an existing index object
  /// @return integer of count of current resolve undo entries
  int git_index_reuc_entrycount(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_reuc_entrycount(
      index,
    );
  }

  late final _git_index_reuc_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_index>)>>(
          'git_index_reuc_entrycount');
  late final _git_index_reuc_entrycount = _git_index_reuc_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Finds the resolve undo entry that points to the given path in the Git
  /// index.
  ///
  /// @param at_pos the address to which the position of the reuc entry is written (optional)
  /// @param index an existing index object
  /// @param path path to search
  /// @return 0 if found, < 0 otherwise (GIT_ENOTFOUND)
  int git_index_reuc_find(
    ffi.Pointer<ffi.Size> at_pos,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_reuc_find(
      at_pos,
      index,
      path,
    );
  }

  late final _git_index_reuc_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_reuc_find');
  late final _git_index_reuc_find = _git_index_reuc_findPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>)>();

  /// Get a resolve undo entry from the index.
  ///
  /// The returned entry is read-only and should not be modified
  /// or freed by the caller.
  ///
  /// @param index an existing index object
  /// @param path path to search
  /// @return the resolve undo entry; NULL if not found
  ffi.Pointer<git_index_reuc_entry> git_index_reuc_get_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_reuc_get_bypath(
      index,
      path,
    );
  }

  late final _git_index_reuc_get_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_index_reuc_entry> Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_reuc_get_bypath');
  late final _git_index_reuc_get_bypath =
      _git_index_reuc_get_bypathPtr.asFunction<
          ffi.Pointer<git_index_reuc_entry> Function(
              ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>)>();

  /// Get a resolve undo entry from the index.
  ///
  /// The returned entry is read-only and should not be modified
  /// or freed by the caller.
  ///
  /// @param index an existing index object
  /// @param n the position of the entry
  /// @return a pointer to the resolve undo entry; NULL if out of bounds
  ffi.Pointer<git_index_reuc_entry> git_index_reuc_get_byindex(
    ffi.Pointer<git_index> index,
    int n,
  ) {
    return _git_index_reuc_get_byindex(
      index,
      n,
    );
  }

  late final _git_index_reuc_get_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_index_reuc_entry> Function(
              ffi.Pointer<git_index>, ffi.Size)>>('git_index_reuc_get_byindex');
  late final _git_index_reuc_get_byindex =
      _git_index_reuc_get_byindexPtr.asFunction<
          ffi.Pointer<git_index_reuc_entry> Function(
              ffi.Pointer<git_index>, int)>();

  /// Adds a resolve undo entry for a file based on the given parameters.
  ///
  /// The resolve undo entry contains the OIDs of files that were involved
  /// in a merge conflict after the conflict has been resolved.  This allows
  /// conflicts to be re-resolved later.
  ///
  /// If there exists a resolve undo entry for the given path in the index,
  /// it will be removed.
  ///
  /// This method will fail in bare index instances.
  ///
  /// @param index an existing index object
  /// @param path filename to add
  /// @param ancestor_mode mode of the ancestor file
  /// @param ancestor_id oid of the ancestor file
  /// @param our_mode mode of our file
  /// @param our_id oid of our file
  /// @param their_mode mode of their file
  /// @param their_id oid of their file
  /// @return 0 or an error code
  int git_index_reuc_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
    int ancestor_mode,
    ffi.Pointer<git_oid> ancestor_id,
    int our_mode,
    ffi.Pointer<git_oid> our_id,
    int their_mode,
    ffi.Pointer<git_oid> their_id,
  ) {
    return _git_index_reuc_add(
      index,
      path,
      ancestor_mode,
      ancestor_id,
      our_mode,
      our_id,
      their_mode,
      their_id,
    );
  }

  late final _git_index_reuc_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<git_oid>,
              ffi.Int,
              ffi.Pointer<git_oid>,
              ffi.Int,
              ffi.Pointer<git_oid>)>>('git_index_reuc_add');
  late final _git_index_reuc_add = _git_index_reuc_addPtr.asFunction<
      int Function(
          ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<git_oid>,
          int,
          ffi.Pointer<git_oid>,
          int,
          ffi.Pointer<git_oid>)>();

  /// Remove an resolve undo entry from the index
  ///
  /// @param index an existing index object
  /// @param n position of the resolve undo entry to remove
  /// @return 0 or an error code
  int git_index_reuc_remove(
    ffi.Pointer<git_index> index,
    int n,
  ) {
    return _git_index_reuc_remove(
      index,
      n,
    );
  }

  late final _git_index_reuc_removePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<git_index>, ffi.Size)>>(
      'git_index_reuc_remove');
  late final _git_index_reuc_remove = _git_index_reuc_removePtr
      .asFunction<int Function(ffi.Pointer<git_index>, int)>();

  /// Remove all resolve undo entries from the index
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_reuc_clear(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_reuc_clear(
      index,
    );
  }

  late final _git_index_reuc_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_reuc_clear');
  late final _git_index_reuc_clear = _git_index_reuc_clearPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Create a diff for a commit in mbox format for sending via email.
  ///
  /// @param out buffer to store the e-mail patch in
  /// @param diff the changes to include in the email
  /// @param patch_idx the patch index
  /// @param patch_count the total number of patches that will be included
  /// @param commit_id the commit id for this change
  /// @param summary the commit message for this change
  /// @param body optional text to include above the diffstat
  /// @param author the person who authored this commit
  /// @param opts email creation options
  /// @return 0 on success or an error code
  int git_email_create_from_diff(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff> diff,
    int patch_idx,
    int patch_count,
    ffi.Pointer<git_oid> commit_id,
    ffi.Pointer<ffi.Char> summary,
    ffi.Pointer<ffi.Char> body,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_email_create_options> opts,
  ) {
    return _git_email_create_from_diff(
      out,
      diff,
      patch_idx,
      patch_count,
      commit_id,
      summary,
      body,
      author,
      opts,
    );
  }

  late final _git_email_create_from_diffPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_buf>,
                  ffi.Pointer<git_diff>,
                  ffi.Size,
                  ffi.Size,
                  ffi.Pointer<git_oid>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<git_email_create_options>)>>(
      'git_email_create_from_diff');
  late final _git_email_create_from_diff =
      _git_email_create_from_diffPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_diff>,
              int,
              int,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_email_create_options>)>();

  /// Initializes a `git_config_backend` with default values. Equivalent to
  /// creating an instance with GIT_CONFIG_BACKEND_INIT.
  ///
  /// @param backend the `git_config_backend` struct to initialize.
  /// @param version Version of struct; pass `GIT_CONFIG_BACKEND_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_config_init_backend(
    ffi.Pointer<git_config_backend> backend,
    int version,
  ) {
    return _git_config_init_backend(
      backend,
      version,
    );
  }

  late final _git_config_init_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config_backend>,
              ffi.UnsignedInt)>>('git_config_init_backend');
  late final _git_config_init_backend = _git_config_init_backendPtr
      .asFunction<int Function(ffi.Pointer<git_config_backend>, int)>();

  /// Add a generic config file instance to an existing config
  ///
  /// Note that the configuration object will free the file
  /// automatically.
  ///
  /// Further queries on this config object will access each
  /// of the config file instances in order (instances with
  /// a higher priority level will be accessed first).
  ///
  /// @param cfg the configuration to add the file to
  /// @param file the configuration file (backend) to add
  /// @param level the priority level of the backend
  /// @param repo optional repository to allow parsing of
  /// conditional includes
  /// @param force if a config file already exists for the given
  /// priority level, replace it
  /// @return 0 on success, GIT_EEXISTS when adding more than one file
  /// for a given priority level (and force_replace set to 0), or error code
  int git_config_add_backend(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<git_config_backend> file,
    git_config_level_t level,
    ffi.Pointer<git_repository> repo,
    int force,
  ) {
    return _git_config_add_backend(
      cfg,
      file,
      level.value,
      repo,
      force,
    );
  }

  late final _git_config_add_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<git_config_backend>,
              ffi.Int,
              ffi.Pointer<git_repository>,
              ffi.Int)>>('git_config_add_backend');
  late final _git_config_add_backend = _git_config_add_backendPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<git_config_backend>,
          int, ffi.Pointer<git_repository>, int)>();

  /// Create an in-memory configuration backend from a string in standard
  /// git configuration file format.
  ///
  /// @param out the new backend
  /// @param cfg the configuration that is to be parsed
  /// @param len the length of the string pointed to by `cfg`
  /// @param opts the options to initialize this backend with, or NULL
  /// @return 0 on success or an error code
  int git_config_backend_from_string(
    ffi.Pointer<ffi.Pointer<git_config_backend>> out,
    ffi.Pointer<ffi.Char> cfg,
    int len,
    ffi.Pointer<git_config_backend_memory_options> opts,
  ) {
    return _git_config_backend_from_string(
      out,
      cfg,
      len,
      opts,
    );
  }

  late final _git_config_backend_from_stringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_config_backend>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<git_config_backend_memory_options>)>>(
      'git_config_backend_from_string');
  late final _git_config_backend_from_string =
      _git_config_backend_from_stringPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_config_backend>>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<git_config_backend_memory_options>)>();

  /// Create an in-memory configuration backend from a list of name/value
  /// pairs.
  ///
  /// @param out the new backend
  /// @param values the configuration values to set (in "key=value" format)
  /// @param len the length of the values array
  /// @param opts the options to initialize this backend with, or NULL
  /// @return 0 on success or an error code
  int git_config_backend_from_values(
    ffi.Pointer<ffi.Pointer<git_config_backend>> out,
    ffi.Pointer<ffi.Pointer<ffi.Char>> values,
    int len,
    ffi.Pointer<git_config_backend_memory_options> opts,
  ) {
    return _git_config_backend_from_values(
      out,
      values,
      len,
      opts,
    );
  }

  late final _git_config_backend_from_valuesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_config_backend>>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Size,
                  ffi.Pointer<git_config_backend_memory_options>)>>(
      'git_config_backend_from_values');
  late final _git_config_backend_from_values =
      _git_config_backend_from_valuesPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_config_backend>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              int,
              ffi.Pointer<git_config_backend_memory_options>)>();

  /// Check whether a path component corresponds to a .git$SUFFIX
  /// file.
  ///
  /// As some filesystems do special things to filenames when
  /// writing files to disk, you cannot always do a plain string
  /// comparison to verify whether a file name matches an expected
  /// path or not. This function can do the comparison for you,
  /// depending on the filesystem you're on.
  ///
  /// @param path the path component to check
  /// @param pathlen the length of `path` that is to be checked
  /// @param gitfile which file to check against
  /// @param fs which filesystem-specific checks to use
  /// @return 0 in case the file does not match, a positive value if
  /// it does; -1 in case of an error
  int git_path_is_gitfile(
    ffi.Pointer<ffi.Char> path,
    int pathlen,
    git_path_gitfile gitfile,
    git_path_fs fs,
  ) {
    return _git_path_is_gitfile(
      path,
      pathlen,
      gitfile.value,
      fs.value,
    );
  }

  late final _git_path_is_gitfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('git_path_is_gitfile');
  late final _git_path_is_gitfile = _git_path_is_gitfilePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  /// Initialize git_repository_new_options structure
  ///
  /// Initializes a `git_repository_new_options` with default values.
  /// Equivalent to creating an instance with
  /// `GIT_REPOSITORY_NEW_OPTIONS_INIT`.
  ///
  /// @param opts The `git_repository_new_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REPOSITORY_NEW_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_repository_new_options_init(
    ffi.Pointer<git_repository_new_options> opts,
    int version,
  ) {
    return _git_repository_new_options_init(
      opts,
      version,
    );
  }

  late final _git_repository_new_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository_new_options>,
              ffi.UnsignedInt)>>('git_repository_new_options_init');
  late final _git_repository_new_options_init =
      _git_repository_new_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_repository_new_options>, int)>();

  /// Create a new repository with no backends.
  ///
  /// @param[out] out The blank repository
  /// @param opts the options for repository creation, or NULL for defaults
  /// @return 0 on success, or an error code
  int git_repository_new(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_repository_new_options> opts,
  ) {
    return _git_repository_new(
      out,
      opts,
    );
  }

  late final _git_repository_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_repository_new_options>)>>('git_repository_new');
  late final _git_repository_new = _git_repository_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<git_repository_new_options>)>();

  /// Reset all the internal state in a repository.
  ///
  /// This will free all the mapped memory and internal objects
  /// of the repository and leave it in a "blank" state.
  ///
  /// There's no need to call this function directly unless you're
  /// trying to aggressively cleanup the repo before its
  /// deallocation. `git_repository_free` already performs this operation
  /// before deallocating the repo.
  ///
  /// @param repo The repository to clean up
  /// @return 0 on success, or an error code
  int git_repository__cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository__cleanup(
      repo,
    );
  }

  late final _git_repository__cleanupPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository__cleanup');
  late final _git_repository__cleanup = _git_repository__cleanupPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Update the filesystem config settings for an open repository
  ///
  /// When a repository is initialized, config values are set based on the
  /// properties of the filesystem that the repository is on, such as
  /// "core.ignorecase", "core.filemode", "core.symlinks", etc.  If the
  /// repository is moved to a new filesystem, these properties may no
  /// longer be correct and API calls may not behave as expected.  This
  /// call reruns the phase of repository initialization that sets those
  /// properties to compensate for the current filesystem of the repo.
  ///
  /// @param repo A repository object
  /// @param recurse_submodules Should submodules be updated recursively
  /// @return 0 on success, < 0 on error
  int git_repository_reinit_filesystem(
    ffi.Pointer<git_repository> repo,
    int recurse_submodules,
  ) {
    return _git_repository_reinit_filesystem(
      repo,
      recurse_submodules,
    );
  }

  late final _git_repository_reinit_filesystemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Int)>>('git_repository_reinit_filesystem');
  late final _git_repository_reinit_filesystem =
      _git_repository_reinit_filesystemPtr
          .asFunction<int Function(ffi.Pointer<git_repository>, int)>();

  /// Set the configuration file for this repository
  ///
  /// This configuration file will be used for all configuration
  /// queries involving this repository.
  ///
  /// The repository will keep a reference to the config file;
  /// the user must still free the config after setting it
  /// to the repository, or it will leak.
  ///
  /// @param repo A repository object
  /// @param config A Config object
  /// @return 0 on success, or an error code
  int git_repository_set_config(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_config> config,
  ) {
    return _git_repository_set_config(
      repo,
      config,
    );
  }

  late final _git_repository_set_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_config>)>>('git_repository_set_config');
  late final _git_repository_set_config =
      _git_repository_set_configPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_config>)>();

  /// Set the Object Database for this repository
  ///
  /// The ODB will be used for all object-related operations
  /// involving this repository.
  ///
  /// The repository will keep a reference to the ODB; the user
  /// must still free the ODB object after setting it to the
  /// repository, or it will leak.
  ///
  /// @param repo A repository object
  /// @param odb An ODB object
  /// @return 0 on success, or an error code
  int git_repository_set_odb(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_odb> odb,
  ) {
    return _git_repository_set_odb(
      repo,
      odb,
    );
  }

  late final _git_repository_set_odbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_odb>)>>('git_repository_set_odb');
  late final _git_repository_set_odb = _git_repository_set_odbPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_odb>)>();

  /// Set the Reference Database Backend for this repository
  ///
  /// The refdb will be used for all reference related operations
  /// involving this repository.
  ///
  /// The repository will keep a reference to the refdb; the user
  /// must still free the refdb object after setting it to the
  /// repository, or it will leak.
  ///
  /// @param repo A repository object
  /// @param refdb An refdb object
  /// @return 0 on success, or an error code
  int git_repository_set_refdb(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_refdb> refdb,
  ) {
    return _git_repository_set_refdb(
      repo,
      refdb,
    );
  }

  late final _git_repository_set_refdbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_refdb>)>>('git_repository_set_refdb');
  late final _git_repository_set_refdb =
      _git_repository_set_refdbPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_refdb>)>();

  /// Set the index file for this repository
  ///
  /// This index will be used for all index-related operations
  /// involving this repository.
  ///
  /// The repository will keep a reference to the index file;
  /// the user must still free the index after setting it
  /// to the repository, or it will leak.
  ///
  /// @param repo A repository object
  /// @param index An index object
  /// @return 0 on success, or an error code
  int git_repository_set_index(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> index,
  ) {
    return _git_repository_set_index(
      repo,
      index,
    );
  }

  late final _git_repository_set_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_index>)>>('git_repository_set_index');
  late final _git_repository_set_index =
      _git_repository_set_indexPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_index>)>();

  /// Set a repository to be bare.
  ///
  /// Clear the working directory and set core.bare to true.  You may also
  /// want to call `git_repository_set_index(repo, NULL)` since a bare repo
  /// typically does not have an index, but this function will not do that
  /// for you.
  ///
  /// @param repo Repo to make bare
  /// @return 0 on success, <0 on failure
  int git_repository_set_bare(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_set_bare(
      repo,
    );
  }

  late final _git_repository_set_barePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_set_bare');
  late final _git_repository_set_bare = _git_repository_set_barePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Load and cache all submodules.
  ///
  /// Because the `.gitmodules` file is unstructured, loading submodules is an
  /// O(N) operation.  Any operation (such as `git_rebase_init`) that requires
  /// accessing all submodules is O(N^2) in the number of submodules, if it
  /// has to look each one up individually.  This function loads all submodules
  /// and caches them so that subsequent calls to `git_submodule_lookup` are O(1).
  ///
  /// @param repo the repository whose submodules will be cached.
  /// @return 0 on success, or an error code
  int git_repository_submodule_cache_all(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_submodule_cache_all(
      repo,
    );
  }

  late final _git_repository_submodule_cache_allPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_submodule_cache_all');
  late final _git_repository_submodule_cache_all =
      _git_repository_submodule_cache_allPtr
          .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Clear the submodule cache.
  ///
  /// Clear the submodule cache populated by `git_repository_submodule_cache_all`.
  /// If there is no cache, do nothing.
  ///
  /// The cache incorporates data from the repository's configuration, as well
  /// as the state of the working tree, the index, and HEAD.  So any time any
  /// of these has changed, the cache might become invalid.
  ///
  /// @param repo the repository whose submodule cache will be cleared
  /// @return 0 on success, or an error code
  int git_repository_submodule_cache_clear(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_submodule_cache_clear(
      repo,
    );
  }

  late final _git_repository_submodule_cache_clearPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_submodule_cache_clear');
  late final _git_repository_submodule_cache_clear =
      _git_repository_submodule_cache_clearPtr
          .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Initialize the OpenSSL locks
  ///
  /// OpenSSL requires the application to determine how it performs
  /// locking.
  ///
  /// This is a last-resort convenience function which libgit2 provides for
  /// allocating and initializing the locks as well as setting the
  /// locking function to use the system's native locking functions.
  ///
  /// The locking function will be cleared and the memory will be freed
  /// when you call git_threads_sutdown().
  ///
  /// If your programming language has an OpenSSL package/bindings, it
  /// likely sets up locking. You should very strongly prefer that over
  /// this function.
  ///
  /// @return 0 on success, -1 if there are errors or if libgit2 was not
  /// built with OpenSSL and threading support.
  int git_openssl_set_locking() {
    return _git_openssl_set_locking();
  }

  late final _git_openssl_set_lockingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'git_openssl_set_locking');
  late final _git_openssl_set_locking =
      _git_openssl_set_lockingPtr.asFunction<int Function()>();

  /// Initialize git_midx_writer_options structure
  ///
  /// Initializes a `git_midx_writer_options` with default values.
  /// Equivalent to creating an instance with
  /// `GIT_MIDX_WRITER_OPTIONS_INIT`.
  ///
  /// @param opts The `git_midx_writer_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MIDX_WRITER_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_midx_writer_options_init(
    ffi.Pointer<git_midx_writer_options> opts,
    int version,
  ) {
    return _git_midx_writer_options_init(
      opts,
      version,
    );
  }

  late final _git_midx_writer_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_midx_writer_options>,
              ffi.UnsignedInt)>>('git_midx_writer_options_init');
  late final _git_midx_writer_options_init = _git_midx_writer_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_midx_writer_options>, int)>();

  /// Create a new writer for `multi-pack-index` files.
  ///
  /// @param out location to store the writer pointer.
  /// @param pack_dir the directory where the `.pack` and `.idx` files are. The
  /// `multi-pack-index` file will be written in this directory, too.
  /// @return 0 or an error code
  int git_midx_writer_new(
    ffi.Pointer<ffi.Pointer<git_midx_writer>> out,
    ffi.Pointer<ffi.Char> pack_dir,
    ffi.Pointer<git_midx_writer_options> options,
  ) {
    return _git_midx_writer_new(
      out,
      pack_dir,
      options,
    );
  }

  late final _git_midx_writer_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_midx_writer>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_midx_writer_options>)>>('git_midx_writer_new');
  late final _git_midx_writer_new = _git_midx_writer_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_midx_writer>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_midx_writer_options>)>();

  /// Free the multi-pack-index writer and its resources.
  ///
  /// @param w the writer to free. If NULL no action is taken.
  void git_midx_writer_free(
    ffi.Pointer<git_midx_writer> w,
  ) {
    return _git_midx_writer_free(
      w,
    );
  }

  late final _git_midx_writer_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_midx_writer>)>>(
      'git_midx_writer_free');
  late final _git_midx_writer_free = _git_midx_writer_freePtr
      .asFunction<void Function(ffi.Pointer<git_midx_writer>)>();

  /// Add an `.idx` file to the writer.
  ///
  /// @param w the writer
  /// @param idx_path the path of an `.idx` file.
  /// @return 0 or an error code
  int git_midx_writer_add(
    ffi.Pointer<git_midx_writer> w,
    ffi.Pointer<ffi.Char> idx_path,
  ) {
    return _git_midx_writer_add(
      w,
      idx_path,
    );
  }

  late final _git_midx_writer_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_midx_writer>,
              ffi.Pointer<ffi.Char>)>>('git_midx_writer_add');
  late final _git_midx_writer_add = _git_midx_writer_addPtr.asFunction<
      int Function(ffi.Pointer<git_midx_writer>, ffi.Pointer<ffi.Char>)>();

  /// Write a `multi-pack-index` file to a file.
  ///
  /// @param w the writer
  /// @return 0 or an error code
  int git_midx_writer_commit(
    ffi.Pointer<git_midx_writer> w,
  ) {
    return _git_midx_writer_commit(
      w,
    );
  }

  late final _git_midx_writer_commitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_midx_writer>)>>(
      'git_midx_writer_commit');
  late final _git_midx_writer_commit = _git_midx_writer_commitPtr
      .asFunction<int Function(ffi.Pointer<git_midx_writer>)>();

  /// Dump the contents of the `multi-pack-index` to an in-memory buffer.
  ///
  /// @param midx Buffer where to store the contents of the `multi-pack-index`.
  /// @param w the writer
  /// @return 0 or an error code
  int git_midx_writer_dump(
    ffi.Pointer<git_buf> midx,
    ffi.Pointer<git_midx_writer> w,
  ) {
    return _git_midx_writer_dump(
      midx,
      w,
    );
  }

  late final _git_midx_writer_dumpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_midx_writer>)>>('git_midx_writer_dump');
  late final _git_midx_writer_dump = _git_midx_writer_dumpPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_midx_writer>)>();

  /// Clear the last library error that occurred for this thread.
  void git_error_clear() {
    return _git_error_clear();
  }

  late final _git_error_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('git_error_clear');
  late final _git_error_clear =
      _git_error_clearPtr.asFunction<void Function()>();

  /// Set the error message string for this thread, using `printf`-style
  /// formatting.
  ///
  /// This function is public so that custom ODB backends and the like can
  /// relay an error message through libgit2.  Most regular users of libgit2
  /// will never need to call this function -- actually, calling it in most
  /// circumstances (for example, calling from within a callback function)
  /// will just end up having the value overwritten by libgit2 internals.
  ///
  /// This error message is stored in thread-local storage and only applies
  /// to the particular thread that this libgit2 call is made from.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param fmt The `printf`-style format string; subsequent arguments must
  /// be the arguments for the format string.
  void git_error_set(
    int error_class,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _git_error_set(
      error_class,
      fmt,
    );
  }

  late final _git_error_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('git_error_set');
  late final _git_error_set =
      _git_error_setPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Set the error message string for this thread.  This function is like
  /// `git_error_set` but takes a static string instead of a `printf`-style
  /// format.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param string The error message to keep
  /// @return 0 on success or -1 on failure
  int git_error_set_str(
    int error_class,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _git_error_set_str(
      error_class,
      string,
    );
  }

  late final _git_error_set_strPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'git_error_set_str');
  late final _git_error_set_str = _git_error_set_strPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Set the error message to a special value for memory allocation failure.
  ///
  /// The normal `git_error_set_str()` function attempts to `strdup()` the
  /// string that is passed in.  This is not a good idea when the error in
  /// question is a memory allocation failure.  That circumstance has a
  /// special setter function that sets the error string to a known and
  /// statically allocated internal value.
  void git_error_set_oom() {
    return _git_error_set_oom();
  }

  late final _git_error_set_oomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('git_error_set_oom');
  late final _git_error_set_oom =
      _git_error_set_oomPtr.asFunction<void Function()>();

  /// Look up a merge driver by name
  ///
  /// @param name The name of the merge driver
  /// @return Pointer to the merge driver object or NULL if not found
  ffi.Pointer<git_merge_driver> git_merge_driver_lookup(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_merge_driver_lookup(
      name,
    );
  }

  late final _git_merge_driver_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_merge_driver> Function(
              ffi.Pointer<ffi.Char>)>>('git_merge_driver_lookup');
  late final _git_merge_driver_lookup = _git_merge_driver_lookupPtr.asFunction<
      ffi.Pointer<git_merge_driver> Function(ffi.Pointer<ffi.Char>)>();

  /// Get the repository that the source data is coming from.
  ///
  /// @param src the merge driver source
  /// @return the repository
  ffi.Pointer<git_repository> git_merge_driver_source_repo(
    ffi.Pointer<git_merge_driver_source> src,
  ) {
    return _git_merge_driver_source_repo(
      src,
    );
  }

  late final _git_merge_driver_source_repoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<git_repository> Function(
                  ffi.Pointer<git_merge_driver_source>)>>(
      'git_merge_driver_source_repo');
  late final _git_merge_driver_source_repo =
      _git_merge_driver_source_repoPtr.asFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_merge_driver_source>)>();

  /// Gets the ancestor of the file to merge.
  ///
  /// @param src the merge driver source
  /// @return the ancestor or NULL if there was no ancestor
  ffi.Pointer<git_index_entry> git_merge_driver_source_ancestor(
    ffi.Pointer<git_merge_driver_source> src,
  ) {
    return _git_merge_driver_source_ancestor(
      src,
    );
  }

  late final _git_merge_driver_source_ancestorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<git_index_entry> Function(
                  ffi.Pointer<git_merge_driver_source>)>>(
      'git_merge_driver_source_ancestor');
  late final _git_merge_driver_source_ancestor =
      _git_merge_driver_source_ancestorPtr.asFunction<
          ffi.Pointer<git_index_entry> Function(
              ffi.Pointer<git_merge_driver_source>)>();

  /// Gets the ours side of the file to merge.
  ///
  /// @param src the merge driver source
  /// @return the ours side or NULL if there was no ours side
  ffi.Pointer<git_index_entry> git_merge_driver_source_ours(
    ffi.Pointer<git_merge_driver_source> src,
  ) {
    return _git_merge_driver_source_ours(
      src,
    );
  }

  late final _git_merge_driver_source_oursPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<git_index_entry> Function(
                  ffi.Pointer<git_merge_driver_source>)>>(
      'git_merge_driver_source_ours');
  late final _git_merge_driver_source_ours =
      _git_merge_driver_source_oursPtr.asFunction<
          ffi.Pointer<git_index_entry> Function(
              ffi.Pointer<git_merge_driver_source>)>();

  /// Gets the theirs side of the file to merge.
  ///
  /// @param src the merge driver source
  /// @return the theirs side or NULL if there was no theirs side
  ffi.Pointer<git_index_entry> git_merge_driver_source_theirs(
    ffi.Pointer<git_merge_driver_source> src,
  ) {
    return _git_merge_driver_source_theirs(
      src,
    );
  }

  late final _git_merge_driver_source_theirsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<git_index_entry> Function(
                  ffi.Pointer<git_merge_driver_source>)>>(
      'git_merge_driver_source_theirs');
  late final _git_merge_driver_source_theirs =
      _git_merge_driver_source_theirsPtr.asFunction<
          ffi.Pointer<git_index_entry> Function(
              ffi.Pointer<git_merge_driver_source>)>();

  /// Gets the merge file options that the merge was invoked with.
  ///
  /// @param src the merge driver source
  /// @return the options
  ffi.Pointer<git_merge_file_options> git_merge_driver_source_file_options(
    ffi.Pointer<git_merge_driver_source> src,
  ) {
    return _git_merge_driver_source_file_options(
      src,
    );
  }

  late final _git_merge_driver_source_file_optionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<git_merge_file_options> Function(
                  ffi.Pointer<git_merge_driver_source>)>>(
      'git_merge_driver_source_file_options');
  late final _git_merge_driver_source_file_options =
      _git_merge_driver_source_file_optionsPtr.asFunction<
          ffi.Pointer<git_merge_file_options> Function(
              ffi.Pointer<git_merge_driver_source>)>();

  /// Register a merge driver under a given name.
  ///
  /// As mentioned elsewhere, the initialize callback will not be invoked
  /// immediately.  It is deferred until the driver is used in some way.
  ///
  /// Currently the merge driver registry is not thread safe, so any
  /// registering or deregistering of merge drivers must be done outside of
  /// any possible usage of the drivers (i.e. during application setup or
  /// shutdown).
  ///
  /// @param name The name of this driver to match an attribute.  Attempting
  /// to register with an in-use name will return GIT_EEXISTS.
  /// @param driver The merge driver definition.  This pointer will be stored
  /// as is by libgit2 so it must be a durable allocation (either
  /// static or on the heap).
  /// @return 0 on successful registry, error code <0 on failure
  int git_merge_driver_register(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_merge_driver> driver,
  ) {
    return _git_merge_driver_register(
      name,
      driver,
    );
  }

  late final _git_merge_driver_registerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_merge_driver>)>>('git_merge_driver_register');
  late final _git_merge_driver_register =
      _git_merge_driver_registerPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_merge_driver>)>();

  /// Remove the merge driver with the given name.
  ///
  /// Attempting to remove the builtin libgit2 merge drivers is not permitted
  /// and will return an error.
  ///
  /// Currently the merge driver registry is not thread safe, so any
  /// registering or deregistering of drivers must be done outside of any
  /// possible usage of the drivers (i.e. during application setup or shutdown).
  ///
  /// @param name The name under which the merge driver was registered
  /// @return 0 on success, error code <0 on failure
  int git_merge_driver_unregister(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_merge_driver_unregister(
      name,
    );
  }

  late final _git_merge_driver_unregisterPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'git_merge_driver_unregister');
  late final _git_merge_driver_unregister = _git_merge_driver_unregisterPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Register stream constructors for the library to use
  ///
  /// If a registration structure is already set, it will be overwritten.
  /// Pass `NULL` in order to deregister the current constructor and return
  /// to the system defaults.
  ///
  /// The type parameter may be a bitwise AND of types.
  ///
  /// @param type the type or types of stream to register
  /// @param registration the registration data
  /// @return 0 or an error code
  int git_stream_register(
    git_stream_t type,
    ffi.Pointer<git_stream_registration> registration,
  ) {
    return _git_stream_register(
      type.value,
      registration,
    );
  }

  late final _git_stream_registerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt,
              ffi.Pointer<git_stream_registration>)>>('git_stream_register');
  late final _git_stream_register = _git_stream_registerPtr
      .asFunction<int Function(int, ffi.Pointer<git_stream_registration>)>();

  /// Register a TLS stream constructor for the library to use.  This stream
  /// will not support HTTP CONNECT proxies.  This internally calls
  /// `git_stream_register` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Provide a git_stream_registration to git_stream_register
  /// @see git_stream_register
  int git_stream_register_tls(
    git_stream_cb ctor,
  ) {
    return _git_stream_register_tls(
      ctor,
    );
  }

  late final _git_stream_register_tlsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(git_stream_cb)>>(
          'git_stream_register_tls');
  late final _git_stream_register_tls =
      _git_stream_register_tlsPtr.asFunction<int Function(git_stream_cb)>();

  /// Initializes a `git_odb_backend` with default values. Equivalent to
  /// creating an instance with GIT_ODB_BACKEND_INIT.
  ///
  /// @param backend the `git_odb_backend` struct to initialize.
  /// @param version Version the struct; pass `GIT_ODB_BACKEND_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_odb_init_backend(
    ffi.Pointer<git_odb_backend> backend,
    int version,
  ) {
    return _git_odb_init_backend(
      backend,
      version,
    );
  }

  late final _git_odb_init_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_backend>,
              ffi.UnsignedInt)>>('git_odb_init_backend');
  late final _git_odb_init_backend = _git_odb_init_backendPtr
      .asFunction<int Function(ffi.Pointer<git_odb_backend>, int)>();

  /// Allocate data for an ODB object.  Custom ODB backends may use this
  /// to provide data back to the ODB from their read function.  This
  /// memory should not be freed once it is returned to libgit2.  If a
  /// custom ODB uses this function but encounters an error and does not
  /// return this data to libgit2, then they should use the corresponding
  /// git_odb_backend_data_free function.
  ///
  /// @param backend the ODB backend that is allocating this memory
  /// @param len the number of bytes to allocate
  /// @return the allocated buffer on success or NULL if out of memory
  ffi.Pointer<ffi.Void> git_odb_backend_data_alloc(
    ffi.Pointer<git_odb_backend> backend,
    int len,
  ) {
    return _git_odb_backend_data_alloc(
      backend,
      len,
    );
  }

  late final _git_odb_backend_data_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_odb_backend>,
              ffi.Size)>>('git_odb_backend_data_alloc');
  late final _git_odb_backend_data_alloc =
      _git_odb_backend_data_allocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_odb_backend>, int)>();

  /// Frees custom allocated ODB data.  This should only be called when
  /// memory allocated using git_odb_backend_data_alloc is not returned
  /// to libgit2 because the backend encountered an error in the read
  /// function after allocation and did not return this data to libgit2.
  ///
  /// @param backend the ODB backend that is freeing this memory
  /// @param data the buffer to free
  void git_odb_backend_data_free(
    ffi.Pointer<git_odb_backend> backend,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _git_odb_backend_data_free(
      backend,
      data,
    );
  }

  late final _git_odb_backend_data_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_odb_backend>,
              ffi.Pointer<ffi.Void>)>>('git_odb_backend_data_free');
  late final _git_odb_backend_data_free =
      _git_odb_backend_data_freePtr.asFunction<
          void Function(ffi.Pointer<git_odb_backend>, ffi.Pointer<ffi.Void>)>();

  /// Allocate memory for an ODB object from a custom backend.  This is
  /// an alias of `git_odb_backend_data_alloc` and is preserved for
  /// backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated git_odb_backend_data_alloc
  /// @see git_odb_backend_data_alloc
  ffi.Pointer<ffi.Void> git_odb_backend_malloc(
    ffi.Pointer<git_odb_backend> backend,
    int len,
  ) {
    return _git_odb_backend_malloc(
      backend,
      len,
    );
  }

  late final _git_odb_backend_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_odb_backend>,
              ffi.Size)>>('git_odb_backend_malloc');
  late final _git_odb_backend_malloc = _git_odb_backend_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_odb_backend>, int)>();

  /// Disposes libgit2-initialized fields from a git_remote_connect_options.
  /// This should only be used for git_remote_connect_options returned by
  /// git_transport_remote_connect_options.
  ///
  /// Note that this does not free the `git_remote_connect_options` itself, just
  /// the memory pointed to by it.
  ///
  /// @param opts The `git_remote_connect_options` struct to dispose.
  void git_remote_connect_options_dispose(
    ffi.Pointer<git_remote_connect_options> opts,
  ) {
    return _git_remote_connect_options_dispose(
      opts,
    );
  }

  late final _git_remote_connect_options_disposePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_remote_connect_options>)>>(
      'git_remote_connect_options_dispose');
  late final _git_remote_connect_options_dispose =
      _git_remote_connect_options_disposePtr
          .asFunction<void Function(ffi.Pointer<git_remote_connect_options>)>();

  /// Diff print callback that writes to a git_buf.
  ///
  /// This function is provided not for you to call it directly, but instead
  /// so you can use it as a function pointer to the `git_diff_print` or
  /// `git_patch_print` APIs.  When using those APIs, you specify a callback
  /// to actually handle the diff and/or patch data.
  ///
  /// Use this callback to easily write that data to a `git_buf` buffer.  You
  /// must pass a `git_buf *` value as the payload to the `git_diff_print`
  /// and/or `git_patch_print` function.  The data will be appended to the
  /// buffer (after any existing content).
  ///
  /// @param delta the delta being processed
  /// @param hunk the hunk being processed
  /// @param line the line being processed
  /// @param payload the payload provided by the diff generator
  /// @return 0 on success or an error code
  int git_diff_print_callback__to_buf(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_hunk> hunk,
    ffi.Pointer<git_diff_line> line,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_print_callback__to_buf(
      delta,
      hunk,
      line,
      payload,
    );
  }

  late final _git_diff_print_callback__to_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_diff_delta>,
              ffi.Pointer<git_diff_hunk>,
              ffi.Pointer<git_diff_line>,
              ffi.Pointer<ffi.Void>)>>('git_diff_print_callback__to_buf');
  late final _git_diff_print_callback__to_buf =
      _git_diff_print_callback__to_bufPtr.asFunction<
          int Function(ffi.Pointer<git_diff_delta>, ffi.Pointer<git_diff_hunk>,
              ffi.Pointer<git_diff_line>, ffi.Pointer<ffi.Void>)>();

  /// Diff print callback that writes to stdio FILE handle.
  ///
  /// This function is provided not for you to call it directly, but instead
  /// so you can use it as a function pointer to the `git_diff_print` or
  /// `git_patch_print` APIs.  When using those APIs, you specify a callback
  /// to actually handle the diff and/or patch data.
  ///
  /// Use this callback to easily write that data to a stdio FILE handle.  You
  /// must pass a `FILE *` value (such as `stdout` or `stderr` or the return
  /// value from `fopen()`) as the payload to the `git_diff_print`
  /// and/or `git_patch_print` function.  If you pass NULL, this will write
  /// data to `stdout`.
  ///
  /// @param delta the delta being processed
  /// @param hunk the hunk being processed
  /// @param line the line being processed
  /// @param payload the payload provided by the diff generator
  /// @return 0 on success or an error code
  int git_diff_print_callback__to_file_handle(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_hunk> hunk,
    ffi.Pointer<git_diff_line> line,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_print_callback__to_file_handle(
      delta,
      hunk,
      line,
      payload,
    );
  }

  late final _git_diff_print_callback__to_file_handlePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_diff_delta>,
                  ffi.Pointer<git_diff_hunk>,
                  ffi.Pointer<git_diff_line>,
                  ffi.Pointer<ffi.Void>)>>(
      'git_diff_print_callback__to_file_handle');
  late final _git_diff_print_callback__to_file_handle =
      _git_diff_print_callback__to_file_handlePtr.asFunction<
          int Function(ffi.Pointer<git_diff_delta>, ffi.Pointer<git_diff_hunk>,
              ffi.Pointer<git_diff_line>, ffi.Pointer<ffi.Void>)>();

  /// Get performance data for a diff object.
  ///
  /// @param out Structure to be filled with diff performance data
  /// @param diff Diff to read performance data from
  /// @return 0 for success, <0 for error
  int git_diff_get_perfdata(
    ffi.Pointer<git_diff_perfdata> out,
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_get_perfdata(
      out,
      diff,
    );
  }

  late final _git_diff_get_perfdataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_perfdata>,
              ffi.Pointer<git_diff>)>>('git_diff_get_perfdata');
  late final _git_diff_get_perfdata = _git_diff_get_perfdataPtr.asFunction<
      int Function(ffi.Pointer<git_diff_perfdata>, ffi.Pointer<git_diff>)>();

  /// Get performance data for diffs from a git_status_list
  ///
  /// @param out Structure to be filled with diff performance data
  /// @param status Diff to read performance data from
  /// @return 0 for success, <0 for error
  int git_status_list_get_perfdata(
    ffi.Pointer<git_diff_perfdata> out,
    ffi.Pointer<git_status_list> status,
  ) {
    return _git_status_list_get_perfdata(
      out,
      status,
    );
  }

  late final _git_status_list_get_perfdataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_perfdata>,
              ffi.Pointer<git_status_list>)>>('git_status_list_get_perfdata');
  late final _git_status_list_get_perfdata =
      _git_status_list_get_perfdataPtr.asFunction<
          int Function(
              ffi.Pointer<git_diff_perfdata>, ffi.Pointer<git_status_list>)>();

  /// Initialize git_commit_graph_open_options structure
  ///
  /// Initializes a `git_commit_graph_open_options` with default values.
  /// Equivalent to creating an instance with
  /// `GIT_COMMIT_GRAPH_OPEN_OPTIONS_INIT`.
  ///
  /// @param opts The `git_commit_graph_open_options` struct to initialize.
  /// @param version The struct version; pass `GIT_COMMIT_GRAPH_OPEN_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_commit_graph_open_options_init(
    ffi.Pointer<git_commit_graph_open_options> opts,
    int version,
  ) {
    return _git_commit_graph_open_options_init(
      opts,
      version,
    );
  }

  late final _git_commit_graph_open_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_commit_graph_open_options>,
              ffi.UnsignedInt)>>('git_commit_graph_open_options_init');
  late final _git_commit_graph_open_options_init =
      _git_commit_graph_open_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_commit_graph_open_options>, int)>();

  /// Opens a `git_commit_graph` from a path to an objects directory.
  ///
  /// This finds, opens, and validates the `commit-graph` file.
  ///
  /// @param cgraph_out the `git_commit_graph` struct to initialize.
  /// @param objects_dir the path to a git objects directory.
  /// @return Zero on success; -1 on failure.
  int git_commit_graph_open(
    ffi.Pointer<ffi.Pointer<git_commit_graph>> cgraph_out,
    ffi.Pointer<ffi.Char> objects_dir,
    ffi.Pointer<git_commit_graph_open_options> options,
  ) {
    return _git_commit_graph_open(
      cgraph_out,
      objects_dir,
      options,
    );
  }

  late final _git_commit_graph_openPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_commit_graph>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_commit_graph_open_options>)>>(
      'git_commit_graph_open');
  late final _git_commit_graph_open = _git_commit_graph_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_commit_graph>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_commit_graph_open_options>)>();

  /// Frees commit-graph data. This should only be called when memory allocated
  /// using `git_commit_graph_open` is not returned to libgit2 because it was not
  /// associated with the ODB through a successful call to
  /// `git_odb_set_commit_graph`.
  ///
  /// @param cgraph the commit-graph object to free. If NULL, no action is taken.
  void git_commit_graph_free(
    ffi.Pointer<git_commit_graph> cgraph,
  ) {
    return _git_commit_graph_free(
      cgraph,
    );
  }

  late final _git_commit_graph_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_commit_graph>)>>(
      'git_commit_graph_free');
  late final _git_commit_graph_free = _git_commit_graph_freePtr
      .asFunction<void Function(ffi.Pointer<git_commit_graph>)>();

  /// Initialize git_commit_graph_writer_options structure
  ///
  /// Initializes a `git_commit_graph_writer_options` with default values. Equivalent to
  /// creating an instance with `GIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT`.
  ///
  /// @param opts The `git_commit_graph_writer_options` struct to initialize.
  /// @param version The struct version; pass `GIT_COMMIT_GRAPH_WRITER_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_commit_graph_writer_options_init(
    ffi.Pointer<git_commit_graph_writer_options> opts,
    int version,
  ) {
    return _git_commit_graph_writer_options_init(
      opts,
      version,
    );
  }

  late final _git_commit_graph_writer_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_commit_graph_writer_options>,
              ffi.UnsignedInt)>>('git_commit_graph_writer_options_init');
  late final _git_commit_graph_writer_options_init =
      _git_commit_graph_writer_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_commit_graph_writer_options>, int)>();

  /// Create a new writer for `commit-graph` files.
  ///
  /// @param out Location to store the writer pointer.
  /// @param objects_info_dir The `objects/info` directory.
  /// The `commit-graph` file will be written in this directory.
  /// @param options The options for the commit graph writer.
  /// @return 0 or an error code
  int git_commit_graph_writer_new(
    ffi.Pointer<ffi.Pointer<git_commit_graph_writer>> out,
    ffi.Pointer<ffi.Char> objects_info_dir,
    ffi.Pointer<git_commit_graph_writer_options> options,
  ) {
    return _git_commit_graph_writer_new(
      out,
      objects_info_dir,
      options,
    );
  }

  late final _git_commit_graph_writer_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_commit_graph_writer>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_commit_graph_writer_options>)>>(
      'git_commit_graph_writer_new');
  late final _git_commit_graph_writer_new =
      _git_commit_graph_writer_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_commit_graph_writer>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_commit_graph_writer_options>)>();

  /// Free the commit-graph writer and its resources.
  ///
  /// @param w The writer to free. If NULL no action is taken.
  void git_commit_graph_writer_free(
    ffi.Pointer<git_commit_graph_writer> w,
  ) {
    return _git_commit_graph_writer_free(
      w,
    );
  }

  late final _git_commit_graph_writer_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_commit_graph_writer>)>>(
      'git_commit_graph_writer_free');
  late final _git_commit_graph_writer_free = _git_commit_graph_writer_freePtr
      .asFunction<void Function(ffi.Pointer<git_commit_graph_writer>)>();

  /// Add an `.idx` file (associated to a packfile) to the writer.
  ///
  /// @param w The writer.
  /// @param repo The repository that owns the `.idx` file.
  /// @param idx_path The path of an `.idx` file.
  /// @return 0 or an error code
  int git_commit_graph_writer_add_index_file(
    ffi.Pointer<git_commit_graph_writer> w,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> idx_path,
  ) {
    return _git_commit_graph_writer_add_index_file(
      w,
      repo,
      idx_path,
    );
  }

  late final _git_commit_graph_writer_add_index_filePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_commit_graph_writer>,
                  ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>>(
      'git_commit_graph_writer_add_index_file');
  late final _git_commit_graph_writer_add_index_file =
      _git_commit_graph_writer_add_index_filePtr.asFunction<
          int Function(ffi.Pointer<git_commit_graph_writer>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Add a revwalk to the writer. This will add all the commits from the revwalk
  /// to the commit-graph.
  ///
  /// @param w The writer.
  /// @param walk The git_revwalk.
  /// @return 0 or an error code
  int git_commit_graph_writer_add_revwalk(
    ffi.Pointer<git_commit_graph_writer> w,
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_commit_graph_writer_add_revwalk(
      w,
      walk,
    );
  }

  late final _git_commit_graph_writer_add_revwalkPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_commit_graph_writer>,
                  ffi.Pointer<git_revwalk>)>>(
      'git_commit_graph_writer_add_revwalk');
  late final _git_commit_graph_writer_add_revwalk =
      _git_commit_graph_writer_add_revwalkPtr.asFunction<
          int Function(ffi.Pointer<git_commit_graph_writer>,
              ffi.Pointer<git_revwalk>)>();

  /// Write a `commit-graph` file to a file.
  ///
  /// @param w The writer
  /// @return 0 or an error code
  int git_commit_graph_writer_commit(
    ffi.Pointer<git_commit_graph_writer> w,
  ) {
    return _git_commit_graph_writer_commit(
      w,
    );
  }

  late final _git_commit_graph_writer_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_commit_graph_writer>)>>(
      'git_commit_graph_writer_commit');
  late final _git_commit_graph_writer_commit =
      _git_commit_graph_writer_commitPtr
          .asFunction<int Function(ffi.Pointer<git_commit_graph_writer>)>();

  /// Dump the contents of the `commit-graph` to an in-memory buffer.
  ///
  /// @param[out] buffer Buffer where to store the contents of the `commit-graph`.
  /// @param w The writer.
  /// @return 0 or an error code
  int git_commit_graph_writer_dump(
    ffi.Pointer<git_buf> buffer,
    ffi.Pointer<git_commit_graph_writer> w,
  ) {
    return _git_commit_graph_writer_dump(
      buffer,
      w,
    );
  }

  late final _git_commit_graph_writer_dumpPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_buf>, ffi.Pointer<git_commit_graph_writer>)>>(
      'git_commit_graph_writer_dump');
  late final _git_commit_graph_writer_dump =
      _git_commit_graph_writer_dumpPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>, ffi.Pointer<git_commit_graph_writer>)>();

  /// Initializes a `git_transport` with default values. Equivalent to
  /// creating an instance with GIT_TRANSPORT_INIT.
  ///
  /// @param opts the `git_transport` struct to initialize
  /// @param version Version of struct; pass `GIT_TRANSPORT_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_transport_init(
    ffi.Pointer<git_transport> opts,
    int version,
  ) {
    return _git_transport_init(
      opts,
      version,
    );
  }

  late final _git_transport_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transport>,
              ffi.UnsignedInt)>>('git_transport_init');
  late final _git_transport_init = _git_transport_initPtr
      .asFunction<int Function(ffi.Pointer<git_transport>, int)>();

  /// Function to use to create a transport from a URL. The transport database
  /// is scanned to find a transport that implements the scheme of the URI (i.e.
  /// git:// or http://) and a transport object is returned to the caller.
  ///
  /// @param out The newly created transport (out)
  /// @param owner The git_remote which will own this transport
  /// @param url The URL to connect to
  /// @return 0 or an error code
  int git_transport_new(
    ffi.Pointer<ffi.Pointer<git_transport>> out,
    ffi.Pointer<git_remote> owner,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_transport_new(
      out,
      owner,
      url,
    );
  }

  late final _git_transport_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_transport>>,
              ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Char>)>>('git_transport_new');
  late final _git_transport_new = _git_transport_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transport>>,
          ffi.Pointer<git_remote>, ffi.Pointer<ffi.Char>)>();

  /// Create an ssh transport with custom git command paths
  ///
  /// This is a factory function suitable for setting as the transport
  /// callback in a remote (or for a clone in the options).
  ///
  /// The payload argument must be a strarray pointer with the paths for
  /// the `git-upload-pack` and `git-receive-pack` at index 0 and 1.
  ///
  /// @param out the resulting transport
  /// @param owner the owning remote
  /// @param payload a strarray with the paths
  /// @return 0 or an error code
  int git_transport_ssh_with_paths(
    ffi.Pointer<ffi.Pointer<git_transport>> out,
    ffi.Pointer<git_remote> owner,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_transport_ssh_with_paths(
      out,
      owner,
      payload,
    );
  }

  late final _git_transport_ssh_with_pathsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_transport>>,
              ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Void>)>>('git_transport_ssh_with_paths');
  late final _git_transport_ssh_with_paths =
      _git_transport_ssh_with_pathsPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_transport>>,
              ffi.Pointer<git_remote>, ffi.Pointer<ffi.Void>)>();

  /// Add a custom transport definition, to be used in addition to the built-in
  /// set of transports that come with libgit2.
  ///
  /// The caller is responsible for synchronizing calls to git_transport_register
  /// and git_transport_unregister with other calls to the library that
  /// instantiate transports.
  ///
  /// @param prefix The scheme (ending in "://") to match, i.e. "git://"
  /// @param cb The callback used to create an instance of the transport
  /// @param param A fixed parameter to pass to cb at creation time
  /// @return 0 or an error code
  int git_transport_register(
    ffi.Pointer<ffi.Char> prefix,
    git_transport_cb cb,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _git_transport_register(
      prefix,
      cb,
      param,
    );
  }

  late final _git_transport_registerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, git_transport_cb,
              ffi.Pointer<ffi.Void>)>>('git_transport_register');
  late final _git_transport_register = _git_transport_registerPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, git_transport_cb, ffi.Pointer<ffi.Void>)>();

  /// Unregister a custom transport definition which was previously registered
  /// with git_transport_register.
  ///
  /// The caller is responsible for synchronizing calls to git_transport_register
  /// and git_transport_unregister with other calls to the library that
  /// instantiate transports.
  ///
  /// @param prefix From the previous call to git_transport_register
  /// @return 0 or an error code
  int git_transport_unregister(
    ffi.Pointer<ffi.Char> prefix,
  ) {
    return _git_transport_unregister(
      prefix,
    );
  }

  late final _git_transport_unregisterPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'git_transport_unregister');
  late final _git_transport_unregister = _git_transport_unregisterPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Create an instance of the dummy transport.
  ///
  /// @param out The newly created transport (out)
  /// @param owner The git_remote which will own this transport
  /// @param payload You must pass NULL for this parameter.
  /// @return 0 or an error code
  int git_transport_dummy(
    ffi.Pointer<ffi.Pointer<git_transport>> out,
    ffi.Pointer<git_remote> owner,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_transport_dummy(
      out,
      owner,
      payload,
    );
  }

  late final _git_transport_dummyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_transport>>,
              ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Void>)>>('git_transport_dummy');
  late final _git_transport_dummy = _git_transport_dummyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transport>>,
          ffi.Pointer<git_remote>, ffi.Pointer<ffi.Void>)>();

  /// Create an instance of the local transport.
  ///
  /// @param out The newly created transport (out)
  /// @param owner The git_remote which will own this transport
  /// @param payload You must pass NULL for this parameter.
  /// @return 0 or an error code
  int git_transport_local(
    ffi.Pointer<ffi.Pointer<git_transport>> out,
    ffi.Pointer<git_remote> owner,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_transport_local(
      out,
      owner,
      payload,
    );
  }

  late final _git_transport_localPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_transport>>,
              ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Void>)>>('git_transport_local');
  late final _git_transport_local = _git_transport_localPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transport>>,
          ffi.Pointer<git_remote>, ffi.Pointer<ffi.Void>)>();

  /// Create an instance of the smart transport.
  ///
  /// @param out The newly created transport (out)
  /// @param owner The git_remote which will own this transport
  /// @param payload A pointer to a git_smart_subtransport_definition
  /// @return 0 or an error code
  int git_transport_smart(
    ffi.Pointer<ffi.Pointer<git_transport>> out,
    ffi.Pointer<git_remote> owner,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_transport_smart(
      out,
      owner,
      payload,
    );
  }

  late final _git_transport_smartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_transport>>,
              ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Void>)>>('git_transport_smart');
  late final _git_transport_smart = _git_transport_smartPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transport>>,
          ffi.Pointer<git_remote>, ffi.Pointer<ffi.Void>)>();

  /// Call the certificate check for this transport.
  ///
  /// @param transport a smart transport
  /// @param cert the certificate to pass to the caller
  /// @param valid whether we believe the certificate is valid
  /// @param hostname the hostname we connected to
  /// @return the return value of the callback: 0 for no error, GIT_PASSTHROUGH
  /// to indicate that there is no callback registered (or the callback
  /// refused to validate the certificate and callers should behave as
  /// if no callback was set), or < 0 for an error
  int git_transport_smart_certificate_check(
    ffi.Pointer<git_transport> transport,
    ffi.Pointer<git_cert> cert,
    int valid,
    ffi.Pointer<ffi.Char> hostname,
  ) {
    return _git_transport_smart_certificate_check(
      transport,
      cert,
      valid,
      hostname,
    );
  }

  late final _git_transport_smart_certificate_checkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transport>,
              ffi.Pointer<git_cert>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_transport_smart_certificate_check');
  late final _git_transport_smart_certificate_check =
      _git_transport_smart_certificate_checkPtr.asFunction<
          int Function(ffi.Pointer<git_transport>, ffi.Pointer<git_cert>, int,
              ffi.Pointer<ffi.Char>)>();

  /// Call the credentials callback for this transport
  ///
  /// @param out the pointer where the creds are to be stored
  /// @param transport a smart transport
  /// @param user the user we saw on the url (if any)
  /// @param methods available methods for authentication
  /// @return the return value of the callback: 0 for no error, GIT_PASSTHROUGH
  /// to indicate that there is no callback registered (or the callback
  /// refused to provide credentials and callers should behave as if no
  /// callback was set), or < 0 for an error
  int git_transport_smart_credentials(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<git_transport> transport,
    ffi.Pointer<ffi.Char> user,
    int methods,
  ) {
    return _git_transport_smart_credentials(
      out,
      transport,
      user,
      methods,
    );
  }

  late final _git_transport_smart_credentialsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<git_transport>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_transport_smart_credentials');
  late final _git_transport_smart_credentials =
      _git_transport_smart_credentialsPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<git_transport>, ffi.Pointer<ffi.Char>, int)>();

  /// Get a copy of the remote connect options
  ///
  /// All data is copied and must be freed by the caller by calling
  /// `git_remote_connect_options_dispose`.
  ///
  /// @param out options struct to fill
  /// @param transport the transport to extract the data from.
  /// @return 0 on success, or an error code
  int git_transport_remote_connect_options(
    ffi.Pointer<git_remote_connect_options> out,
    ffi.Pointer<git_transport> transport,
  ) {
    return _git_transport_remote_connect_options(
      out,
      transport,
    );
  }

  late final _git_transport_remote_connect_optionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_remote_connect_options>,
                  ffi.Pointer<git_transport>)>>(
      'git_transport_remote_connect_options');
  late final _git_transport_remote_connect_options =
      _git_transport_remote_connect_optionsPtr.asFunction<
          int Function(ffi.Pointer<git_remote_connect_options>,
              ffi.Pointer<git_transport>)>();

  /// Create an instance of the http subtransport.
  ///
  /// This subtransport also supports https.
  ///
  /// @param out The newly created subtransport
  /// @param owner The smart transport to own this subtransport
  /// @param param custom parameters for the subtransport
  /// @return 0 or an error code
  int git_smart_subtransport_http(
    ffi.Pointer<ffi.Pointer<git_smart_subtransport>> out,
    ffi.Pointer<git_transport> owner,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _git_smart_subtransport_http(
      out,
      owner,
      param,
    );
  }

  late final _git_smart_subtransport_httpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_smart_subtransport>>,
              ffi.Pointer<git_transport>,
              ffi.Pointer<ffi.Void>)>>('git_smart_subtransport_http');
  late final _git_smart_subtransport_http =
      _git_smart_subtransport_httpPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_smart_subtransport>>,
              ffi.Pointer<git_transport>, ffi.Pointer<ffi.Void>)>();

  /// Create an instance of the git subtransport.
  ///
  /// @param out The newly created subtransport
  /// @param owner The smart transport to own this subtransport
  /// @param param custom parameters for the subtransport
  /// @return 0 or an error code
  int git_smart_subtransport_git(
    ffi.Pointer<ffi.Pointer<git_smart_subtransport>> out,
    ffi.Pointer<git_transport> owner,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _git_smart_subtransport_git(
      out,
      owner,
      param,
    );
  }

  late final _git_smart_subtransport_gitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_smart_subtransport>>,
              ffi.Pointer<git_transport>,
              ffi.Pointer<ffi.Void>)>>('git_smart_subtransport_git');
  late final _git_smart_subtransport_git =
      _git_smart_subtransport_gitPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_smart_subtransport>>,
              ffi.Pointer<git_transport>, ffi.Pointer<ffi.Void>)>();

  /// Create an instance of the ssh subtransport.
  ///
  /// @param out The newly created subtransport
  /// @param owner The smart transport to own this subtransport
  /// @param param custom parameters for the subtransport
  /// @return 0 or an error code
  int git_smart_subtransport_ssh(
    ffi.Pointer<ffi.Pointer<git_smart_subtransport>> out,
    ffi.Pointer<git_transport> owner,
    ffi.Pointer<ffi.Void> param,
  ) {
    return _git_smart_subtransport_ssh(
      out,
      owner,
      param,
    );
  }

  late final _git_smart_subtransport_sshPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_smart_subtransport>>,
              ffi.Pointer<git_transport>,
              ffi.Pointer<ffi.Void>)>>('git_smart_subtransport_ssh');
  late final _git_smart_subtransport_ssh =
      _git_smart_subtransport_sshPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_smart_subtransport>>,
              ffi.Pointer<git_transport>, ffi.Pointer<ffi.Void>)>();

  /// Compute a similarity signature for a text buffer
  ///
  /// If you have passed the option GIT_HASHSIG_IGNORE_WHITESPACE, then the
  /// whitespace will be removed from the buffer while it is being processed,
  /// modifying the buffer in place. Sorry about that!
  ///
  /// @param out The computed similarity signature.
  /// @param buf The input buffer.
  /// @param buflen The input buffer size.
  /// @param opts The signature computation options (see above).
  /// @return 0 on success, GIT_EBUFS if the buffer doesn't contain enough data to
  /// compute a valid signature (unless GIT_HASHSIG_ALLOW_SMALL_FILES is set), or
  /// error code.
  int git_hashsig_create(
    ffi.Pointer<ffi.Pointer<git_hashsig>> out,
    ffi.Pointer<ffi.Char> buf,
    int buflen,
    git_hashsig_option_t opts,
  ) {
    return _git_hashsig_create(
      out,
      buf,
      buflen,
      opts.value,
    );
  }

  late final _git_hashsig_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_hashsig>>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.UnsignedInt)>>('git_hashsig_create');
  late final _git_hashsig_create = _git_hashsig_createPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_hashsig>>, ffi.Pointer<ffi.Char>,
          int, int)>();

  /// Compute a similarity signature for a text file
  ///
  /// This walks through the file, only loading a maximum of 4K of file data at
  /// a time. Otherwise, it acts just like `git_hashsig_create`.
  ///
  /// @param out The computed similarity signature.
  /// @param path The path to the input file.
  /// @param opts The signature computation options (see above).
  /// @return 0 on success, GIT_EBUFS if the buffer doesn't contain enough data to
  /// compute a valid signature (unless GIT_HASHSIG_ALLOW_SMALL_FILES is set), or
  /// error code.
  int git_hashsig_create_fromfile(
    ffi.Pointer<ffi.Pointer<git_hashsig>> out,
    ffi.Pointer<ffi.Char> path,
    git_hashsig_option_t opts,
  ) {
    return _git_hashsig_create_fromfile(
      out,
      path,
      opts.value,
    );
  }

  late final _git_hashsig_create_fromfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_hashsig>>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_hashsig_create_fromfile');
  late final _git_hashsig_create_fromfile =
      _git_hashsig_create_fromfilePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_hashsig>>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Release memory for a content similarity signature
  ///
  /// @param sig The similarity signature to free.
  void git_hashsig_free(
    ffi.Pointer<git_hashsig> sig,
  ) {
    return _git_hashsig_free(
      sig,
    );
  }

  late final _git_hashsig_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_hashsig>)>>(
          'git_hashsig_free');
  late final _git_hashsig_free = _git_hashsig_freePtr
      .asFunction<void Function(ffi.Pointer<git_hashsig>)>();

  /// Measure similarity score between two similarity signatures
  ///
  /// @param a The first similarity signature to compare.
  /// @param b The second similarity signature to compare.
  /// @return [0 to 100] on success as the similarity score, or error code.
  int git_hashsig_compare(
    ffi.Pointer<git_hashsig> a,
    ffi.Pointer<git_hashsig> b,
  ) {
    return _git_hashsig_compare(
      a,
      b,
    );
  }

  late final _git_hashsig_comparePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_hashsig>,
              ffi.Pointer<git_hashsig>)>>('git_hashsig_compare');
  late final _git_hashsig_compare = _git_hashsig_comparePtr.asFunction<
      int Function(ffi.Pointer<git_hashsig>, ffi.Pointer<git_hashsig>)>();

  /// Create a new direct reference from an OID.
  ///
  /// @param name the reference name
  /// @param oid the object id for a direct reference
  /// @param peel the first non-tag object's OID, or NULL
  /// @return the created git_reference or NULL on error
  ffi.Pointer<git_reference> git_reference__alloc(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_oid> peel,
  ) {
    return _git_reference__alloc(
      name,
      oid,
      peel,
    );
  }

  late final _git_reference__allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_reference> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_reference__alloc');
  late final _git_reference__alloc = _git_reference__allocPtr.asFunction<
      ffi.Pointer<git_reference> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Create a new symbolic reference.
  ///
  /// @param name the reference name
  /// @param target the target for a symbolic reference
  /// @return the created git_reference or NULL on error
  ffi.Pointer<git_reference> git_reference__alloc_symbolic(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> target,
  ) {
    return _git_reference__alloc_symbolic(
      name,
      target,
    );
  }

  late final _git_reference__alloc_symbolicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_reference> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_reference__alloc_symbolic');
  late final _git_reference__alloc_symbolic =
      _git_reference__alloc_symbolicPtr.asFunction<
          ffi.Pointer<git_reference> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Look up a filter by name
  ///
  /// @param name The name of the filter
  /// @return Pointer to the filter object or NULL if not found
  ffi.Pointer<git_filter> git_filter_lookup(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_filter_lookup(
      name,
    );
  }

  late final _git_filter_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_filter> Function(
              ffi.Pointer<ffi.Char>)>>('git_filter_lookup');
  late final _git_filter_lookup = _git_filter_lookupPtr
      .asFunction<ffi.Pointer<git_filter> Function(ffi.Pointer<ffi.Char>)>();

  /// Create a new empty filter list
  ///
  /// Normally you won't use this because `git_filter_list_load` will create
  /// the filter list for you, but you can use this in combination with the
  /// `git_filter_lookup` and `git_filter_list_push` functions to assemble
  /// your own chains of filters.
  ///
  /// @param out the filter list
  /// @param repo the repository to use for configuration
  /// @param mode the filter mode (direction)
  /// @param options the options
  /// @return 0 on success or an error code
  int git_filter_list_new(
    ffi.Pointer<ffi.Pointer<git_filter_list>> out,
    ffi.Pointer<git_repository> repo,
    git_filter_mode_t mode,
    int options,
  ) {
    return _git_filter_list_new(
      out,
      repo,
      mode.value,
      options,
    );
  }

  late final _git_filter_list_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_filter_list>>,
              ffi.Pointer<git_repository>,
              ffi.UnsignedInt,
              ffi.Uint32)>>('git_filter_list_new');
  late final _git_filter_list_new = _git_filter_list_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_filter_list>>,
          ffi.Pointer<git_repository>, int, int)>();

  /// Add a filter to a filter list with the given payload.
  ///
  /// Normally you won't have to do this because the filter list is created
  /// by calling the "check" function on registered filters when the filter
  /// attributes are set, but this does allow more direct manipulation of
  /// filter lists when desired.
  ///
  /// Note that normally the "check" function can set up a payload for the
  /// filter.  Using this function, you can either pass in a payload if you
  /// know the expected payload format, or you can pass NULL.  Some filters
  /// may fail with a NULL payload.  Good luck!
  ///
  /// @param fl the filter list
  /// @param filter the filter to push
  /// @param payload the payload for the filter
  /// @return 0 on success or an error code
  int git_filter_list_push(
    ffi.Pointer<git_filter_list> fl,
    ffi.Pointer<git_filter> filter,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_filter_list_push(
      fl,
      filter,
      payload,
    );
  }

  late final _git_filter_list_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_filter>,
              ffi.Pointer<ffi.Void>)>>('git_filter_list_push');
  late final _git_filter_list_push = _git_filter_list_pushPtr.asFunction<
      int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<git_filter>,
          ffi.Pointer<ffi.Void>)>();

  /// Look up how many filters are in the list
  ///
  /// We will attempt to apply all of these filters to any data passed in,
  /// but note that the filter apply action still has the option of skipping
  /// data that is passed in (for example, the CRLF filter will skip data
  /// that appears to be binary).
  ///
  /// @param fl A filter list
  /// @return The number of filters in the list
  int git_filter_list_length(
    ffi.Pointer<git_filter_list> fl,
  ) {
    return _git_filter_list_length(
      fl,
    );
  }

  late final _git_filter_list_lengthPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_filter_list>)>>(
      'git_filter_list_length');
  late final _git_filter_list_length = _git_filter_list_lengthPtr
      .asFunction<int Function(ffi.Pointer<git_filter_list>)>();

  /// Get the repository that the source data is coming from.
  ///
  /// @param src the filter source
  /// @return the repository for the filter information
  ffi.Pointer<git_repository> git_filter_source_repo(
    ffi.Pointer<git_filter_source> src,
  ) {
    return _git_filter_source_repo(
      src,
    );
  }

  late final _git_filter_source_repoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_filter_source>)>>('git_filter_source_repo');
  late final _git_filter_source_repo = _git_filter_source_repoPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_filter_source>)>();

  /// Get the path that the source data is coming from.
  ///
  /// @param src the filter source
  /// @return the path that is being filtered
  ffi.Pointer<ffi.Char> git_filter_source_path(
    ffi.Pointer<git_filter_source> src,
  ) {
    return _git_filter_source_path(
      src,
    );
  }

  late final _git_filter_source_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_filter_source>)>>('git_filter_source_path');
  late final _git_filter_source_path = _git_filter_source_pathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_filter_source>)>();

  /// Get the file mode of the source file
  /// If the mode is unknown, this will return 0
  ///
  /// @param src the filter source
  /// @return the file mode for the file being filtered
  int git_filter_source_filemode(
    ffi.Pointer<git_filter_source> src,
  ) {
    return _git_filter_source_filemode(
      src,
    );
  }

  late final _git_filter_source_filemodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint16 Function(ffi.Pointer<git_filter_source>)>>(
      'git_filter_source_filemode');
  late final _git_filter_source_filemode = _git_filter_source_filemodePtr
      .asFunction<int Function(ffi.Pointer<git_filter_source>)>();

  /// Get the OID of the source
  /// If the OID is unknown (often the case with GIT_FILTER_CLEAN) then
  /// this will return NULL.
  ///
  /// @param src the filter source
  /// @return the object id of the file being filtered
  ffi.Pointer<git_oid> git_filter_source_id(
    ffi.Pointer<git_filter_source> src,
  ) {
    return _git_filter_source_id(
      src,
    );
  }

  late final _git_filter_source_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_filter_source>)>>('git_filter_source_id');
  late final _git_filter_source_id = _git_filter_source_idPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_filter_source>)>();

  /// Get the git_filter_mode_t to be used
  ///
  /// @param src the filter source
  /// @return the mode (direction) of the filter
  git_filter_mode_t git_filter_source_mode(
    ffi.Pointer<git_filter_source> src,
  ) {
    return git_filter_mode_t.fromValue(_git_filter_source_mode(
      src,
    ));
  }

  late final _git_filter_source_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<git_filter_source>)>>('git_filter_source_mode');
  late final _git_filter_source_mode = _git_filter_source_modePtr
      .asFunction<int Function(ffi.Pointer<git_filter_source>)>();

  /// Get the combination git_filter_flag_t options to be applied
  ///
  /// @param src the filter source
  /// @return the flags of the filter
  int git_filter_source_flags(
    ffi.Pointer<git_filter_source> src,
  ) {
    return _git_filter_source_flags(
      src,
    );
  }

  late final _git_filter_source_flagsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<git_filter_source>)>>(
      'git_filter_source_flags');
  late final _git_filter_source_flags = _git_filter_source_flagsPtr
      .asFunction<int Function(ffi.Pointer<git_filter_source>)>();

  /// Initializes a `git_filter` with default values. Equivalent to
  /// creating an instance with GIT_FILTER_INIT.
  ///
  /// @param filter the `git_filter` struct to initialize.
  /// @param version Version the struct; pass `GIT_FILTER_VERSION`
  /// @return 0 on success; -1 on failure.
  int git_filter_init(
    ffi.Pointer<git_filter> filter,
    int version,
  ) {
    return _git_filter_init(
      filter,
      version,
    );
  }

  late final _git_filter_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_filter>, ffi.UnsignedInt)>>('git_filter_init');
  late final _git_filter_init = _git_filter_initPtr
      .asFunction<int Function(ffi.Pointer<git_filter>, int)>();

  /// Register a filter under a given name with a given priority.
  ///
  /// As mentioned elsewhere, the initialize callback will not be invoked
  /// immediately.  It is deferred until the filter is used in some way.
  ///
  /// A filter's attribute checks and `check` and `stream` (or `apply`)
  /// callbacks will be issued in order of `priority` on smudge (to
  /// workdir), and in reverse order of `priority` on clean (to odb).
  ///
  /// Two filters are preregistered with libgit2:
  /// - GIT_FILTER_CRLF with priority 0
  /// - GIT_FILTER_IDENT with priority 100
  ///
  /// Currently the filter registry is not thread safe, so any registering or
  /// deregistering of filters must be done outside of any possible usage of
  /// the filters (i.e. during application setup or shutdown).
  ///
  /// @param name A name by which the filter can be referenced.  Attempting
  /// to register with an in-use name will return GIT_EEXISTS.
  /// @param filter The filter definition.  This pointer will be stored as is
  /// by libgit2 so it must be a durable allocation (either static
  /// or on the heap).
  /// @param priority The priority for filter application
  /// @return 0 on successful registry, error code <0 on failure
  int git_filter_register(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_filter> filter,
    int priority,
  ) {
    return _git_filter_register(
      name,
      filter,
      priority,
    );
  }

  late final _git_filter_registerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_filter>,
              ffi.Int)>>('git_filter_register');
  late final _git_filter_register = _git_filter_registerPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_filter>, int)>();

  /// Remove the filter with the given name
  ///
  /// Attempting to remove the builtin libgit2 filters is not permitted and
  /// will return an error.
  ///
  /// Currently the filter registry is not thread safe, so any registering or
  /// deregistering of filters must be done outside of any possible usage of
  /// the filters (i.e. during application setup or shutdown).
  ///
  /// @param name The name under which the filter was registered
  /// @return 0 on success, error code <0 on failure
  int git_filter_unregister(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_filter_unregister(
      name,
    );
  }

  late final _git_filter_unregisterPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'git_filter_unregister');
  late final _git_filter_unregister = _git_filter_unregisterPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Initialize the allocator structure to use the `stdalloc` pointer.
  ///
  /// Set up the structure so that all of its members are using the standard
  /// "stdalloc" allocator functions. The structure can then be used with
  /// `git_allocator_setup`.
  ///
  /// @param allocator The allocator that is to be initialized.
  /// @return An error code or 0.
  int git_stdalloc_init_allocator(
    ffi.Pointer<git_allocator> allocator,
  ) {
    return _git_stdalloc_init_allocator(
      allocator,
    );
  }

  late final _git_stdalloc_init_allocatorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_allocator>)>>(
          'git_stdalloc_init_allocator');
  late final _git_stdalloc_init_allocator = _git_stdalloc_init_allocatorPtr
      .asFunction<int Function(ffi.Pointer<git_allocator>)>();

  /// Initialize the allocator structure to use the `crtdbg` pointer.
  ///
  /// Set up the structure so that all of its members are using the "crtdbg"
  /// allocator functions. Note that this allocator is only available on Windows
  /// platforms and only if libgit2 is being compiled with "-DMSVC_CRTDBG".
  ///
  /// @param allocator The allocator that is to be initialized.
  /// @return An error code or 0.
  int git_win32_crtdbg_init_allocator(
    ffi.Pointer<git_allocator> allocator,
  ) {
    return _git_win32_crtdbg_init_allocator(
      allocator,
    );
  }

  late final _git_win32_crtdbg_init_allocatorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_allocator>)>>(
          'git_win32_crtdbg_init_allocator');
  late final _git_win32_crtdbg_init_allocator =
      _git_win32_crtdbg_init_allocatorPtr
          .asFunction<int Function(ffi.Pointer<git_allocator>)>();

  /// Instantiate a new mempack backend.
  ///
  /// The backend must be added to an existing ODB with the highest
  /// priority.
  ///
  /// git_mempack_new(&mempacker);
  /// git_repository_odb(&odb, repository);
  /// git_odb_add_backend(odb, mempacker, 999);
  ///
  /// Once the backend has been loaded, all writes to the ODB will
  /// instead be queued in memory, and can be finalized with
  /// `git_mempack_dump`.
  ///
  /// Subsequent reads will also be served from the in-memory store
  /// to ensure consistency, until the memory store is dumped.
  ///
  /// @param out Pointer where to store the ODB backend
  /// @return 0 on success; error code otherwise
  int git_mempack_new(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ) {
    return _git_mempack_new(
      out,
    );
  }

  late final _git_mempack_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_backend>>)>>('git_mempack_new');
  late final _git_mempack_new = _git_mempack_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>)>();

  /// Write a thin packfile with the objects in the memory store.
  ///
  /// A thin packfile is a packfile that does not contain its transitive closure of
  /// references. This is useful for efficiently distributing additions to a
  /// repository over the network, but also finds use in the efficient bulk
  /// addition of objects to a repository, locally.
  ///
  /// This operation performs the (shallow) insert operations into the
  /// `git_packbuilder`, but does not write the packfile to disk;
  /// see `git_packbuilder_write_buf`.
  ///
  /// It also does not reset the in-memory object database; see `git_mempack_reset`.
  ///
  /// @param backend The mempack backend
  /// @param pb The packbuilder to use to write the packfile
  /// @return 0 on success or an error code
  int git_mempack_write_thin_pack(
    ffi.Pointer<git_odb_backend> backend,
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_mempack_write_thin_pack(
      backend,
      pb,
    );
  }

  late final _git_mempack_write_thin_packPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_backend>,
              ffi.Pointer<git_packbuilder>)>>('git_mempack_write_thin_pack');
  late final _git_mempack_write_thin_pack =
      _git_mempack_write_thin_packPtr.asFunction<
          int Function(
              ffi.Pointer<git_odb_backend>, ffi.Pointer<git_packbuilder>)>();

  /// Dump all the queued in-memory writes to a packfile.
  ///
  /// The contents of the packfile will be stored in the given buffer.
  /// It is the caller's responsibility to ensure that the generated
  /// packfile is available to the repository (e.g. by writing it
  /// to disk, or doing something crazy like distributing it across
  /// several copies of the repository over a network).
  ///
  /// Once the generated packfile is available to the repository,
  /// call `git_mempack_reset` to cleanup the memory store.
  ///
  /// Calling `git_mempack_reset` before the packfile has been
  /// written to disk will result in an inconsistent repository
  /// (the objects in the memory store won't be accessible).
  ///
  /// @param pack Buffer where to store the raw packfile
  /// @param repo The active repository where the backend is loaded
  /// @param backend The mempack backend
  /// @return 0 on success; error code otherwise
  int git_mempack_dump(
    ffi.Pointer<git_buf> pack,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_odb_backend> backend,
  ) {
    return _git_mempack_dump(
      pack,
      repo,
      backend,
    );
  }

  late final _git_mempack_dumpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<git_odb_backend>)>>('git_mempack_dump');
  late final _git_mempack_dump = _git_mempack_dumpPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_odb_backend>)>();

  /// Reset the memory packer by clearing all the queued objects.
  ///
  /// This assumes that `git_mempack_dump` has been called before to
  /// store all the queued objects into a single packfile.
  ///
  /// Alternatively, call `reset` without a previous dump to "undo"
  /// all the recently written objects, giving transaction-like
  /// semantics to the Git repository.
  ///
  /// @param backend The mempack backend
  /// @return 0 on success; error code otherwise
  int git_mempack_reset(
    ffi.Pointer<git_odb_backend> backend,
  ) {
    return _git_mempack_reset(
      backend,
    );
  }

  late final _git_mempack_resetPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_backend>)>>(
      'git_mempack_reset');
  late final _git_mempack_reset = _git_mempack_resetPtr
      .asFunction<int Function(ffi.Pointer<git_odb_backend>)>();

  /// Get the total number of objects in mempack
  ///
  /// @param count The count of objects in the mempack
  /// @param backend The mempack backend
  /// @return 0 on success, or -1 on error
  int git_mempack_object_count(
    ffi.Pointer<ffi.Size> count,
    ffi.Pointer<git_odb_backend> backend,
  ) {
    return _git_mempack_object_count(
      count,
      backend,
    );
  }

  late final _git_mempack_object_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_odb_backend>)>>('git_mempack_object_count');
  late final _git_mempack_object_count =
      _git_mempack_object_countPtr.asFunction<
          int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_odb_backend>)>();

  /// Create new commit in the repository from a list of `git_oid` values.
  ///
  /// See documentation for `git_commit_create()` for information about the
  /// parameters, as the meaning is identical excepting that `tree` and
  /// `parents` now take `git_oid`.  This is a dangerous API in that nor
  /// the `tree`, neither the `parents` list of `git_oid`s are checked for
  /// validity.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int git_commit_create_from_ids(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_oid> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_oid>> parents,
  ) {
    return _git_commit_create_from_ids(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _git_commit_create_from_idsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_oid>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_oid>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<git_oid>>)>>(
      'git_commit_create_from_ids');
  late final _git_commit_create_from_ids =
      _git_commit_create_from_idsPtr.asFunction<
          int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              int,
              ffi.Pointer<ffi.Pointer<git_oid>>)>();

  /// Create a new commit in the repository with an callback to supply parents.
  ///
  /// See documentation for `git_commit_create()` for information about the
  /// parameters, as the meaning is identical excepting that `tree` takes a
  /// `git_oid` and doesn't check for validity, and `parent_cb` is invoked
  /// with `parent_payload` and should return `git_oid` values or NULL to
  /// indicate that all parents are accounted for.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_cb Callback to invoke to obtain parent information
  ///
  /// @param parent_payload User-specified payload to provide to the callback
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int git_commit_create_from_callback(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_oid> tree,
    git_commit_parent_callback parent_cb,
    ffi.Pointer<ffi.Void> parent_payload,
  ) {
    return _git_commit_create_from_callback(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_cb,
      parent_payload,
    );
  }

  late final _git_commit_create_from_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              git_commit_parent_callback,
              ffi.Pointer<ffi.Void>)>>('git_commit_create_from_callback');
  late final _git_commit_create_from_callback =
      _git_commit_create_from_callbackPtr.asFunction<
          int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              git_commit_parent_callback,
              ffi.Pointer<ffi.Void>)>();

  /// Initializes a `git_refdb_backend` with default values. Equivalent to
  /// creating an instance with GIT_REFDB_BACKEND_INIT.
  ///
  /// @param backend the `git_refdb_backend` struct to initialize
  /// @param version Version of struct; pass `GIT_REFDB_BACKEND_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_refdb_init_backend(
    ffi.Pointer<git_refdb_backend> backend,
    int version,
  ) {
    return _git_refdb_init_backend(
      backend,
      version,
    );
  }

  late final _git_refdb_init_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refdb_backend>,
              ffi.UnsignedInt)>>('git_refdb_init_backend');
  late final _git_refdb_init_backend = _git_refdb_init_backendPtr
      .asFunction<int Function(ffi.Pointer<git_refdb_backend>, int)>();

  /// Constructors for default filesystem-based refdb backend
  ///
  /// Under normal usage, this is called for you when the repository is
  /// opened / created, but you can use this to explicitly construct a
  /// filesystem refdb backend for a repository.
  ///
  /// @param backend_out Output pointer to the git_refdb_backend object
  /// @param repo Git repository to access
  /// @return 0 on success, <0 error code on failure
  int git_refdb_backend_fs(
    ffi.Pointer<ffi.Pointer<git_refdb_backend>> backend_out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_refdb_backend_fs(
      backend_out,
      repo,
    );
  }

  late final _git_refdb_backend_fsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb_backend>>,
              ffi.Pointer<git_repository>)>>('git_refdb_backend_fs');
  late final _git_refdb_backend_fs = _git_refdb_backend_fsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_refdb_backend>>,
          ffi.Pointer<git_repository>)>();

  /// Sets the custom backend to an existing reference DB
  ///
  /// The `git_refdb` will take ownership of the `git_refdb_backend` so you
  /// should NOT free it after calling this function.
  ///
  /// @param refdb database to add the backend to
  /// @param backend pointer to a git_refdb_backend instance
  /// @return 0 on success; error code otherwise
  int git_refdb_set_backend(
    ffi.Pointer<git_refdb> refdb,
    ffi.Pointer<git_refdb_backend> backend,
  ) {
    return _git_refdb_set_backend(
      refdb,
      backend,
    );
  }

  late final _git_refdb_set_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refdb>,
              ffi.Pointer<git_refdb_backend>)>>('git_refdb_set_backend');
  late final _git_refdb_set_backend = _git_refdb_set_backendPtr.asFunction<
      int Function(ffi.Pointer<git_refdb>, ffi.Pointer<git_refdb_backend>)>();
}

typedef __int8_t = ffi.SignedChar;
typedef Dart__int8_t = int;
typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;
typedef __int16_t = ffi.Short;
typedef Dart__int16_t = int;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;
typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;
typedef __darwin_intptr_t = ffi.Long;
typedef Dart__darwin_intptr_t = int;
typedef __darwin_natural_t = ffi.UnsignedInt;
typedef Dart__darwin_natural_t = int;

/// The rune type below is declared to be an ``int'' instead of the more natural
/// ``unsigned long'' or ``long''.  Two things are happening here.  It is not
/// unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
/// it looks like 10646 will be a 31 bit standard.  This means that if your
/// ints cannot hold 32 bits, you will be in trouble.  The reason an int was
/// chosen over a long is that the is*() and to*() routines take ints (says
/// ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
/// here, you lose a bit of ANSI conformance, but your programs will still
/// work.
///
/// NOTE: rune_t is not covered by ANSI nor other standards, and should not
/// be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
/// rune_t must be the same type.  Also wint_t must be no narrower than
/// wchar_t, and should also be able to hold all members of the largest
/// character set plus one extra value (WEOF). wint_t must be at least 16 bits.
typedef __darwin_ct_rune_t = ffi.Int;
typedef Dart__darwin_ct_rune_t = int;

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

typedef __darwin_mbstate_t = __mbstate_t;
typedef __darwin_ptrdiff_t = ffi.Long;
typedef Dart__darwin_ptrdiff_t = int;
typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;
typedef __builtin_va_list = ffi.Pointer<ffi.Char>;
typedef __darwin_va_list = __builtin_va_list;
typedef __darwin_wchar_t = ffi.Int;
typedef Dart__darwin_wchar_t = int;
typedef __darwin_rune_t = __darwin_wchar_t;
typedef __darwin_wint_t = ffi.Int;
typedef Dart__darwin_wint_t = int;
typedef __darwin_clock_t = ffi.UnsignedLong;
typedef Dart__darwin_clock_t = int;
typedef __darwin_socklen_t = __uint32_t;
typedef __darwin_ssize_t = ffi.Long;
typedef Dart__darwin_ssize_t = int;
typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_blkcnt_t = __int64_t;
typedef __darwin_blksize_t = __int32_t;
typedef __darwin_dev_t = __int32_t;
typedef __darwin_fsblkcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsblkcnt_t = int;
typedef __darwin_fsfilcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsfilcnt_t = int;
typedef __darwin_gid_t = __uint32_t;
typedef __darwin_id_t = __uint32_t;
typedef __darwin_ino64_t = __uint64_t;
typedef __darwin_ino_t = __darwin_ino64_t;
typedef __darwin_mach_port_name_t = __darwin_natural_t;
typedef __darwin_mach_port_t = __darwin_mach_port_name_t;
typedef __darwin_mode_t = __uint16_t;
typedef __darwin_off_t = __int64_t;
typedef __darwin_pid_t = __int32_t;
typedef __darwin_sigset_t = __uint32_t;
typedef __darwin_suseconds_t = __int32_t;
typedef __darwin_uid_t = __uint32_t;
typedef __darwin_useconds_t = __uint32_t;

final class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;
typedef __darwin_pthread_cond_t = _opaque_pthread_cond_t;
typedef __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
typedef __darwin_pthread_key_t = ffi.UnsignedLong;
typedef Dart__darwin_pthread_key_t = int;
typedef __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
typedef __darwin_pthread_once_t = _opaque_pthread_once_t;
typedef __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
typedef __darwin_pthread_t = ffi.Pointer<_opaque_pthread_t>;
typedef __darwin_nl_item = ffi.Int;
typedef Dart__darwin_nl_item = int;
typedef __darwin_wctrans_t = ffi.Int;
typedef Dart__darwin_wctrans_t = int;
typedef __darwin_wctype_t = __uint32_t;
typedef u_int8_t = ffi.UnsignedChar;
typedef Dartu_int8_t = int;
typedef u_int16_t = ffi.UnsignedShort;
typedef Dartu_int16_t = int;
typedef u_int32_t = ffi.UnsignedInt;
typedef Dartu_int32_t = int;
typedef u_int64_t = ffi.UnsignedLongLong;
typedef Dartu_int64_t = int;
typedef register_t = ffi.Int64;
typedef Dartregister_t = int;
typedef user_addr_t = u_int64_t;
typedef user_size_t = u_int64_t;
typedef user_ssize_t = ffi.Int64;
typedef Dartuser_ssize_t = int;
typedef user_long_t = ffi.Int64;
typedef Dartuser_long_t = int;
typedef user_ulong_t = u_int64_t;
typedef user_time_t = ffi.Int64;
typedef Dartuser_time_t = int;
typedef user_off_t = ffi.Int64;
typedef Dartuser_off_t = int;
typedef syscall_arg_t = u_int64_t;
typedef clock_t = __darwin_clock_t;
typedef time_t = __darwin_time_t;

final class timespec extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @ffi.Long()
  external int tv_nsec;
}

final class tm extends ffi.Struct {
  /// seconds after the minute [0-60]
  @ffi.Int()
  external int tm_sec;

  /// minutes after the hour [0-59]
  @ffi.Int()
  external int tm_min;

  /// hours since midnight [0-23]
  @ffi.Int()
  external int tm_hour;

  /// day of the month [1-31]
  @ffi.Int()
  external int tm_mday;

  /// months since January [0-11]
  @ffi.Int()
  external int tm_mon;

  /// years since 1900
  @ffi.Int()
  external int tm_year;

  /// days since Sunday [0-6]
  @ffi.Int()
  external int tm_wday;

  /// days since January 1 [0-365]
  @ffi.Int()
  external int tm_yday;

  /// Daylight Savings Time flag
  @ffi.Int()
  external int tm_isdst;

  /// offset from UTC in seconds
  @ffi.Long()
  external int tm_gmtoff;

  /// timezone abbreviation
  external ffi.Pointer<ffi.Char> tm_zone;
}

enum clockid_t {
  _CLOCK_REALTIME(0),
  _CLOCK_MONOTONIC(6),
  _CLOCK_MONOTONIC_RAW(4),
  _CLOCK_MONOTONIC_RAW_APPROX(5),
  _CLOCK_UPTIME_RAW(8),
  _CLOCK_UPTIME_RAW_APPROX(9),
  _CLOCK_PROCESS_CPUTIME_ID(12),
  _CLOCK_THREAD_CPUTIME_ID(16);

  final int value;
  const clockid_t(this.value);

  static clockid_t fromValue(int value) => switch (value) {
        0 => _CLOCK_REALTIME,
        6 => _CLOCK_MONOTONIC,
        4 => _CLOCK_MONOTONIC_RAW,
        5 => _CLOCK_MONOTONIC_RAW_APPROX,
        8 => _CLOCK_UPTIME_RAW,
        9 => _CLOCK_UPTIME_RAW_APPROX,
        12 => _CLOCK_PROCESS_CPUTIME_ID,
        16 => _CLOCK_THREAD_CPUTIME_ID,
        _ => throw ArgumentError('Unknown value for clockid_t: $value'),
      };
}

/// [XSI] The type idtype_t shall be defined as an enumeration type whose
/// possible values shall include at least P_ALL, P_PID, and P_PGID.
enum idtype_t {
  P_ALL(0),
  P_PID(1),
  P_PGID(2);

  final int value;
  const idtype_t(this.value);

  static idtype_t fromValue(int value) => switch (value) {
        0 => P_ALL,
        1 => P_PID,
        2 => P_PGID,
        _ => throw ArgumentError('Unknown value for idtype_t: $value'),
      };
}

typedef pid_t = __darwin_pid_t;
typedef id_t = __darwin_id_t;
typedef sig_atomic_t = ffi.Int;
typedef Dartsig_atomic_t = int;

final class __darwin_arm_exception_state extends ffi.Struct {
  /// number of arm exception taken
  @__uint32_t()
  external int __exception;

  /// Fault status
  @__uint32_t()
  external int __fsr;

  /// Virtual Fault Address
  @__uint32_t()
  external int __far;
}

final class __darwin_arm_exception_state64 extends ffi.Struct {
  /// Virtual Fault Address
  @__uint64_t()
  external int __far;

  /// Exception syndrome
  @__uint32_t()
  external int __esr;

  /// number of arm exception taken
  @__uint32_t()
  external int __exception;
}

final class __darwin_arm_exception_state64_v2 extends ffi.Struct {
  /// Virtual Fault Address
  @__uint64_t()
  external int __far;

  /// Exception syndrome
  @__uint64_t()
  external int __esr;
}

final class __darwin_arm_thread_state extends ffi.Struct {
  /// General purpose register r0-r12
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  /// Stack pointer r13
  @__uint32_t()
  external int __sp;

  /// Link register r14
  @__uint32_t()
  external int __lr;

  /// Program counter r15
  @__uint32_t()
  external int __pc;

  /// Current program status register
  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  /// General purpose registers x0-x28
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  /// Frame pointer x29
  @__uint64_t()
  external int __fp;

  /// Link register x30
  @__uint64_t()
  external int __lr;

  /// Stack pointer x31
  @__uint64_t()
  external int __sp;

  /// Program counter
  @__uint64_t()
  external int __pc;

  /// Current program status register
  @__uint32_t()
  external int __cpsr;

  /// Same size for 32-bit or 64-bit clients
  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __darwin_arm_sme_state extends ffi.Struct {
  @__uint64_t()
  external int __svcr;

  @__uint64_t()
  external int __tpidr2_el0;

  @__uint16_t()
  external int __svl_b;
}

final class __darwin_arm_sve_z_state extends ffi.Struct {
  @ffi.Array.multi([16, 256])
  external ffi.Array<ffi.Array<ffi.Char>> __z;
}

final class __darwin_arm_sve_p_state extends ffi.Struct {
  @ffi.Array.multi([16, 32])
  external ffi.Array<ffi.Array<ffi.Char>> __p;
}

final class __darwin_arm_sme_za_state extends ffi.Struct {
  @ffi.Array.multi([4096])
  external ffi.Array<ffi.Char> __za;
}

final class __darwin_arm_sme2_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> __zt0;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  /// Bit 0 is SS (Hardware Single Step)
  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  /// Bit 0 is SS (Hardware Single Step)
  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

typedef mcontext_t = ffi.Pointer<__darwin_mcontext64>;
typedef pthread_attr_t = __darwin_pthread_attr_t;

final class __darwin_sigaltstack extends ffi.Struct {
  /// signal stack base
  external ffi.Pointer<ffi.Void> ss_sp;

  /// signal stack length
  @__darwin_size_t()
  external int ss_size;

  /// SA_DISABLE and/or SA_ONSTACK
  @ffi.Int()
  external int ss_flags;
}

typedef stack_t = __darwin_sigaltstack;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  /// signal mask used by this context
  @__darwin_sigset_t()
  external int uc_sigmask;

  /// stack used by this context
  external __darwin_sigaltstack uc_stack;

  /// pointer to resuming context
  external ffi.Pointer<__darwin_ucontext> uc_link;

  /// size of the machine context passed in
  @__darwin_size_t()
  external int uc_mcsize;

  /// pointer to machine specific context
  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

/// user context
typedef ucontext_t = __darwin_ucontext;
typedef sigset_t = __darwin_sigset_t;
typedef uid_t = __darwin_uid_t;

final class sigval extends ffi.Union {
  /// Members as suggested by Annex C of POSIX 1003.1b.
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  /// Notification type
  @ffi.Int()
  external int sigev_notify;

  /// Signal number
  @ffi.Int()
  external int sigev_signo;

  /// Signal value
  external sigval sigev_value;

  /// Notification function
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  /// Notification attributes
  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

final class __siginfo extends ffi.Struct {
  /// signal number
  @ffi.Int()
  external int si_signo;

  /// errno association
  @ffi.Int()
  external int si_errno;

  /// signal code
  @ffi.Int()
  external int si_code;

  /// sending process
  @pid_t()
  external int si_pid;

  /// sender's ruid
  @uid_t()
  external int si_uid;

  /// exit value
  @ffi.Int()
  external int si_status;

  /// faulting instruction
  external ffi.Pointer<ffi.Void> si_addr;

  /// signal value
  external sigval si_value;

  /// band event for SIGPOLL
  @ffi.Long()
  external int si_band;

  /// Reserved for Future Use
  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef siginfo_t = __siginfo;

/// union for signal handlers
final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

/// Signal vector template for Kernel user boundary
final class __sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u$1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

/// Signal vector "template" used in sigaction call.
final class sigaction extends ffi.Struct {
  /// signal handler
  external __sigaction_u __sigaction_u$1;

  /// signal mask to apply
  @sigset_t()
  external int sa_mask;

  /// see signal options below
  @ffi.Int()
  external int sa_flags;
}

typedef sig_tFunction = ffi.Void Function(ffi.Int);
typedef Dartsig_tFunction = void Function(int);
typedef sig_t = ffi.Pointer<ffi.NativeFunction<sig_tFunction>>;

/// 4.3 compatibility:
/// Signal vector "template" used in sigvec call.
final class sigvec extends ffi.Struct {
  /// signal handler
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  /// signal mask to apply
  @ffi.Int()
  external int sv_mask;

  /// see signal options below
  @ffi.Int()
  external int sv_flags;
}

/// Structure used in sigstack call.
final class sigstack extends ffi.Struct {
  /// signal stack pointer
  external ffi.Pointer<ffi.Char> ss_sp;

  /// current status
  @ffi.Int()
  external int ss_onstack;
}

/// 7.18.1.2 Minimum-width integer types
typedef int_least8_t = ffi.Int8;
typedef Dartint_least8_t = int;
typedef int_least16_t = ffi.Int16;
typedef Dartint_least16_t = int;
typedef int_least32_t = ffi.Int32;
typedef Dartint_least32_t = int;
typedef int_least64_t = ffi.Int64;
typedef Dartint_least64_t = int;
typedef uint_least8_t = ffi.Uint8;
typedef Dartuint_least8_t = int;
typedef uint_least16_t = ffi.Uint16;
typedef Dartuint_least16_t = int;
typedef uint_least32_t = ffi.Uint32;
typedef Dartuint_least32_t = int;
typedef uint_least64_t = ffi.Uint64;
typedef Dartuint_least64_t = int;

/// 7.18.1.3 Fastest-width integer types
typedef int_fast8_t = ffi.Int8;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Int16;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Int32;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Int64;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.Uint8;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.Uint16;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.Uint32;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.Uint64;
typedef Dartuint_fast64_t = int;
typedef intmax_t = ffi.Long;
typedef Dartintmax_t = int;
typedef uintmax_t = ffi.UnsignedLong;
typedef Dartuintmax_t = int;

final class timeval extends ffi.Struct {
  /// seconds
  @__darwin_time_t()
  external int tv_sec;

  /// and microseconds
  @__darwin_suseconds_t()
  external int tv_usec;
}

/// Resource limit type (low 63 bits, excluding the sign bit)
typedef rlim_t = __uint64_t;

/// A structure representing an accounting of resource utilization.  The
/// address of an instance of this structure is the second parameter to
/// getrusage().
///
/// Note: All values other than ru_utime and ru_stime are implementaiton
/// defined and subject to change in a future release.  Their use
/// is discouraged for standards compliant programs.
final class rusage extends ffi.Struct {
  /// user time used (PL)
  external timeval ru_utime;

  /// system time used (PL)
  external timeval ru_stime;

  /// max resident set size (PL)
  @ffi.Long()
  external int ru_maxrss;

  /// integral shared memory size (NU)
  @ffi.Long()
  external int ru_ixrss;

  /// integral unshared data (NU)
  @ffi.Long()
  external int ru_idrss;

  /// integral unshared stack (NU)
  @ffi.Long()
  external int ru_isrss;

  /// page reclaims (NU)
  @ffi.Long()
  external int ru_minflt;

  /// page faults (NU)
  @ffi.Long()
  external int ru_majflt;

  /// swaps (NU)
  @ffi.Long()
  external int ru_nswap;

  /// block input operations (atomic)
  @ffi.Long()
  external int ru_inblock;

  /// block output operations (atomic)
  @ffi.Long()
  external int ru_oublock;

  /// messages sent (atomic)
  @ffi.Long()
  external int ru_msgsnd;

  /// messages received (atomic)
  @ffi.Long()
  external int ru_msgrcv;

  /// signals received (atomic)
  @ffi.Long()
  external int ru_nsignals;

  /// voluntary context switches (atomic)
  @ffi.Long()
  external int ru_nvcsw;

  /// involuntary "
  @ffi.Long()
  external int ru_nivcsw;
}

typedef rusage_info_t = ffi.Pointer<ffi.Void>;

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Uint64()
  external int ri_neural_footprint;

  @ffi.Uint64()
  external int ri_lifetime_max_neural_footprint;

  @ffi.Uint64()
  external int ri_interval_max_neural_footprint;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

typedef rusage_info_current = rusage_info_v6;

/// A structure representing a resource limit.  The address of an instance
/// of this structure is the second parameter to getrlimit()/setrlimit().
final class rlimit extends ffi.Struct {
  /// current (soft) limit
  @rlim_t()
  external int rlim_cur;

  /// maximum value for rlim_cur
  @rlim_t()
  external int rlim_max;
}

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

/// Deprecated:
/// Structure of the information in the status word returned by wait4.
/// If w_stopval==_WSTOPPED, then the second structure describes
/// the information returned, else the first.
final class wait extends ffi.Opaque {}

typedef ct_rune_t = __darwin_ct_rune_t;
typedef rune_t = __darwin_rune_t;

final class div_t extends ffi.Struct {
  /// quotient
  @ffi.Int()
  external int quot;

  /// remainder
  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  /// quotient
  @ffi.Long()
  external int quot;

  /// remainder
  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

/// <malloc/malloc.h>
typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef mode_t = __darwin_mode_t;

/// 7.8.2.2
final class imaxdiv_t extends ffi.Struct {
  @intmax_t()
  external int quot;

  @intmax_t()
  external int rem;
}

/// Configurable features of libgit2; either optional settings (like
/// threading), or features that can be enabled by one of a number of
/// different backend "providers" (like HTTPS, which can be provided by
/// OpenSSL, mbedTLS, or system libraries).
enum git_feature_t {
  /// libgit2 is thread-aware and can be used from multiple threads
  /// (as described in the documentation).
  GIT_FEATURE_THREADS(1),

  /// HTTPS remotes
  GIT_FEATURE_HTTPS(2),

  /// SSH remotes
  GIT_FEATURE_SSH(4),

  /// Sub-second resolution in index timestamps
  GIT_FEATURE_NSEC(8),

  /// HTTP parsing; always available
  GIT_FEATURE_HTTP_PARSER(16),

  /// Regular expression support; always available
  GIT_FEATURE_REGEX(32),

  /// Internationalization support for filename translation
  GIT_FEATURE_I18N(64),

  /// NTLM support over HTTPS
  GIT_FEATURE_AUTH_NTLM(128),

  /// Kerberos (SPNEGO) authentication support over HTTPS
  GIT_FEATURE_AUTH_NEGOTIATE(256),

  /// zlib support; always available
  GIT_FEATURE_COMPRESSION(512),

  /// SHA1 object support; always available
  GIT_FEATURE_SHA1(1024),

  /// SHA256 object support
  GIT_FEATURE_SHA256(2048);

  final int value;
  const git_feature_t(this.value);

  static git_feature_t fromValue(int value) => switch (value) {
        1 => GIT_FEATURE_THREADS,
        2 => GIT_FEATURE_HTTPS,
        4 => GIT_FEATURE_SSH,
        8 => GIT_FEATURE_NSEC,
        16 => GIT_FEATURE_HTTP_PARSER,
        32 => GIT_FEATURE_REGEX,
        64 => GIT_FEATURE_I18N,
        128 => GIT_FEATURE_AUTH_NTLM,
        256 => GIT_FEATURE_AUTH_NEGOTIATE,
        512 => GIT_FEATURE_COMPRESSION,
        1024 => GIT_FEATURE_SHA1,
        2048 => GIT_FEATURE_SHA256,
        _ => throw ArgumentError('Unknown value for git_feature_t: $value'),
      };
}

/// Global library options
///
/// These are used to select which global option to set or get and are
/// used in `git_libgit2_opts()`.
enum git_libgit2_opt_t {
  GIT_OPT_GET_MWINDOW_SIZE(0),
  GIT_OPT_SET_MWINDOW_SIZE(1),
  GIT_OPT_GET_MWINDOW_MAPPED_LIMIT(2),
  GIT_OPT_SET_MWINDOW_MAPPED_LIMIT(3),
  GIT_OPT_GET_SEARCH_PATH(4),
  GIT_OPT_SET_SEARCH_PATH(5),
  GIT_OPT_SET_CACHE_OBJECT_LIMIT(6),
  GIT_OPT_SET_CACHE_MAX_SIZE(7),
  GIT_OPT_ENABLE_CACHING(8),
  GIT_OPT_GET_CACHED_MEMORY(9),
  GIT_OPT_GET_TEMPLATE_PATH(10),
  GIT_OPT_SET_TEMPLATE_PATH(11),
  GIT_OPT_SET_SSL_CERT_LOCATIONS(12),
  GIT_OPT_SET_USER_AGENT(13),
  GIT_OPT_ENABLE_STRICT_OBJECT_CREATION(14),
  GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION(15),
  GIT_OPT_SET_SSL_CIPHERS(16),
  GIT_OPT_GET_USER_AGENT(17),
  GIT_OPT_ENABLE_OFS_DELTA(18),
  GIT_OPT_ENABLE_FSYNC_GITDIR(19),
  GIT_OPT_GET_WINDOWS_SHAREMODE(20),
  GIT_OPT_SET_WINDOWS_SHAREMODE(21),
  GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION(22),
  GIT_OPT_SET_ALLOCATOR(23),
  GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY(24),
  GIT_OPT_GET_PACK_MAX_OBJECTS(25),
  GIT_OPT_SET_PACK_MAX_OBJECTS(26),
  GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS(27),
  GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE(28),
  GIT_OPT_GET_MWINDOW_FILE_LIMIT(29),
  GIT_OPT_SET_MWINDOW_FILE_LIMIT(30),
  GIT_OPT_SET_ODB_PACKED_PRIORITY(31),
  GIT_OPT_SET_ODB_LOOSE_PRIORITY(32),
  GIT_OPT_GET_EXTENSIONS(33),
  GIT_OPT_SET_EXTENSIONS(34),
  GIT_OPT_GET_OWNER_VALIDATION(35),
  GIT_OPT_SET_OWNER_VALIDATION(36),
  GIT_OPT_GET_HOMEDIR(37),
  GIT_OPT_SET_HOMEDIR(38),
  GIT_OPT_SET_SERVER_CONNECT_TIMEOUT(39),
  GIT_OPT_GET_SERVER_CONNECT_TIMEOUT(40),
  GIT_OPT_SET_SERVER_TIMEOUT(41),
  GIT_OPT_GET_SERVER_TIMEOUT(42),
  GIT_OPT_SET_USER_AGENT_PRODUCT(43),
  GIT_OPT_GET_USER_AGENT_PRODUCT(44),
  GIT_OPT_ADD_SSL_X509_CERT(45);

  final int value;
  const git_libgit2_opt_t(this.value);

  static git_libgit2_opt_t fromValue(int value) => switch (value) {
        0 => GIT_OPT_GET_MWINDOW_SIZE,
        1 => GIT_OPT_SET_MWINDOW_SIZE,
        2 => GIT_OPT_GET_MWINDOW_MAPPED_LIMIT,
        3 => GIT_OPT_SET_MWINDOW_MAPPED_LIMIT,
        4 => GIT_OPT_GET_SEARCH_PATH,
        5 => GIT_OPT_SET_SEARCH_PATH,
        6 => GIT_OPT_SET_CACHE_OBJECT_LIMIT,
        7 => GIT_OPT_SET_CACHE_MAX_SIZE,
        8 => GIT_OPT_ENABLE_CACHING,
        9 => GIT_OPT_GET_CACHED_MEMORY,
        10 => GIT_OPT_GET_TEMPLATE_PATH,
        11 => GIT_OPT_SET_TEMPLATE_PATH,
        12 => GIT_OPT_SET_SSL_CERT_LOCATIONS,
        13 => GIT_OPT_SET_USER_AGENT,
        14 => GIT_OPT_ENABLE_STRICT_OBJECT_CREATION,
        15 => GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION,
        16 => GIT_OPT_SET_SSL_CIPHERS,
        17 => GIT_OPT_GET_USER_AGENT,
        18 => GIT_OPT_ENABLE_OFS_DELTA,
        19 => GIT_OPT_ENABLE_FSYNC_GITDIR,
        20 => GIT_OPT_GET_WINDOWS_SHAREMODE,
        21 => GIT_OPT_SET_WINDOWS_SHAREMODE,
        22 => GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION,
        23 => GIT_OPT_SET_ALLOCATOR,
        24 => GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY,
        25 => GIT_OPT_GET_PACK_MAX_OBJECTS,
        26 => GIT_OPT_SET_PACK_MAX_OBJECTS,
        27 => GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS,
        28 => GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE,
        29 => GIT_OPT_GET_MWINDOW_FILE_LIMIT,
        30 => GIT_OPT_SET_MWINDOW_FILE_LIMIT,
        31 => GIT_OPT_SET_ODB_PACKED_PRIORITY,
        32 => GIT_OPT_SET_ODB_LOOSE_PRIORITY,
        33 => GIT_OPT_GET_EXTENSIONS,
        34 => GIT_OPT_SET_EXTENSIONS,
        35 => GIT_OPT_GET_OWNER_VALIDATION,
        36 => GIT_OPT_SET_OWNER_VALIDATION,
        37 => GIT_OPT_GET_HOMEDIR,
        38 => GIT_OPT_SET_HOMEDIR,
        39 => GIT_OPT_SET_SERVER_CONNECT_TIMEOUT,
        40 => GIT_OPT_GET_SERVER_CONNECT_TIMEOUT,
        41 => GIT_OPT_SET_SERVER_TIMEOUT,
        42 => GIT_OPT_GET_SERVER_TIMEOUT,
        43 => GIT_OPT_SET_USER_AGENT_PRODUCT,
        44 => GIT_OPT_GET_USER_AGENT_PRODUCT,
        45 => GIT_OPT_ADD_SSL_X509_CERT,
        _ => throw ArgumentError('Unknown value for git_libgit2_opt_t: $value'),
      };
}

typedef u_char = ffi.UnsignedChar;
typedef Dartu_char = int;
typedef u_short = ffi.UnsignedShort;
typedef Dartu_short = int;
typedef u_int = ffi.UnsignedInt;
typedef Dartu_int = int;
typedef u_long = ffi.UnsignedLong;
typedef Dartu_long = int;
typedef ushort = ffi.UnsignedShort;
typedef Dartushort = int;
typedef uint = ffi.UnsignedInt;
typedef Dartuint = int;
typedef u_quad_t = u_int64_t;
typedef quad_t = ffi.Int64;
typedef Dartquad_t = int;
typedef qaddr_t = ffi.Pointer<quad_t>;
typedef caddr_t = ffi.Pointer<ffi.Char>;
typedef daddr_t = ffi.Int32;
typedef Dartdaddr_t = int;
typedef fixpt_t = u_int32_t;
typedef blkcnt_t = __darwin_blkcnt_t;
typedef blksize_t = __darwin_blksize_t;
typedef gid_t = __darwin_gid_t;
typedef in_addr_t = __uint32_t;
typedef in_port_t = __uint16_t;
typedef ino_t = __darwin_ino_t;
typedef ino64_t = __darwin_ino64_t;
typedef key_t = __int32_t;
typedef nlink_t = __uint16_t;
typedef off_t = __darwin_off_t;
typedef segsz_t = ffi.Int32;
typedef Dartsegsz_t = int;
typedef swblk_t = ffi.Int32;
typedef Dartswblk_t = int;
typedef ssize_t = __darwin_ssize_t;
typedef useconds_t = __darwin_useconds_t;
typedef suseconds_t = __darwin_suseconds_t;
typedef rsize_t = __darwin_size_t;
typedef errno_t = ffi.Int;
typedef Darterrno_t = int;

final class fd_set extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__int32_t> fds_bits;
}

typedef fd_mask = __int32_t;
typedef pthread_cond_t = __darwin_pthread_cond_t;
typedef pthread_condattr_t = __darwin_pthread_condattr_t;
typedef pthread_mutex_t = __darwin_pthread_mutex_t;
typedef pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
typedef pthread_once_t = __darwin_pthread_once_t;
typedef pthread_rwlock_t = __darwin_pthread_rwlock_t;
typedef pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
typedef pthread_t = __darwin_pthread_t;
typedef pthread_key_t = __darwin_pthread_key_t;
typedef fsblkcnt_t = __darwin_fsblkcnt_t;
typedef fsfilcnt_t = __darwin_fsfilcnt_t;

/// Note: Can't use off_t since if a client program includes <sys/types.h>
/// before us (directly or indirectly), they'll get 32 bit off_t in their client
/// app, even though /we/ define _FILE_OFFSET_BITS=64.
typedef git_off_t = ffi.Int64;
typedef Dartgit_off_t = int;
typedef git_time_t = ffi.Int64;
typedef Dartgit_time_t = int;

/// The maximum size of an object
typedef git_object_size_t = ffi.Uint64;
typedef Dartgit_object_size_t = int;

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// To make ownership clear in these cases, libgit2 uses  `git_buf` to
/// return this data.  Callers should use `git_buf_dispose()` to release
/// the memory when they are done.
///
/// A `git_buf` contains a pointer to a NUL-terminated C string, and
/// the length of the string (not including the NUL terminator).
final class git_buf extends ffi.Struct {
  /// The buffer contents.  `ptr` points to the start of the buffer
  /// being returned.  The buffer's length (in bytes) is specified
  /// by the `size` member of the structure, and contains a NUL
  /// terminator at position `(size + 1)`.
  external ffi.Pointer<ffi.Char> ptr;

  /// This field is reserved and unused.
  @ffi.Size()
  external int reserved;

  /// The length (in bytes) of the buffer pointed to by `ptr`,
  /// not including a NUL terminator.
  @ffi.Size()
  external int size;
}

/// The type of object id.
enum git_oid_t {
  /// < SHA1
  GIT_OID_SHA1(1),

  /// < SHA256
  GIT_OID_SHA256(2);

  final int value;
  const git_oid_t(this.value);

  static git_oid_t fromValue(int value) => switch (value) {
        1 => GIT_OID_SHA1,
        2 => GIT_OID_SHA256,
        _ => throw ArgumentError('Unknown value for git_oid_t: $value'),
      };
}

/// Unique identity of any object (commit, tree, blob, tag).
final class git_oid extends ffi.Struct {
  /// type of object id
  @ffi.UnsignedChar()
  external int type;

  /// raw binary formatted id
  @ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedChar> id;
}

final class git_oid_shorten extends ffi.Opaque {}

/// Basic type (loose or packed) of any Git object.
enum git_object_t {
  /// < Object can be any of the following
  GIT_OBJECT_ANY(-2),

  /// < Object is invalid.
  GIT_OBJECT_INVALID(-1),

  /// < A commit object.
  GIT_OBJECT_COMMIT(1),

  /// < A tree (directory listing) object.
  GIT_OBJECT_TREE(2),

  /// < A file revision object.
  GIT_OBJECT_BLOB(3),

  /// < An annotated tag object.
  GIT_OBJECT_TAG(4),

  /// < A delta, base is given by an offset.
  GIT_OBJECT_OFS_DELTA(6),

  /// < A delta, base is given by object id.
  GIT_OBJECT_REF_DELTA(7);

  final int value;
  const git_object_t(this.value);

  static git_object_t fromValue(int value) => switch (value) {
        -2 => GIT_OBJECT_ANY,
        -1 => GIT_OBJECT_INVALID,
        1 => GIT_OBJECT_COMMIT,
        2 => GIT_OBJECT_TREE,
        3 => GIT_OBJECT_BLOB,
        4 => GIT_OBJECT_TAG,
        6 => GIT_OBJECT_OFS_DELTA,
        7 => GIT_OBJECT_REF_DELTA,
        _ => throw ArgumentError('Unknown value for git_object_t: $value'),
      };
}

final class git_odb extends ffi.Opaque {}

/// A stream to read/write from a backend.
///
/// This represents a stream of data being written to or read from a
/// backend. When writing, the frontend functions take care of
/// calculating the object's id and all `finalize_write` needs to do is
/// store the object with the id it is passed.
final class git_odb_stream extends ffi.Struct {
  external ffi.Pointer<git_odb_backend> backend;

  @ffi.UnsignedInt()
  external int mode;

  external ffi.Pointer<ffi.Void> hash_ctx;

  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

  @git_object_size_t()
  external int declared_size;

  @git_object_size_t()
  external int received_bytes;

  /// Write at most `len` bytes into `buffer` and advance the stream.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream> stream,
              ffi.Pointer<ffi.Char> buffer, ffi.Size len)>> read;

  /// Write `len` bytes from `buffer` into the stream.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream> stream,
              ffi.Pointer<ffi.Char> buffer, ffi.Size len)>> write;

  /// Store the contents of the stream as an object with the id
  /// specified in `oid`.
  ///
  /// This method might not be invoked if:
  /// - an error occurs earlier with the `write` callback,
  /// - the object referred to by `oid` already exists in any backend, or
  /// - the final number of received bytes differs from the size declared
  /// with `git_odb_open_wstream()`
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream> stream,
              ffi.Pointer<git_oid> oid)>> finalize_write;

  /// Free the stream's memory.
  ///
  /// This method might be called without a call to `finalize_write` if
  /// an error occurs or if the object is already present in the ODB.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_odb_stream> stream)>> free;
}

typedef git_odb_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<git_oid> id, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_odb_foreach_cbFunction = int Function(
    ffi.Pointer<git_oid> id, ffi.Pointer<ffi.Void> payload);

/// Function type for callbacks from git_odb_foreach.
///
/// @param id an id of an object in the object database
/// @param payload the payload from the initial call to git_odb_foreach
/// @return 0 on success, or an error code
typedef git_odb_foreach_cb
    = ffi.Pointer<ffi.NativeFunction<git_odb_foreach_cbFunction>>;

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
final class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.UnsignedInt()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.UnsignedInt()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.UnsignedInt()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.UnsignedInt()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.Size()
  external int received_bytes;
}

/// A stream to write a pack file to the ODB
final class git_odb_writepack extends ffi.Struct {
  external ffi.Pointer<git_odb_backend> backend;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_odb_writepack> writepack,
              ffi.Pointer<ffi.Void> data,
              ffi.Size size,
              ffi.Pointer<git_indexer_progress> stats)>> append;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_writepack> writepack,
              ffi.Pointer<git_indexer_progress> stats)>> commit;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_odb_writepack> writepack)>> free;
}

typedef git_indexer_progress_cbFunction = ffi.Int Function(
    ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_indexer_progress_cbFunction = int Function(
    ffi.Pointer<git_indexer_progress> stats, ffi.Pointer<ffi.Void> payload);

/// Type for progress callbacks during indexing.  Return a value less
/// than zero to cancel the indexing or download.
///
/// @param stats Structure containing information about the state of the transfer
/// @param payload Payload provided by caller
/// @return 0 on success or an error code
typedef git_indexer_progress_cb
    = ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cbFunction>>;

/// An instance for a custom backend
final class git_odb_backend extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  external ffi.Pointer<git_odb> odb;

  /// read and read_prefix each return to libgit2 a buffer which
  /// will be freed later. The buffer should be allocated using
  /// the function git_odb_backend_data_alloc to ensure that libgit2
  /// can safely free it later.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_odb_backend>,
              ffi.Pointer<git_oid>)>> read;

  /// To find a unique object given a prefix of its oid.  The oid given
  /// must be so that the remaining (GIT_OID_SHA1_HEXSIZE - len)*4 bits are 0s.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_odb_backend>,
              ffi.Pointer<git_oid>,
              ffi.Size)>> read_prefix;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_odb_backend>, ffi.Pointer<git_oid>)>> read_header;

  /// Write an object into the backend. The id of the object has
  /// already been calculated and is passed in.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_backend>, ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>> write;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_stream>>,
              ffi.Pointer<git_odb_backend>,
              git_object_size_t,
              ffi.Int)>> writestream;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_stream>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_odb_backend>,
              ffi.Pointer<git_oid>)>> readstream;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_odb_backend>, ffi.Pointer<git_oid>)>> exists;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb_backend>,
              ffi.Pointer<git_oid>, ffi.Size)>> exists_prefix;

  /// If the backend implements a refreshing mechanism, it should be exposed
  /// through this endpoint. Each call to `git_odb_refresh()` will invoke it.
  ///
  /// The odb layer will automatically call this when needed on failed
  /// lookups (ie. `exists()`, `read()`, `read_header()`).
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_backend>)>>
      refresh;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_backend>, git_odb_foreach_cb,
              ffi.Pointer<ffi.Void>)>> foreach;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_writepack>>,
              ffi.Pointer<git_odb_backend>,
              ffi.Pointer<git_odb>,
              git_indexer_progress_cb,
              ffi.Pointer<ffi.Void>)>> writepack;

  /// If the backend supports pack files, this will create a
  /// `multi-pack-index` file which will contain an index of all objects
  /// across all the `.pack` files.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb_backend>)>>
      writemidx;

  /// "Freshens" an already existing object, updating its last-used
  /// time.  This occurs when `git_odb_write` was called, but the
  /// object already existed (and will not be re-written).  The
  /// underlying implementation may want to update last-used timestamps.
  ///
  /// If callers implement this, they should return `0` if the object
  /// exists and was freshened, and non-zero otherwise.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_odb_backend>, ffi.Pointer<git_oid>)>> freshen;

  /// Frees any resources held by the odb (including the `git_odb_backend`
  /// itself). An odb backend implementation must provide this function.
  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_backend>)>> free;
}

final class git_odb_object extends ffi.Opaque {}

final class git_midx_writer extends ffi.Opaque {}

final class git_refdb extends ffi.Opaque {}

final class git_reference extends ffi.Opaque {}

/// Every backend's iterator must have a pointer to itself as the first
/// element, so the API can talk to it. You'd define your iterator as
///
/// struct my_iterator {
/// git_reference_iterator parent;
/// ...
/// }
///
/// and assign `iter->parent.backend` to your `git_refdb_backend`.
final class git_reference_iterator extends ffi.Struct {
  external ffi.Pointer<git_refdb> db;

  /// Return the current reference and advance the iterator.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>> ref,
              ffi.Pointer<git_reference_iterator> iter)>> next;

  /// Return the name of the current reference and advance the iterator
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>> ref_name,
              ffi.Pointer<git_reference_iterator> iter)>> next_name;

  /// Free the iterator
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_reference_iterator> iter)>> free;
}

/// Time in a signature
final class git_time extends ffi.Struct {
  /// < time in seconds from epoch
  @git_time_t()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Char()
  external int sign;
}

/// An action signature (e.g. for committers, taggers, etc)
final class git_signature extends ffi.Struct {
  /// < full name of the author
  external ffi.Pointer<ffi.Char> name;

  /// < email of the author
  external ffi.Pointer<ffi.Char> email;

  /// < time when the action happened
  external git_time when;
}

final class git_reflog extends ffi.Opaque {}

/// An instance for a custom backend
final class git_refdb_backend extends ffi.Struct {
  /// < The backend API version
  @ffi.UnsignedInt()
  external int version;

  /// Queries the refdb backend for the existence of a reference.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param exists The implementation shall set this to `0` if a ref does
  /// not exist, otherwise to `1`.
  /// @param ref_name The reference's name that should be checked for
  /// existence.
  /// @return `0` on success, a negative error value code.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int> exists,
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> ref_name)>> exists;

  /// Queries the refdb backend for a given reference.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param out The implementation shall set this to the allocated
  /// reference, if it could be found, otherwise to `NULL`.
  /// @param ref_name The reference's name that should be checked for
  /// existence.
  /// @return `0` on success, `GIT_ENOTFOUND` if the reference does
  /// exist, otherwise a negative error code.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>> out,
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> ref_name)>> lookup;

  /// Allocate an iterator object for the backend.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param out The implementation shall set this to the allocated
  /// reference iterator. A custom structure may be used with an
  /// embedded `git_reference_iterator` structure. Both `next`
  /// and `next_name` functions of `git_reference_iterator` need
  /// to be populated.
  /// @param glob A pattern to filter references by. If given, the iterator
  /// shall only return references that match the glob when
  /// passed to `wildmatch`.
  /// @return `0` on success, otherwise a negative error code.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference_iterator>> iter,
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> glob)>> iterator;

  /// Writes the given reference to the refdb.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param ref The reference to persist. May either be a symbolic or
  /// direct reference.
  /// @param force Whether to write the reference if a reference with the
  /// same name already exists.
  /// @param who The person updating the reference. Shall be used to create
  /// a reflog entry.
  /// @param message The message detailing what kind of reference update is
  /// performed. Shall be used to create a reflog entry.
  /// @param old If not `NULL` and `force` is not set, then the
  /// implementation needs to ensure that the reference is currently at
  /// the given OID before writing the new value. If both `old`
  /// and `old_target` are `NULL`, then the reference should not
  /// exist at the point of writing.
  /// @param old_target If not `NULL` and `force` is not set, then the
  /// implementation needs to ensure that the symbolic
  /// reference is currently at the given target before
  /// writing the new value. If both `old` and
  /// `old_target` are `NULL`, then the reference should
  /// not exist at the point of writing.
  /// @return `0` on success, otherwise a negative error code.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<git_reference> ref,
              ffi.Int force,
              ffi.Pointer<git_signature> who,
              ffi.Pointer<ffi.Char> message,
              ffi.Pointer<git_oid> old,
              ffi.Pointer<ffi.Char> old_target)>> write;

  /// Rename a reference in the refdb.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param out The implementation shall set this to the newly created
  /// reference or `NULL` on error.
  /// @param old_name The current name of the reference that is to be renamed.
  /// @param new_name The new name that the old reference shall be renamed to.
  /// @param force Whether to write the reference if a reference with the
  /// target name already exists.
  /// @param who The person updating the reference. Shall be used to create
  /// a reflog entry.
  /// @param message The message detailing what kind of reference update is
  /// performed. Shall be used to create a reflog entry.
  /// @return `0` on success, otherwise a negative error code.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>> out,
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> old_name,
              ffi.Pointer<ffi.Char> new_name,
              ffi.Int force,
              ffi.Pointer<git_signature> who,
              ffi.Pointer<ffi.Char> message)>> rename;

  /// Deletes the given reference from the refdb.
  ///
  /// If it exists, its reflog should be deleted as well.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param ref_name The name of the reference name that shall be deleted.
  /// @param old_id If not `NULL` and `force` is not set, then the
  /// implementation needs to ensure that the reference is currently at
  /// the given OID before writing the new value.
  /// @param old_target If not `NULL` and `force` is not set, then the
  /// implementation needs to ensure that the symbolic
  /// reference is currently at the given target before
  /// writing the new value.
  /// @return `0` on success, otherwise a negative error code.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> ref_name,
              ffi.Pointer<git_oid> old_id,
              ffi.Pointer<ffi.Char> old_target)>> del;

  /// Suggests that the given refdb compress or optimize its references.
  ///
  /// This mechanism is implementation specific. For on-disk reference
  /// databases, this may pack all loose references.
  ///
  /// A refdb implementation may provide this function; if it is not
  /// provided, nothing will be done.
  ///
  /// @return `0` on success a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refdb_backend> backend)>> compress;

  /// Query whether a particular reference has a log (may be empty)
  ///
  /// Shall return 1 if it has a reflog, 0 it it doesn't and negative in
  /// case an error occurred.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @return `0` on success, `1` if the reflog for the given reference
  /// exists, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> refname)>> has_log;

  /// Make sure a particular reference will have a reflog which
  /// will be appended to on writes.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @return `0` on success, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> refname)>> ensure_log;

  /// Frees any resources held by the refdb (including the `git_refdb_backend`
  /// itself).
  ///
  /// A refdb backend implementation must provide this function.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_refdb_backend> backend)>> free;

  /// Read the reflog for the given reference name.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @return `0` on success, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reflog>> out,
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> name)>> reflog_read;

  /// Write a reflog to disk.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param reflog The complete reference log for a given reference. Note
  /// that this may contain entries that have already been
  /// written to disk.
  /// @return `0` on success, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<git_reflog> reflog)>> reflog_write;

  /// Rename a reflog.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param old_name The name of old reference whose reflog shall be renamed from.
  /// @param new_name The name of new reference whose reflog shall be renamed to.
  /// @return `0` on success, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_refdb_backend> _backend,
              ffi.Pointer<ffi.Char> old_name,
              ffi.Pointer<ffi.Char> new_name)>> reflog_rename;

  /// Remove a reflog.
  ///
  /// A refdb implementation must provide this function.
  ///
  /// @param name The name of the reference whose reflog shall be deleted.
  /// @return `0` on success, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> name)>> reflog_delete;

  /// Lock a reference.
  ///
  /// A refdb implementation may provide this function; if it is not
  /// provided, the transaction API will fail to work.
  ///
  /// @param payload_out Opaque parameter that will be passed verbosely to
  /// `unlock`.
  /// @param refname Reference that shall be locked.
  /// @return `0` on success, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>> payload_out,
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Char> refname)>> lock;

  /// Unlock a reference.
  ///
  /// Only one of target or symbolic_target will be set.
  /// `success` will be true if the reference should be update, false if
  /// the lock must be discarded.
  ///
  /// A refdb implementation must provide this function if a `lock`
  /// implementation is provided.
  ///
  /// @param payload The payload returned by `lock`.
  /// @param success `1` if a reference should be updated, `2` if
  /// a reference should be deleted, `0` if the lock must be
  /// discarded.
  /// @param update_reflog `1` in case the reflog should be updated, `0`
  /// otherwise.
  /// @param ref The reference which should be unlocked.
  /// @param who The person updating the reference. Shall be used to create
  /// a reflog entry in case `update_reflog` is set.
  /// @param message The message detailing what kind of reference update is
  /// performed. Shall be used to create a reflog entry in
  /// case `update_reflog` is set.
  /// @return `0` on success, a negative error code otherwise
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_refdb_backend> backend,
              ffi.Pointer<ffi.Void> payload,
              ffi.Int success,
              ffi.Int update_reflog,
              ffi.Pointer<git_reference> ref,
              ffi.Pointer<git_signature> sig,
              ffi.Pointer<ffi.Char> message)>> unlock;
}

final class git_commit_graph extends ffi.Opaque {}

final class git_commit_graph_writer extends ffi.Opaque {}

final class git_repository extends ffi.Opaque {}

final class git_worktree extends ffi.Opaque {}

final class git_object extends ffi.Opaque {}

final class git_revwalk extends ffi.Opaque {}

final class git_tag extends ffi.Opaque {}

final class git_blob extends ffi.Opaque {}

final class git_commit extends ffi.Opaque {}

final class git_tree_entry extends ffi.Opaque {}

final class git_tree extends ffi.Opaque {}

final class git_treebuilder extends ffi.Opaque {}

final class git_index extends ffi.Opaque {}

final class git_index_iterator extends ffi.Opaque {}

final class git_index_conflict_iterator extends ffi.Opaque {}

final class git_config extends ffi.Opaque {}

/// Priority level of a config file.
///
/// These priority levels correspond to the natural escalation logic
/// (from higher to lower) when reading or searching for config entries
/// in git.git. Meaning that for the same key, the configuration in
/// the local configuration is preferred over the configuration in
/// the system configuration file.
///
/// Callers can add their own custom configuration, beginning at the
/// `GIT_CONFIG_LEVEL_APP` level.
///
/// Writes, by default, occur in the highest priority level backend
/// that is writable. This ordering can be overridden with
/// `git_config_set_writeorder`.
///
/// git_config_open_default() and git_repository_config() honor those
/// priority levels as well.
///
/// @see git_config_open_default
/// @see git_repository_config
enum git_config_level_t {
  /// System-wide on Windows, for compatibility with "Portable Git".
  GIT_CONFIG_LEVEL_PROGRAMDATA(1),

  /// System-wide configuration file; `/etc/gitconfig` on Linux.
  GIT_CONFIG_LEVEL_SYSTEM(2),

  /// XDG compatible configuration file; typically
  /// `~/.config/git/config`.
  GIT_CONFIG_LEVEL_XDG(3),

  /// Global configuration file is the user-specific configuration;
  /// typically `~/.gitconfig`.
  GIT_CONFIG_LEVEL_GLOBAL(4),

  /// Local configuration, the repository-specific configuration file;
  /// typically `$GIT_DIR/config`.
  GIT_CONFIG_LEVEL_LOCAL(5),

  /// Worktree-specific configuration; typically
  /// `$GIT_DIR/config.worktree`.
  GIT_CONFIG_LEVEL_WORKTREE(6),

  /// Application-specific configuration file. Callers into libgit2
  /// can add their own configuration beginning at this level.
  GIT_CONFIG_LEVEL_APP(7),

  /// Not a configuration level; callers can use this value when
  /// querying configuration levels to specify that they want to
  /// have data from the highest-level currently configuration.
  /// This can be used to indicate that callers want the most
  /// specific config file available that actually is loaded.
  GIT_CONFIG_HIGHEST_LEVEL(-1);

  final int value;
  const git_config_level_t(this.value);

  static git_config_level_t fromValue(int value) => switch (value) {
        1 => GIT_CONFIG_LEVEL_PROGRAMDATA,
        2 => GIT_CONFIG_LEVEL_SYSTEM,
        3 => GIT_CONFIG_LEVEL_XDG,
        4 => GIT_CONFIG_LEVEL_GLOBAL,
        5 => GIT_CONFIG_LEVEL_LOCAL,
        6 => GIT_CONFIG_LEVEL_WORKTREE,
        7 => GIT_CONFIG_LEVEL_APP,
        -1 => GIT_CONFIG_HIGHEST_LEVEL,
        _ =>
          throw ArgumentError('Unknown value for git_config_level_t: $value'),
      };
}

/// An entry in a configuration file
final class git_config_entry extends ffi.Struct {
  /// Name of the configuration entry (normalized).
  external ffi.Pointer<ffi.Char> name;

  /// Literal (string) value of the entry.
  external ffi.Pointer<ffi.Char> value;

  /// The type of backend that this entry exists in (eg, "file").
  external ffi.Pointer<ffi.Char> backend_type;

  /// The path to the origin of this entry. For config files, this is
  /// the path to the file.
  external ffi.Pointer<ffi.Char> origin_path;

  /// Depth of includes where this variable was found.
  @ffi.UnsignedInt()
  external int include_depth;

  /// Configuration level for the file this was found in.
  @ffi.Int()
  external int levelAsInt;

  git_config_level_t get level => git_config_level_t.fromValue(levelAsInt);
}

/// An entry in a configuration backend. This is provided so that
/// backend implementors can have a mechanism to free their data.
final class git_config_backend_entry extends ffi.Struct {
  /// The base configuration entry
  external git_config_entry entry;

  /// Free function for this entry; for internal purposes. Callers
  /// should call `git_config_entry_free` to free data.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_config_backend_entry> entry)>> free;
}

/// Every iterator must have this struct as its first element, so the
/// API can talk to it. You'd define your iterator as
///
/// struct my_iterator {
/// git_config_iterator parent;
/// ...
/// }
///
/// and assign `iter->parent.backend` to your `git_config_backend`.
final class git_config_iterator extends ffi.Struct {
  external ffi.Pointer<git_config_backend> backend;

  @ffi.UnsignedInt()
  external int flags;

  /// Return the current entry and advance the iterator. The
  /// memory belongs to the library.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config_backend_entry>> entry,
              ffi.Pointer<git_config_iterator> iter)>> next;

  /// Free the iterator
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_config_iterator> iter)>> free;
}

/// Generic backend that implements the interface to
/// access a configuration file
final class git_config_backend extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// True if this backend is for a snapshot
  @ffi.Int()
  external int readonly;

  external ffi.Pointer<git_config> cfg;

  /// Open means open the file/database and parse if necessary
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config_backend>, ffi.Int,
              ffi.Pointer<git_repository>)>> open;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config_backend>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<git_config_backend_entry>>)>> get$;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config_backend>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>> set$;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config_backend> cfg,
              ffi.Pointer<ffi.Char> name,
              ffi.Pointer<ffi.Char> regexp,
              ffi.Pointer<ffi.Char> value)>> set_multivar;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config_backend>, ffi.Pointer<ffi.Char>)>> del;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config_backend>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>> del_multivar;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config_backend>)>> iterator;

  /// Produce a read-only version of this backend
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_backend>>,
              ffi.Pointer<git_config_backend>)>> snapshot;

  /// Lock this backend.
  ///
  /// Prevent any writes to the data store backing this
  /// backend. Any updates must not be visible to any other
  /// readers.
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_config_backend>)>>
      lock;

  /// Unlock the data store backing this backend. If success is
  /// true, the changes should be committed, otherwise rolled
  /// back.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config_backend>, ffi.Int)>> unlock;

  external ffi.Pointer<
      ffi
      .NativeFunction<ffi.Void Function(ffi.Pointer<git_config_backend>)>> free;
}

final class git_reflog_entry extends ffi.Opaque {}

final class git_note extends ffi.Opaque {}

final class git_packbuilder extends ffi.Opaque {}

final class git_transaction extends ffi.Opaque {}

final class git_annotated_commit extends ffi.Opaque {}

final class git_status_list extends ffi.Opaque {}

final class git_rebase extends ffi.Opaque {}

/// Basic type of any Git reference.
enum git_reference_t {
  /// < Invalid reference
  GIT_REFERENCE_INVALID(0),

  /// < A reference that points at an object id
  GIT_REFERENCE_DIRECT(1),

  /// < A reference that points at another reference
  GIT_REFERENCE_SYMBOLIC(2),
  GIT_REFERENCE_ALL(3);

  final int value;
  const git_reference_t(this.value);

  static git_reference_t fromValue(int value) => switch (value) {
        0 => GIT_REFERENCE_INVALID,
        1 => GIT_REFERENCE_DIRECT,
        2 => GIT_REFERENCE_SYMBOLIC,
        3 => GIT_REFERENCE_ALL,
        _ => throw ArgumentError('Unknown value for git_reference_t: $value'),
      };
}

/// Basic type of any Git branch.
enum git_branch_t {
  GIT_BRANCH_LOCAL(1),
  GIT_BRANCH_REMOTE(2),
  GIT_BRANCH_ALL(3);

  final int value;
  const git_branch_t(this.value);

  static git_branch_t fromValue(int value) => switch (value) {
        1 => GIT_BRANCH_LOCAL,
        2 => GIT_BRANCH_REMOTE,
        3 => GIT_BRANCH_ALL,
        _ => throw ArgumentError('Unknown value for git_branch_t: $value'),
      };
}

/// Valid modes for index and tree entries.
enum git_filemode_t {
  GIT_FILEMODE_UNREADABLE(0),
  GIT_FILEMODE_TREE(16384),
  GIT_FILEMODE_BLOB(33188),
  GIT_FILEMODE_BLOB_EXECUTABLE(33261),
  GIT_FILEMODE_LINK(40960),
  GIT_FILEMODE_COMMIT(57344);

  final int value;
  const git_filemode_t(this.value);

  static git_filemode_t fromValue(int value) => switch (value) {
        0 => GIT_FILEMODE_UNREADABLE,
        16384 => GIT_FILEMODE_TREE,
        33188 => GIT_FILEMODE_BLOB,
        33261 => GIT_FILEMODE_BLOB_EXECUTABLE,
        40960 => GIT_FILEMODE_LINK,
        57344 => GIT_FILEMODE_COMMIT,
        _ => throw ArgumentError('Unknown value for git_filemode_t: $value'),
      };
}

final class git_refspec extends ffi.Opaque {}

final class git_remote extends ffi.Opaque {}

typedef git_transport_message_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Char> str, ffi.Int len, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_transport_message_cbFunction = int Function(
    ffi.Pointer<ffi.Char> str, int len, ffi.Pointer<ffi.Void> payload);

/// Callback for messages received by the transport.
///
/// Return a negative value to cancel the network operation.
///
/// @param str The message from the transport
/// @param len The length of the message
/// @param payload Payload provided by the caller
/// @return 0 on success or an error code
typedef git_transport_message_cb
    = ffi.Pointer<ffi.NativeFunction<git_transport_message_cbFunction>>;

/// Argument to the completion callback which tells it which operation
/// finished.
enum git_remote_completion_t {
  GIT_REMOTE_COMPLETION_DOWNLOAD(0),
  GIT_REMOTE_COMPLETION_INDEXING(1),
  GIT_REMOTE_COMPLETION_ERROR(2);

  final int value;
  const git_remote_completion_t(this.value);

  static git_remote_completion_t fromValue(int value) => switch (value) {
        0 => GIT_REMOTE_COMPLETION_DOWNLOAD,
        1 => GIT_REMOTE_COMPLETION_INDEXING,
        2 => GIT_REMOTE_COMPLETION_ERROR,
        _ => throw ArgumentError(
            'Unknown value for git_remote_completion_t: $value'),
      };
}

/// Supported credential types
///
/// This represents the various types of authentication methods supported by
/// the library.
enum git_credential_t {
  /// A vanilla user/password request
  /// @see git_credential_userpass_plaintext_new
  GIT_CREDENTIAL_USERPASS_PLAINTEXT(1),

  /// An SSH key-based authentication request
  /// @see git_credential_ssh_key_new
  GIT_CREDENTIAL_SSH_KEY(2),

  /// An SSH key-based authentication request, with a custom signature
  /// @see git_credential_ssh_custom_new
  GIT_CREDENTIAL_SSH_CUSTOM(4),

  /// An NTLM/Negotiate-based authentication request.
  /// @see git_credential_default
  GIT_CREDENTIAL_DEFAULT(8),

  /// An SSH interactive authentication request
  /// @see git_credential_ssh_interactive_new
  GIT_CREDENTIAL_SSH_INTERACTIVE(16),

  /// Username-only authentication request
  ///
  /// Used as a pre-authentication step if the underlying transport
  /// (eg. SSH, with no username in its URL) does not know which username
  /// to use.
  ///
  /// @see git_credential_username_new
  GIT_CREDENTIAL_USERNAME(32),

  /// An SSH key-based authentication request
  ///
  /// Allows credentials to be read from memory instead of files.
  /// Note that because of differences in crypto backend support, it might
  /// not be functional.
  ///
  /// @see git_credential_ssh_key_memory_new
  GIT_CREDENTIAL_SSH_MEMORY(64);

  final int value;
  const git_credential_t(this.value);

  static git_credential_t fromValue(int value) => switch (value) {
        1 => GIT_CREDENTIAL_USERPASS_PLAINTEXT,
        2 => GIT_CREDENTIAL_SSH_KEY,
        4 => GIT_CREDENTIAL_SSH_CUSTOM,
        8 => GIT_CREDENTIAL_DEFAULT,
        16 => GIT_CREDENTIAL_SSH_INTERACTIVE,
        32 => GIT_CREDENTIAL_USERNAME,
        64 => GIT_CREDENTIAL_SSH_MEMORY,
        _ => throw ArgumentError('Unknown value for git_credential_t: $value'),
      };
}

/// The base structure for all credential types
final class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.UnsignedInt()
  external int credtypeAsInt;

  git_credential_t get credtype => git_credential_t.fromValue(credtypeAsInt);

  /// The deallocator for this type of credentials
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<git_credential> cred)>>
      free;
}

typedef git_credential_acquire_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> username_from_url,
    ffi.UnsignedInt allowed_types,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_credential_acquire_cbFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> username_from_url,
    int allowed_types,
    ffi.Pointer<ffi.Void> payload);

/// Credential acquisition callback.
///
/// This callback is usually involved any time another system might need
/// authentication. As such, you are expected to provide a valid
/// git_credential object back, depending on allowed_types (a
/// git_credential_t bitmask).
///
/// Note that most authentication details are your responsibility - this
/// callback will be called until the authentication succeeds, or you report
/// an error. As such, it's easy to get in a loop if you fail to stop providing
/// the same incorrect credentials.
///
/// @param[out] out The newly created credential object.
/// @param url The resource for which we are demanding a credential.
/// @param username_from_url The username that was embedded in a "user\@host"
/// remote url, or NULL if not included.
/// @param allowed_types A bitmask stating which credential types are OK to return.
/// @param payload The payload provided when specifying this callback.
/// @return 0 for success, < 0 to indicate an error, > 0 to indicate
/// no credential was acquired
typedef git_credential_acquire_cb
    = ffi.Pointer<ffi.NativeFunction<git_credential_acquire_cbFunction>>;

/// Type of host certificate structure that is passed to the check callback
enum git_cert_t {
  /// No information about the certificate is available. This may
  /// happen when using curl.
  GIT_CERT_NONE(0),

  /// The `data` argument to the callback will be a pointer to
  /// the DER-encoded data.
  GIT_CERT_X509(1),

  /// The `data` argument to the callback will be a pointer to a
  /// `git_cert_hostkey` structure.
  GIT_CERT_HOSTKEY_LIBSSH2(2),

  /// The `data` argument to the callback will be a pointer to a
  /// `git_strarray` with `name:content` strings containing
  /// information about the certificate. This is used when using
  /// curl.
  GIT_CERT_STRARRAY(3);

  final int value;
  const git_cert_t(this.value);

  static git_cert_t fromValue(int value) => switch (value) {
        0 => GIT_CERT_NONE,
        1 => GIT_CERT_X509,
        2 => GIT_CERT_HOSTKEY_LIBSSH2,
        3 => GIT_CERT_STRARRAY,
        _ => throw ArgumentError('Unknown value for git_cert_t: $value'),
      };
}

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
final class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.UnsignedInt()
  external int cert_typeAsInt;

  git_cert_t get cert_type => git_cert_t.fromValue(cert_typeAsInt);
}

typedef git_transport_certificate_check_cbFunction = ffi.Int Function(
    ffi.Pointer<git_cert> cert,
    ffi.Int valid,
    ffi.Pointer<ffi.Char> host,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_transport_certificate_check_cbFunction = int Function(
    ffi.Pointer<git_cert> cert,
    int valid,
    ffi.Pointer<ffi.Char> host,
    ffi.Pointer<ffi.Void> payload);

/// Callback for the user's custom certificate checks.
///
/// @param cert The host certificate
/// @param valid Whether the libgit2 checks (OpenSSL or WinHTTP) think
/// this certificate is valid
/// @param host Hostname of the host libgit2 connected to
/// @param payload Payload provided by the caller
/// @return 0 to proceed with the connection, < 0 to fail the connection
/// or > 0 to indicate that the callback refused to act and that
/// the existing validity determination should be honored
typedef git_transport_certificate_check_cb = ffi
    .Pointer<ffi.NativeFunction<git_transport_certificate_check_cbFunction>>;
typedef git_packbuilder_progressFunction = ffi.Int Function(ffi.Int stage,
    ffi.Uint32 current, ffi.Uint32 total, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_packbuilder_progressFunction = int Function(
    int stage, int current, int total, ffi.Pointer<ffi.Void> payload);

/// Packbuilder progress notification function.
///
/// @param stage the stage of the packbuilder
/// @param current the current object
/// @param total the total number of objects
/// @param payload the callback payload
/// @return 0 on success or an error code
typedef git_packbuilder_progress
    = ffi.Pointer<ffi.NativeFunction<git_packbuilder_progressFunction>>;
typedef git_push_transfer_progress_cbFunction = ffi.Int Function(
    ffi.UnsignedInt current,
    ffi.UnsignedInt total,
    ffi.Size bytes,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_push_transfer_progress_cbFunction = int Function(
    int current, int total, int bytes, ffi.Pointer<ffi.Void> payload);

/// Push network progress notification callback.
///
/// @param current The number of objects pushed so far
/// @param total The total number of objects to push
/// @param bytes The number of bytes pushed
/// @param payload The user-specified payload callback
/// @return 0 or an error code to stop the transfer
typedef git_push_transfer_progress_cb
    = ffi.Pointer<ffi.NativeFunction<git_push_transfer_progress_cbFunction>>;
typedef git_push_update_reference_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<ffi.Char> status,
    ffi.Pointer<ffi.Void> data);
typedef Dartgit_push_update_reference_cbFunction = int Function(
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<ffi.Char> status,
    ffi.Pointer<ffi.Void> data);

/// Callback used to inform of the update status from the remote.
///
/// Called for each updated reference on push. If `status` is
/// not `NULL`, the update was rejected by the remote server
/// and `status` contains the reason given.
///
/// @param refname refname specifying to the remote ref
/// @param status status message sent from the remote
/// @param data data provided by the caller
/// @return 0 on success, otherwise an error
typedef git_push_update_reference_cb
    = ffi.Pointer<ffi.NativeFunction<git_push_update_reference_cbFunction>>;

/// Represents an update which will be performed on the remote during push
final class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Char> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Char> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

typedef git_push_negotiationFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_push_update>> updates,
    ffi.Size len,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_push_negotiationFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_push_update>> updates,
    int len,
    ffi.Pointer<ffi.Void> payload);

/// Callback used to inform of upcoming updates.
///
/// @param updates an array containing the updates which will be sent
/// as commands to the destination.
/// @param len number of elements in `updates`
/// @param payload Payload provided by the caller
/// @return 0 or an error code to stop the push
typedef git_push_negotiation
    = ffi.Pointer<ffi.NativeFunction<git_push_negotiationFunction>>;
typedef git_transport_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_transport>> out,
    ffi.Pointer<git_remote> owner,
    ffi.Pointer<ffi.Void> param);
typedef Dartgit_transport_cbFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_transport>> out,
    ffi.Pointer<git_remote> owner,
    ffi.Pointer<ffi.Void> param);

/// Signature of a function which creates a transport.
///
/// @param out the transport generate
/// @param owner the owner for the transport
/// @param param the param to the transport creation
/// @return 0 on success or an error code
typedef git_transport_cb
    = ffi.Pointer<ffi.NativeFunction<git_transport_cbFunction>>;
typedef git_remote_ready_cbFunction = ffi.Int Function(
    ffi.Pointer<git_remote> remote,
    ffi.Int direction,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_remote_ready_cbFunction = int Function(
    ffi.Pointer<git_remote> remote,
    int direction,
    ffi.Pointer<ffi.Void> payload);

/// Callback invoked immediately before we attempt to connect to the
/// given url.  Callers may change the URL before the connection by
/// calling `git_remote_set_instance_url` in the callback.
///
/// @param remote The remote to be connected
/// @param direction GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
/// @param payload Payload provided by the caller
/// @return 0 on success, or an error
typedef git_remote_ready_cb
    = ffi.Pointer<ffi.NativeFunction<git_remote_ready_cbFunction>>;
typedef git_url_resolve_cbFunction = ffi.Int Function(
    ffi.Pointer<git_buf> url_resolved,
    ffi.Pointer<ffi.Char> url,
    ffi.Int direction,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_url_resolve_cbFunction = int Function(
    ffi.Pointer<git_buf> url_resolved,
    ffi.Pointer<ffi.Char> url,
    int direction,
    ffi.Pointer<ffi.Void> payload);

/// Callback to resolve URLs before connecting to remote
///
/// If you return GIT_PASSTHROUGH, you don't need to write anything to
/// url_resolved.
///
/// @param url_resolved The buffer to write the resolved URL to
/// @param url The URL to resolve
/// @param direction GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
/// @param payload Payload provided by the caller
/// @return 0 on success, GIT_PASSTHROUGH or an error
/// @deprecated Use `git_remote_set_instance_url`
typedef git_url_resolve_cb
    = ffi.Pointer<ffi.NativeFunction<git_url_resolve_cbFunction>>;

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
final class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external git_transport_message_cb sideband_progress;

  /// Completion is called when different parts of the download
  /// process are done (currently unused).
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt type, ffi.Pointer<ffi.Void> data)>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external git_credential_acquire_cb credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external git_transport_certificate_check_cb certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external git_indexer_progress_cb transfer_progress;

  /// Deprecated callback for reference updates, callers should
  /// set `update_refs` instead. This is retained for backward
  /// compatibility; if you specify both `update_refs` and
  /// `update_tips`, then only the `update_refs` function will
  /// be called.
  ///
  /// @deprecated the `update_refs` callback in this structure
  /// should be preferred
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char> refname,
              ffi.Pointer<git_oid> a,
              ffi.Pointer<git_oid> b,
              ffi.Pointer<ffi.Void> data)>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external git_packbuilder_progress pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external git_push_transfer_progress_cb push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external git_push_update_reference_cb push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external git_push_negotiation push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external git_transport_cb transport;

  /// Callback when the remote is ready to connect.
  external git_remote_ready_cb remote_ready;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  ///
  /// This callback is deprecated; users should use
  /// git_remote_ready_cb and configure the instance URL instead.
  external git_url_resolve_cb resolve_url;

  /// Each time a reference is updated locally, this function
  /// will be called with information about it. This should be
  /// preferred over the `update_tips` callback in this
  /// structure.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char> refname,
              ffi.Pointer<git_oid> a,
              ffi.Pointer<git_oid> b,
              ffi.Pointer<git_refspec> spec,
              ffi.Pointer<ffi.Void> data)>> update_refs;
}

/// The type of proxy to use.
enum git_proxy_t {
  /// Do not attempt to connect through a proxy
  ///
  /// If built against libcurl, it itself may attempt to connect
  /// to a proxy if the environment variables specify it.
  GIT_PROXY_NONE(0),

  /// Try to auto-detect the proxy from the git configuration.
  GIT_PROXY_AUTO(1),

  /// Connect via the URL given in the options
  GIT_PROXY_SPECIFIED(2);

  final int value;
  const git_proxy_t(this.value);

  static git_proxy_t fromValue(int value) => switch (value) {
        0 => GIT_PROXY_NONE,
        1 => GIT_PROXY_AUTO,
        2 => GIT_PROXY_SPECIFIED,
        _ => throw ArgumentError('Unknown value for git_proxy_t: $value'),
      };
}

/// Options for connecting through a proxy
///
/// Note that not all types may be supported, depending on the platform
/// and compilation options.
final class git_proxy_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The type of proxy to use, by URL, auto-detect.
  @ffi.UnsignedInt()
  external int typeAsInt;

  git_proxy_t get type => git_proxy_t.fromValue(typeAsInt);

  /// The URL of the proxy.
  external ffi.Pointer<ffi.Char> url;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external git_credential_acquire_cb credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external git_transport_certificate_check_cb certificate_check;

  /// Payload to be provided to the credentials and certificate
  /// check callbacks.
  external ffi.Pointer<ffi.Void> payload;
}

/// Remote redirection settings; whether redirects to another host
/// are permitted.  By default, git will follow a redirect on the
/// initial request (`/info/refs`), but not subsequent requests.
enum git_remote_redirect_t {
  /// Do not follow any off-site redirects at any stage of
  /// the fetch or push.
  GIT_REMOTE_REDIRECT_NONE(1),

  /// Allow off-site redirects only upon the initial request.
  /// This is the default.
  GIT_REMOTE_REDIRECT_INITIAL(2),

  /// Allow redirects at any stage in the fetch or push.
  GIT_REMOTE_REDIRECT_ALL(4);

  final int value;
  const git_remote_redirect_t(this.value);

  static git_remote_redirect_t fromValue(int value) => switch (value) {
        1 => GIT_REMOTE_REDIRECT_NONE,
        2 => GIT_REMOTE_REDIRECT_INITIAL,
        4 => GIT_REMOTE_REDIRECT_ALL,
        _ => throw ArgumentError(
            'Unknown value for git_remote_redirect_t: $value'),
      };
}

/// Array of strings
final class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Char>> strings;

  @ffi.Size()
  external int count;
}

/// Remote creation options structure
///
/// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_remote_create_options_init`.
final class git_remote_connect_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Callbacks to use for this connection
  external git_remote_callbacks callbacks;

  /// HTTP Proxy settings
  external git_proxy_options proxy_opts;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.UnsignedInt()
  external int follow_redirectsAsInt;

  git_remote_redirect_t get follow_redirects =>
      git_remote_redirect_t.fromValue(follow_redirectsAsInt);

  /// Extra HTTP headers to use in this connection
  external git_strarray custom_headers;
}

/// Description of a reference advertised by a remote server, given out
/// on `ls` calls.
final class git_remote_head extends ffi.Struct {
  /// available locally
  @ffi.Int()
  external int local;

  external git_oid oid;

  external git_oid loid;

  external ffi.Pointer<ffi.Char> name;

  /// If the server send a symref mapping for this ref, this will
  /// point to the target.
  external ffi.Pointer<ffi.Char> symref_target;
}

final class git_push extends ffi.Opaque {}

/// The negotiation state during a fetch smart transport negotiation.
final class git_fetch_negotiation extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<git_remote_head>> refs;

  @ffi.Size()
  external int refs_len;

  external ffi.Pointer<git_oid> shallow_roots;

  @ffi.Size()
  external int shallow_roots_len;

  @ffi.Int()
  external int depth;
}

/// Array of object ids
final class git_oidarray extends ffi.Struct {
  external ffi.Pointer<git_oid> ids;

  @ffi.Size()
  external int count;
}

final class git_transport extends ffi.Struct {
  /// < The struct version
  @ffi.UnsignedInt()
  external int version;

  /// Connect the transport to the remote repository, using the given
  /// direction.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transport> transport,
              ffi.Pointer<ffi.Char> url,
              ffi.Int direction,
              ffi.Pointer<git_remote_connect_options> connect_opts)>> connect;

  /// Resets the connect options for the given transport.  This
  /// is useful for updating settings or callbacks for an already
  /// connected transport.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_transport> transport,
                  ffi.Pointer<git_remote_connect_options> connect_opts)>>
      set_connect_opts;

  /// Gets the capabilities for this remote repository.
  ///
  /// This function may be called after a successful call to
  /// `connect()`.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedInt> capabilities,
              ffi.Pointer<git_transport> transport)>> capabilities;

  /// Gets the object type for the remote repository.
  ///
  /// This function may be called after a successful call to
  /// `connect()`.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedInt> object_type,
              ffi.Pointer<git_transport> transport)>> oid_type;

  /// Get the list of available references in the remote repository.
  ///
  /// This function may be called after a successful call to
  /// `connect()`. The array returned is owned by the transport and
  /// must be kept valid until the next call to one of its functions.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> out,
              ffi.Pointer<ffi.Size> size,
              ffi.Pointer<git_transport> transport)>> ls;

  /// Executes the push whose context is in the git_push object.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transport> transport,
              ffi.Pointer<git_push> push)>> push;

  /// Negotiate a fetch with the remote repository.
  ///
  /// This function may be called after a successful call to `connect()`,
  /// when the direction is GIT_DIRECTION_FETCH. The function performs a
  /// negotiation to calculate the `wants` list for the fetch.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transport> transport,
              ffi.Pointer<git_repository> repo,
              ffi.Pointer<git_fetch_negotiation> fetch_data)>> negotiate_fetch;

  /// Return the shallow roots of the remote.
  ///
  /// This function may be called after a successful call to
  /// `negotiate_fetch`.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oidarray> out,
              ffi.Pointer<git_transport> transport)>> shallow_roots;

  /// Start downloading the packfile from the remote repository.
  ///
  /// This function may be called after a successful call to
  /// negotiate_fetch(), when the direction is GIT_DIRECTION_FETCH.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transport> transport,
              ffi.Pointer<git_repository> repo,
              ffi.Pointer<git_indexer_progress> stats)>> download_pack;

  /// Checks to see if the transport is connected
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transport> transport)>> is_connected;

  /// Cancels any outstanding transport operation
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_transport> transport)>> cancel;

  /// Close the connection to the remote repository.
  ///
  /// This function is the reverse of connect() -- it terminates the
  /// connection to the remote end.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transport> transport)>> close;

  /// Frees/destructs the git_transport object.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_transport> transport)>> free;
}

final class git_submodule extends ffi.Opaque {}

/// Submodule update values
///
/// These values represent settings for the `submodule.$name.update`
/// configuration value which says how to handle `git submodule update` for
/// this submodule.  The value is usually set in the ".gitmodules" file and
/// copied to ".git/config" when the submodule is initialized.
///
/// You can override this setting on a per-submodule basis with
/// `git_submodule_set_update()` and write the changed value to disk using
/// `git_submodule_save()`.  If you have overwritten the value, you can
/// revert it by passing `GIT_SUBMODULE_UPDATE_RESET` to the set function.
///
/// The values are:
///
/// - GIT_SUBMODULE_UPDATE_CHECKOUT: the default; when a submodule is
/// updated, checkout the new detached HEAD to the submodule directory.
/// - GIT_SUBMODULE_UPDATE_REBASE: update by rebasing the current checked
/// out branch onto the commit from the superproject.
/// - GIT_SUBMODULE_UPDATE_MERGE: update by merging the commit in the
/// superproject into the current checkout out branch of the submodule.
/// - GIT_SUBMODULE_UPDATE_NONE: do not update this submodule even when
/// the commit in the superproject is updated.
/// - GIT_SUBMODULE_UPDATE_DEFAULT: not used except as static initializer
/// when we don't want any particular update rule to be specified.
enum git_submodule_update_t {
  GIT_SUBMODULE_UPDATE_CHECKOUT(1),
  GIT_SUBMODULE_UPDATE_REBASE(2),
  GIT_SUBMODULE_UPDATE_MERGE(3),
  GIT_SUBMODULE_UPDATE_NONE(4),
  GIT_SUBMODULE_UPDATE_DEFAULT(0);

  final int value;
  const git_submodule_update_t(this.value);

  static git_submodule_update_t fromValue(int value) => switch (value) {
        1 => GIT_SUBMODULE_UPDATE_CHECKOUT,
        2 => GIT_SUBMODULE_UPDATE_REBASE,
        3 => GIT_SUBMODULE_UPDATE_MERGE,
        4 => GIT_SUBMODULE_UPDATE_NONE,
        0 => GIT_SUBMODULE_UPDATE_DEFAULT,
        _ => throw ArgumentError(
            'Unknown value for git_submodule_update_t: $value'),
      };
}

/// Submodule ignore values
///
/// These values represent settings for the `submodule.$name.ignore`
/// configuration value which says how deeply to look at the working
/// directory when getting submodule status.
///
/// You can override this value in memory on a per-submodule basis with
/// `git_submodule_set_ignore()` and can write the changed value to disk
/// with `git_submodule_save()`.  If you have overwritten the value, you
/// can revert to the on disk value by using `GIT_SUBMODULE_IGNORE_RESET`.
///
/// The values are:
///
/// - GIT_SUBMODULE_IGNORE_UNSPECIFIED: use the submodule's configuration
/// - GIT_SUBMODULE_IGNORE_NONE: don't ignore any change - i.e. even an
/// untracked file, will mark the submodule as dirty.  Ignored files are
/// still ignored, of course.
/// - GIT_SUBMODULE_IGNORE_UNTRACKED: ignore untracked files; only changes
/// to tracked files, or the index or the HEAD commit will matter.
/// - GIT_SUBMODULE_IGNORE_DIRTY: ignore changes in the working directory,
/// only considering changes if the HEAD of submodule has moved from the
/// value in the superproject.
/// - GIT_SUBMODULE_IGNORE_ALL: never check if the submodule is dirty
/// - GIT_SUBMODULE_IGNORE_DEFAULT: not used except as static initializer
/// when we don't want any particular ignore rule to be specified.
enum git_submodule_ignore_t {
  /// < use the submodule's configuration
  GIT_SUBMODULE_IGNORE_UNSPECIFIED(-1),

  /// < any change or untracked == dirty
  GIT_SUBMODULE_IGNORE_NONE(1),

  /// < dirty if tracked files change
  GIT_SUBMODULE_IGNORE_UNTRACKED(2),

  /// < only dirty if HEAD moved
  GIT_SUBMODULE_IGNORE_DIRTY(3),

  /// < never dirty
  GIT_SUBMODULE_IGNORE_ALL(4);

  final int value;
  const git_submodule_ignore_t(this.value);

  static git_submodule_ignore_t fromValue(int value) => switch (value) {
        -1 => GIT_SUBMODULE_IGNORE_UNSPECIFIED,
        1 => GIT_SUBMODULE_IGNORE_NONE,
        2 => GIT_SUBMODULE_IGNORE_UNTRACKED,
        3 => GIT_SUBMODULE_IGNORE_DIRTY,
        4 => GIT_SUBMODULE_IGNORE_ALL,
        _ => throw ArgumentError(
            'Unknown value for git_submodule_ignore_t: $value'),
      };
}

/// Options for submodule recurse.
///
/// Represent the value of `submodule.$name.fetchRecurseSubmodules`
///
/// * GIT_SUBMODULE_RECURSE_NO    - do no recurse into submodules
/// * GIT_SUBMODULE_RECURSE_YES   - recurse into submodules
/// * GIT_SUBMODULE_RECURSE_ONDEMAND - recurse into submodules only when
/// commit not already in local clone
enum git_submodule_recurse_t {
  GIT_SUBMODULE_RECURSE_NO(0),
  GIT_SUBMODULE_RECURSE_YES(1),
  GIT_SUBMODULE_RECURSE_ONDEMAND(2);

  final int value;
  const git_submodule_recurse_t(this.value);

  static git_submodule_recurse_t fromValue(int value) => switch (value) {
        0 => GIT_SUBMODULE_RECURSE_NO,
        1 => GIT_SUBMODULE_RECURSE_YES,
        2 => GIT_SUBMODULE_RECURSE_ONDEMAND,
        _ => throw ArgumentError(
            'Unknown value for git_submodule_recurse_t: $value'),
      };
}

/// A type to write in a streaming fashion, for example, for filters.
final class git_writestream extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_writestream> stream,
              ffi.Pointer<ffi.Char> buffer, ffi.Size len)>> write;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_writestream> stream)>> close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<git_writestream> stream)>> free;
}

final class git_mailmap extends ffi.Opaque {}

final class git_indexer extends ffi.Opaque {}

/// Options for indexer configuration
final class git_indexer_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// permissions to use creating packfile or 0 for defaults
  @ffi.UnsignedInt()
  external int mode;

  /// the type of object ids in the packfile or 0 for SHA1
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

  /// object database from which to read base objects when
  /// fixing thin packs. This can be NULL if there are no thin
  /// packs; if a thin pack is encountered, an error will be
  /// returned if there are bases missing.
  external ffi.Pointer<git_odb> odb;

  /// progress_cb function to call with progress information
  external git_indexer_progress_cb progress_cb;

  /// progress_cb_payload payload for the progress callback
  external ffi.Pointer<ffi.Void> progress_cb_payload;

  /// Do connectivity checks for the received pack
  @ffi.UnsignedChar()
  external int verify;
}

/// Flags controlling the behavior of ODB lookup operations
enum git_odb_lookup_flags_t {
  /// Don't call `git_odb_refresh` if the lookup fails. Useful when doing
  /// a batch of lookup operations for objects that may legitimately not
  /// exist. When using this flag, you may wish to manually call
  /// `git_odb_refresh` before processing a batch of objects.
  GIT_ODB_LOOKUP_NO_REFRESH(1);

  final int value;
  const git_odb_lookup_flags_t(this.value);

  static git_odb_lookup_flags_t fromValue(int value) => switch (value) {
        1 => GIT_ODB_LOOKUP_NO_REFRESH,
        _ => throw ArgumentError(
            'Unknown value for git_odb_lookup_flags_t: $value'),
      };
}

/// Options for configuring a loose object backend.
final class git_odb_options extends ffi.Struct {
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// Type of object IDs to use for this object database, or
  /// 0 for default (currently SHA1).
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

/// The information about object IDs to query in `git_odb_expand_ids`,
/// which will be populated upon return.
final class git_odb_expand_id extends ffi.Struct {
  /// The object ID to expand
  external git_oid id;

  /// The length of the object ID (in nibbles, or packets of 4 bits; the
  /// number of hex characters)
  @ffi.UnsignedShort()
  external int length;

  /// The (optional) type of the object to search for; leave as `0` or set
  /// to `GIT_OBJECT_ANY` to query for any object matching the ID.
  @ffi.Int()
  external int typeAsInt;

  git_object_t get type => git_object_t.fromValue(typeAsInt);
}

final class git_commit_create_options extends ffi.Opaque {}

typedef git_commit_create_cbFunction = ffi.Int Function(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    ffi.Size parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_commit_create_cbFunction = int Function(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
    ffi.Pointer<ffi.Void> payload);

/// Commit creation callback: used when a function is going to create
/// commits (for example, in `git_rebase_commit`) to allow callers to
/// override the commit creation behavior.  For example, users may
/// wish to sign commits by providing this information to
/// `git_commit_create_buffer`, signing that buffer, then calling
/// `git_commit_create_with_signature`.  The resultant commit id
/// should be set in the `out` object id parameter.
///
/// @param out pointer that this callback will populate with the object
/// id of the commit that is created
/// @param author the author name and time of the commit
/// @param committer the committer name and time of the commit
/// @param message_encoding the encoding of the given message, or NULL
/// to assume UTF8
/// @param message the commit message
/// @param tree the tree to be committed
/// @param parent_count the number of parents for this commit
/// @param parents the commit parents
/// @param payload the payload pointer in the rebase options
/// @return 0 if this callback has created the commit and populated the out
/// parameter, GIT_PASSTHROUGH if the callback has not created a
/// commit and wants the calling function to create the commit as
/// if no callback had been specified, any other value to stop
/// and return a failure
typedef git_commit_create_cb
    = ffi.Pointer<ffi.NativeFunction<git_commit_create_cbFunction>>;

/// An array of commits returned from the library
final class git_commitarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<git_commit>> commits;

  @ffi.Size()
  external int count;
}

/// Option flags for `git_repository_open_ext`.
enum git_repository_open_flag_t {
  /// Only open the repository if it can be immediately found in the
  /// start_path. Do not walk up from the start_path looking at parent
  /// directories.
  GIT_REPOSITORY_OPEN_NO_SEARCH(1),

  /// Unless this flag is set, open will not continue searching across
  /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
  /// system call).  For example, searching in a user's home directory at
  /// "/home/user/source/" will not return "/.git/" as the found repo if
  /// "/" is a different filesystem than "/home".
  GIT_REPOSITORY_OPEN_CROSS_FS(2),

  /// Open repository as a bare repo regardless of core.bare config, and
  /// defer loading config file for faster setup.
  /// Unlike `git_repository_open_bare`, this can follow gitlinks.
  GIT_REPOSITORY_OPEN_BARE(4),

  /// Do not check for a repository by appending /.git to the start_path;
  /// only open the repository if start_path itself points to the git
  /// directory.
  GIT_REPOSITORY_OPEN_NO_DOTGIT(8),

  /// Find and open a git repository, respecting the environment variables
  /// used by the git command-line tools.
  /// If set, `git_repository_open_ext` will ignore the other flags and
  /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
  /// `GIT_DIR` or search from the current directory.
  /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
  /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
  /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
  /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
  /// In the future, this flag will also cause `git_repository_open_ext`
  /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
  /// `git_repository_open_ext` with this flag will error out if either
  /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
  GIT_REPOSITORY_OPEN_FROM_ENV(16);

  final int value;
  const git_repository_open_flag_t(this.value);

  static git_repository_open_flag_t fromValue(int value) => switch (value) {
        1 => GIT_REPOSITORY_OPEN_NO_SEARCH,
        2 => GIT_REPOSITORY_OPEN_CROSS_FS,
        4 => GIT_REPOSITORY_OPEN_BARE,
        8 => GIT_REPOSITORY_OPEN_NO_DOTGIT,
        16 => GIT_REPOSITORY_OPEN_FROM_ENV,
        _ => throw ArgumentError(
            'Unknown value for git_repository_open_flag_t: $value'),
      };
}

/// Option flags for `git_repository_init_ext`.
///
/// These flags configure extra behaviors to `git_repository_init_ext`.
/// In every case, the default behavior is the zero value (i.e. flag is
/// not set). Just OR the flag values together for the `flags` parameter
/// when initializing a new repo.
enum git_repository_init_flag_t {
  /// Create a bare repository with no working directory.
  GIT_REPOSITORY_INIT_BARE(1),

  /// Return an GIT_EEXISTS error if the repo_path appears to already be
  /// an git repository.
  GIT_REPOSITORY_INIT_NO_REINIT(2),

  /// Normally a "/.git/" will be appended to the repo path for
  /// non-bare repos (if it is not already there), but passing this flag
  /// prevents that behavior.
  GIT_REPOSITORY_INIT_NO_DOTGIT_DIR(4),

  /// Make the repo_path (and workdir_path) as needed. Init is always willing
  /// to create the ".git" directory even without this flag. This flag tells
  /// init to create the trailing component of the repo and workdir paths
  /// as needed.
  GIT_REPOSITORY_INIT_MKDIR(8),

  /// Recursively make all components of the repo and workdir paths as
  /// necessary.
  GIT_REPOSITORY_INIT_MKPATH(16),

  /// libgit2 normally uses internal templates to initialize a new repo.
  /// This flags enables external templates, looking the "template_path" from
  /// the options if set, or the `init.templatedir` global config if not,
  /// or falling back on "/usr/share/git-core/templates" if it exists.
  GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE(32),

  /// If an alternate workdir is specified, use relative paths for the gitdir
  /// and core.worktree.
  GIT_REPOSITORY_INIT_RELATIVE_GITLINK(64);

  final int value;
  const git_repository_init_flag_t(this.value);

  static git_repository_init_flag_t fromValue(int value) => switch (value) {
        1 => GIT_REPOSITORY_INIT_BARE,
        2 => GIT_REPOSITORY_INIT_NO_REINIT,
        4 => GIT_REPOSITORY_INIT_NO_DOTGIT_DIR,
        8 => GIT_REPOSITORY_INIT_MKDIR,
        16 => GIT_REPOSITORY_INIT_MKPATH,
        32 => GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE,
        64 => GIT_REPOSITORY_INIT_RELATIVE_GITLINK,
        _ => throw ArgumentError(
            'Unknown value for git_repository_init_flag_t: $value'),
      };
}

/// Mode options for `git_repository_init_ext`.
///
/// Set the mode field of the `git_repository_init_options` structure
/// either to the custom mode that you would like, or to one of the
/// defined modes.
enum git_repository_init_mode_t {
  /// Use permissions configured by umask - the default.
  GIT_REPOSITORY_INIT_SHARED_UMASK(0),

  /// Use "--shared=group" behavior, chmod'ing the new repo to be group
  /// writable and "g+sx" for sticky group assignment.
  GIT_REPOSITORY_INIT_SHARED_GROUP(1533),

  /// Use "--shared=all" behavior, adding world readability.
  GIT_REPOSITORY_INIT_SHARED_ALL(1535);

  final int value;
  const git_repository_init_mode_t(this.value);

  static git_repository_init_mode_t fromValue(int value) => switch (value) {
        0 => GIT_REPOSITORY_INIT_SHARED_UMASK,
        1533 => GIT_REPOSITORY_INIT_SHARED_GROUP,
        1535 => GIT_REPOSITORY_INIT_SHARED_ALL,
        _ => throw ArgumentError(
            'Unknown value for git_repository_init_mode_t: $value'),
      };
}

/// Extended options structure for `git_repository_init_ext`.
///
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.
final class git_repository_init_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Combination of GIT_REPOSITORY_INIT flags above.
  @ffi.Uint32()
  external int flags;

  /// Set to one of the standard GIT_REPOSITORY_INIT_SHARED_... constants
  /// above, or to a custom value that you would like.
  @ffi.Uint32()
  external int mode;

  /// The path to the working dir or NULL for default (i.e. repo_path parent
  /// on non-bare repos). IF THIS IS RELATIVE PATH, IT WILL BE EVALUATED
  /// RELATIVE TO THE REPO_PATH. If this is not the "natural" working
  /// directory, a .git gitlink file will be created here linking to the
  /// repo_path.
  external ffi.Pointer<ffi.Char> workdir_path;

  /// If set, this will be used to initialize the "description" file in the
  /// repository, instead of using the template content.
  external ffi.Pointer<ffi.Char> description;

  /// When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set, this contains
  /// the path to use for the template directory. If this is NULL, the config
  /// or default directory options will be used instead.
  external ffi.Pointer<ffi.Char> template_path;

  /// The name of the head to point HEAD at. If NULL, then this will be
  /// treated as "master" and the HEAD ref will be set to "refs/heads/master".
  /// If this begins with "refs/" it will be used verbatim;
  /// otherwise "refs/heads/" will be prefixed.
  external ffi.Pointer<ffi.Char> initial_head;

  /// If this is non-NULL, then after the rest of the repository
  /// initialization is completed, an "origin" remote will be added
  /// pointing to this URL.
  external ffi.Pointer<ffi.Char> origin_url;

  /// Type of object IDs to use for this repository, or 0 for
  /// default (currently SHA1).
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

/// List of items which belong to the git repository layout
enum git_repository_item_t {
  GIT_REPOSITORY_ITEM_GITDIR(0),
  GIT_REPOSITORY_ITEM_WORKDIR(1),
  GIT_REPOSITORY_ITEM_COMMONDIR(2),
  GIT_REPOSITORY_ITEM_INDEX(3),
  GIT_REPOSITORY_ITEM_OBJECTS(4),
  GIT_REPOSITORY_ITEM_REFS(5),
  GIT_REPOSITORY_ITEM_PACKED_REFS(6),
  GIT_REPOSITORY_ITEM_REMOTES(7),
  GIT_REPOSITORY_ITEM_CONFIG(8),
  GIT_REPOSITORY_ITEM_INFO(9),
  GIT_REPOSITORY_ITEM_HOOKS(10),
  GIT_REPOSITORY_ITEM_LOGS(11),
  GIT_REPOSITORY_ITEM_MODULES(12),
  GIT_REPOSITORY_ITEM_WORKTREES(13),
  GIT_REPOSITORY_ITEM_WORKTREE_CONFIG(14),
  GIT_REPOSITORY_ITEM__LAST(15);

  final int value;
  const git_repository_item_t(this.value);

  static git_repository_item_t fromValue(int value) => switch (value) {
        0 => GIT_REPOSITORY_ITEM_GITDIR,
        1 => GIT_REPOSITORY_ITEM_WORKDIR,
        2 => GIT_REPOSITORY_ITEM_COMMONDIR,
        3 => GIT_REPOSITORY_ITEM_INDEX,
        4 => GIT_REPOSITORY_ITEM_OBJECTS,
        5 => GIT_REPOSITORY_ITEM_REFS,
        6 => GIT_REPOSITORY_ITEM_PACKED_REFS,
        7 => GIT_REPOSITORY_ITEM_REMOTES,
        8 => GIT_REPOSITORY_ITEM_CONFIG,
        9 => GIT_REPOSITORY_ITEM_INFO,
        10 => GIT_REPOSITORY_ITEM_HOOKS,
        11 => GIT_REPOSITORY_ITEM_LOGS,
        12 => GIT_REPOSITORY_ITEM_MODULES,
        13 => GIT_REPOSITORY_ITEM_WORKTREES,
        14 => GIT_REPOSITORY_ITEM_WORKTREE_CONFIG,
        15 => GIT_REPOSITORY_ITEM__LAST,
        _ => throw ArgumentError(
            'Unknown value for git_repository_item_t: $value'),
      };
}

typedef git_repository_fetchhead_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Char> ref_name,
    ffi.Pointer<ffi.Char> remote_url,
    ffi.Pointer<git_oid> oid,
    ffi.UnsignedInt is_merge,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_repository_fetchhead_foreach_cbFunction = int Function(
    ffi.Pointer<ffi.Char> ref_name,
    ffi.Pointer<ffi.Char> remote_url,
    ffi.Pointer<git_oid> oid,
    int is_merge,
    ffi.Pointer<ffi.Void> payload);

/// Callback used to iterate over each FETCH_HEAD entry
///
/// @see git_repository_fetchhead_foreach
///
/// @param ref_name The reference name
/// @param remote_url The remote URL
/// @param oid The reference target OID
/// @param is_merge Was the reference the result of a merge
/// @param payload Payload passed to git_repository_fetchhead_foreach
/// @return non-zero to terminate the iteration
typedef git_repository_fetchhead_foreach_cb = ffi
    .Pointer<ffi.NativeFunction<git_repository_fetchhead_foreach_cbFunction>>;
typedef git_repository_mergehead_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<git_oid> oid, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_repository_mergehead_foreach_cbFunction = int Function(
    ffi.Pointer<git_oid> oid, ffi.Pointer<ffi.Void> payload);

/// Callback used to iterate over each MERGE_HEAD entry
///
/// @see git_repository_mergehead_foreach
///
/// @param oid The merge OID
/// @param payload Payload passed to git_repository_mergehead_foreach
/// @return non-zero to terminate the iteration
typedef git_repository_mergehead_foreach_cb = ffi
    .Pointer<ffi.NativeFunction<git_repository_mergehead_foreach_cbFunction>>;

/// Repository state
///
/// These values represent possible states for the repository to be in,
/// based on the current operation which is ongoing.
enum git_repository_state_t {
  GIT_REPOSITORY_STATE_NONE(0),
  GIT_REPOSITORY_STATE_MERGE(1),
  GIT_REPOSITORY_STATE_REVERT(2),
  GIT_REPOSITORY_STATE_REVERT_SEQUENCE(3),
  GIT_REPOSITORY_STATE_CHERRYPICK(4),
  GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE(5),
  GIT_REPOSITORY_STATE_BISECT(6),
  GIT_REPOSITORY_STATE_REBASE(7),
  GIT_REPOSITORY_STATE_REBASE_INTERACTIVE(8),
  GIT_REPOSITORY_STATE_REBASE_MERGE(9),
  GIT_REPOSITORY_STATE_APPLY_MAILBOX(10),
  GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE(11);

  final int value;
  const git_repository_state_t(this.value);

  static git_repository_state_t fromValue(int value) => switch (value) {
        0 => GIT_REPOSITORY_STATE_NONE,
        1 => GIT_REPOSITORY_STATE_MERGE,
        2 => GIT_REPOSITORY_STATE_REVERT,
        3 => GIT_REPOSITORY_STATE_REVERT_SEQUENCE,
        4 => GIT_REPOSITORY_STATE_CHERRYPICK,
        5 => GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE,
        6 => GIT_REPOSITORY_STATE_BISECT,
        7 => GIT_REPOSITORY_STATE_REBASE,
        8 => GIT_REPOSITORY_STATE_REBASE_INTERACTIVE,
        9 => GIT_REPOSITORY_STATE_REBASE_MERGE,
        10 => GIT_REPOSITORY_STATE_APPLY_MAILBOX,
        11 => GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE,
        _ => throw ArgumentError(
            'Unknown value for git_repository_state_t: $value'),
      };
}

typedef git_treebuilder_filter_cbFunction = ffi.Int Function(
    ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_treebuilder_filter_cbFunction = int Function(
    ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload);

/// Callback for git_treebuilder_filter
///
/// The return value is treated as a boolean, with zero indicating that the
/// entry should be left alone and any non-zero value meaning that the
/// entry should be removed from the treebuilder list (i.e. filtered out).
///
/// @param entry the tree entry for the callback to examine
/// @param payload the payload from the caller
/// @return 0 to do nothing, non-zero to remove the entry
typedef git_treebuilder_filter_cb
    = ffi.Pointer<ffi.NativeFunction<git_treebuilder_filter_cbFunction>>;
typedef git_treewalk_cbFunction = ffi.Int Function(ffi.Pointer<ffi.Char> root,
    ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_treewalk_cbFunction = int Function(ffi.Pointer<ffi.Char> root,
    ffi.Pointer<git_tree_entry> entry, ffi.Pointer<ffi.Void> payload);

/// Callback for the tree traversal method.
///
/// @param root the current (relative) root to the entry
/// @param entry the tree entry
/// @param payload the caller-provided callback payload
/// @return a positive value to skip the entry, a negative value to stop the walk
typedef git_treewalk_cb
    = ffi.Pointer<ffi.NativeFunction<git_treewalk_cbFunction>>;

/// Tree traversal modes
enum git_treewalk_mode {
  /// Pre-order
  GIT_TREEWALK_PRE(0),

  /// Post-order
  GIT_TREEWALK_POST(1);

  final int value;
  const git_treewalk_mode(this.value);

  static git_treewalk_mode fromValue(int value) => switch (value) {
        0 => GIT_TREEWALK_PRE,
        1 => GIT_TREEWALK_POST,
        _ => throw ArgumentError('Unknown value for git_treewalk_mode: $value'),
      };
}

/// The kind of update to perform
enum git_tree_update_t {
  /// Update or insert an entry at the specified path
  GIT_TREE_UPDATE_UPSERT(0),

  /// Remove an entry from the specified path
  GIT_TREE_UPDATE_REMOVE(1);

  final int value;
  const git_tree_update_t(this.value);

  static git_tree_update_t fromValue(int value) => switch (value) {
        0 => GIT_TREE_UPDATE_UPSERT,
        1 => GIT_TREE_UPDATE_REMOVE,
        _ => throw ArgumentError('Unknown value for git_tree_update_t: $value'),
      };
}

/// An action to perform during the update of a tree
final class git_tree_update extends ffi.Struct {
  /// Update action. If it's an removal, only the path is looked at
  @ffi.UnsignedInt()
  external int actionAsInt;

  git_tree_update_t get action => git_tree_update_t.fromValue(actionAsInt);

  /// The entry's id
  external git_oid id;

  /// The filemode/kind of object
  @ffi.UnsignedInt()
  external int filemodeAsInt;

  git_filemode_t get filemode => git_filemode_t.fromValue(filemodeAsInt);

  /// The full path from the root tree
  external ffi.Pointer<ffi.Char> path;
}

typedef git_reference_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<git_reference> reference, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_reference_foreach_cbFunction = int Function(
    ffi.Pointer<git_reference> reference, ffi.Pointer<ffi.Void> payload);

/// Callback used to iterate over references
///
/// @see git_reference_foreach
///
/// @param reference The reference object
/// @param payload Payload passed to git_reference_foreach
/// @return non-zero to terminate the iteration
typedef git_reference_foreach_cb
    = ffi.Pointer<ffi.NativeFunction<git_reference_foreach_cbFunction>>;
typedef git_reference_foreach_name_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_reference_foreach_name_cbFunction = int Function(
    ffi.Pointer<ffi.Char> name, ffi.Pointer<ffi.Void> payload);

/// Callback used to iterate over reference names
///
/// @see git_reference_foreach_name
///
/// @param name The reference name
/// @param payload Payload passed to git_reference_foreach_name
/// @return non-zero to terminate the iteration
typedef git_reference_foreach_name_cb
    = ffi.Pointer<ffi.NativeFunction<git_reference_foreach_name_cbFunction>>;

/// Normalization options for reference lookup
enum git_reference_format_t {
  /// No particular normalization.
  GIT_REFERENCE_FORMAT_NORMAL(0),

  /// Control whether one-level refnames are accepted
  /// (i.e., refnames that do not contain multiple /-separated
  /// components). Those are expected to be written only using
  /// uppercase letters and underscore (FETCH_HEAD, ...)
  GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL(1),

  /// Interpret the provided name as a reference pattern for a
  /// refspec (as used with remote repositories). If this option
  /// is enabled, the name is allowed to contain a single * (<star>)
  /// in place of a one full pathname component
  /// (e.g., foo/<star>/bar but not foo/bar<star>).
  GIT_REFERENCE_FORMAT_REFSPEC_PATTERN(2),

  /// Interpret the name as part of a refspec in shorthand form
  /// so the `ONELEVEL` naming rules aren't enforced and 'master'
  /// becomes a valid name.
  GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND(4);

  final int value;
  const git_reference_format_t(this.value);

  static git_reference_format_t fromValue(int value) => switch (value) {
        0 => GIT_REFERENCE_FORMAT_NORMAL,
        1 => GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL,
        2 => GIT_REFERENCE_FORMAT_REFSPEC_PATTERN,
        4 => GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND,
        _ => throw ArgumentError(
            'Unknown value for git_reference_format_t: $value'),
      };
}

/// Flags for diff options.  A combination of these flags can be passed
/// in via the `flags` value in the `git_diff_options`.
enum git_diff_option_t {
  /// Normal diff, the default
  GIT_DIFF_NORMAL(0),

  /// Reverse the sides of the diff
  GIT_DIFF_REVERSE(1),

  /// Include ignored files in the diff
  GIT_DIFF_INCLUDE_IGNORED(2),

  /// Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
  /// will be marked with only a single entry in the diff; this flag
  /// adds all files under the directory as IGNORED entries, too.
  GIT_DIFF_RECURSE_IGNORED_DIRS(4),

  /// Include untracked files in the diff
  GIT_DIFF_INCLUDE_UNTRACKED(8),

  /// Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
  /// directory will be marked with only a single entry in the diff
  /// (a la what core Git does in `git status`); this flag adds *all*
  /// files under untracked directories as UNTRACKED entries, too.
  GIT_DIFF_RECURSE_UNTRACKED_DIRS(16),

  /// Include unmodified files in the diff
  GIT_DIFF_INCLUDE_UNMODIFIED(32),

  /// Normally, a type change between files will be converted into a
  /// DELETED record for the old and an ADDED record for the new; this
  /// options enabled the generation of TYPECHANGE delta records.
  GIT_DIFF_INCLUDE_TYPECHANGE(64),

  /// Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still
  /// generally show as a DELETED blob.  This flag tries to correctly
  /// label blob->tree transitions as TYPECHANGE records with new_file's
  /// mode set to tree.  Note: the tree SHA will not be available.
  GIT_DIFF_INCLUDE_TYPECHANGE_TREES(128),

  /// Ignore file mode changes
  GIT_DIFF_IGNORE_FILEMODE(256),

  /// Treat all submodules as unmodified
  GIT_DIFF_IGNORE_SUBMODULES(512),

  /// Use case insensitive filename comparisons
  GIT_DIFF_IGNORE_CASE(1024),

  /// May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
  /// that has changed case will be returned as an add/delete pair.
  GIT_DIFF_INCLUDE_CASECHANGE(2048),

  /// If the pathspec is set in the diff options, this flags indicates
  /// that the paths will be treated as literal paths instead of
  /// fnmatch patterns.  Each path in the list must either be a full
  /// path to a file or a directory.  (A trailing slash indicates that
  /// the path will _only_ match a directory).  If a directory is
  /// specified, all children will be included.
  GIT_DIFF_DISABLE_PATHSPEC_MATCH(4096),

  /// Disable updating of the `binary` flag in delta records.  This is
  /// useful when iterating over a diff if you don't need hunk and data
  /// callbacks and want to avoid having to load file completely.
  GIT_DIFF_SKIP_BINARY_CHECK(8192),

  /// When diff finds an untracked directory, to match the behavior of
  /// core Git, it scans the contents for IGNORED and UNTRACKED files.
  /// If *all* contents are IGNORED, then the directory is IGNORED; if
  /// any contents are not IGNORED, then the directory is UNTRACKED.
  /// This is extra work that may not matter in many cases.  This flag
  /// turns off that scan and immediately labels an untracked directory
  /// as UNTRACKED (changing the behavior to not match core Git).
  GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS(16384),

  /// When diff finds a file in the working directory with stat
  /// information different from the index, but the OID ends up being the
  /// same, write the correct stat information into the index.  Note:
  /// without this flag, diff will always leave the index untouched.
  GIT_DIFF_UPDATE_INDEX(32768),

  /// Include unreadable files in the diff
  GIT_DIFF_INCLUDE_UNREADABLE(65536),

  /// Include unreadable files in the diff
  GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED(131072),

  /// Use a heuristic that takes indentation and whitespace into account
  /// which generally can produce better diffs when dealing with ambiguous
  /// diff hunks.
  GIT_DIFF_INDENT_HEURISTIC(262144),

  /// Ignore blank lines
  GIT_DIFF_IGNORE_BLANK_LINES(524288),

  /// Treat all files as text, disabling binary attributes & detection
  GIT_DIFF_FORCE_TEXT(1048576),

  /// Treat all files as binary, disabling text diffs
  GIT_DIFF_FORCE_BINARY(2097152),

  /// Ignore all whitespace
  GIT_DIFF_IGNORE_WHITESPACE(4194304),

  /// Ignore changes in amount of whitespace
  GIT_DIFF_IGNORE_WHITESPACE_CHANGE(8388608),

  /// Ignore whitespace at end of line
  GIT_DIFF_IGNORE_WHITESPACE_EOL(16777216),

  /// When generating patch text, include the content of untracked
  /// files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
  /// it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
  /// flag if you want the content of every single UNTRACKED file.
  GIT_DIFF_SHOW_UNTRACKED_CONTENT(33554432),

  /// When generating output, include the names of unmodified files if
  /// they are included in the git_diff.  Normally these are skipped in
  /// the formats that list files (e.g. name-only, name-status, raw).
  /// Even with this, these will not be included in patch format.
  GIT_DIFF_SHOW_UNMODIFIED(67108864),

  /// Use the "patience diff" algorithm
  GIT_DIFF_PATIENCE(268435456),

  /// Take extra time to find minimal diff
  GIT_DIFF_MINIMAL(536870912),

  /// Include the necessary deflate / delta information so that `git-apply`
  /// can apply given diff information to binary files.
  GIT_DIFF_SHOW_BINARY(1073741824);

  final int value;
  const git_diff_option_t(this.value);

  static git_diff_option_t fromValue(int value) => switch (value) {
        0 => GIT_DIFF_NORMAL,
        1 => GIT_DIFF_REVERSE,
        2 => GIT_DIFF_INCLUDE_IGNORED,
        4 => GIT_DIFF_RECURSE_IGNORED_DIRS,
        8 => GIT_DIFF_INCLUDE_UNTRACKED,
        16 => GIT_DIFF_RECURSE_UNTRACKED_DIRS,
        32 => GIT_DIFF_INCLUDE_UNMODIFIED,
        64 => GIT_DIFF_INCLUDE_TYPECHANGE,
        128 => GIT_DIFF_INCLUDE_TYPECHANGE_TREES,
        256 => GIT_DIFF_IGNORE_FILEMODE,
        512 => GIT_DIFF_IGNORE_SUBMODULES,
        1024 => GIT_DIFF_IGNORE_CASE,
        2048 => GIT_DIFF_INCLUDE_CASECHANGE,
        4096 => GIT_DIFF_DISABLE_PATHSPEC_MATCH,
        8192 => GIT_DIFF_SKIP_BINARY_CHECK,
        16384 => GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS,
        32768 => GIT_DIFF_UPDATE_INDEX,
        65536 => GIT_DIFF_INCLUDE_UNREADABLE,
        131072 => GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED,
        262144 => GIT_DIFF_INDENT_HEURISTIC,
        524288 => GIT_DIFF_IGNORE_BLANK_LINES,
        1048576 => GIT_DIFF_FORCE_TEXT,
        2097152 => GIT_DIFF_FORCE_BINARY,
        4194304 => GIT_DIFF_IGNORE_WHITESPACE,
        8388608 => GIT_DIFF_IGNORE_WHITESPACE_CHANGE,
        16777216 => GIT_DIFF_IGNORE_WHITESPACE_EOL,
        33554432 => GIT_DIFF_SHOW_UNTRACKED_CONTENT,
        67108864 => GIT_DIFF_SHOW_UNMODIFIED,
        268435456 => GIT_DIFF_PATIENCE,
        536870912 => GIT_DIFF_MINIMAL,
        1073741824 => GIT_DIFF_SHOW_BINARY,
        _ => throw ArgumentError('Unknown value for git_diff_option_t: $value'),
      };
}

final class git_diff extends ffi.Opaque {}

/// Flags for the delta object and the file objects on each side.
///
/// These flags are used for both the `flags` value of the `git_diff_delta`
/// and the flags for the `git_diff_file` objects representing the old and
/// new sides of the delta.  Values outside of this public range should be
/// considered reserved for internal or future use.
enum git_diff_flag_t {
  /// < file(s) treated as binary data
  GIT_DIFF_FLAG_BINARY(1),

  /// < file(s) treated as text data
  GIT_DIFF_FLAG_NOT_BINARY(2),

  /// < `id` value is known correct
  GIT_DIFF_FLAG_VALID_ID(4),

  /// < file exists at this side of the delta
  GIT_DIFF_FLAG_EXISTS(8),

  /// < file size value is known correct
  GIT_DIFF_FLAG_VALID_SIZE(16);

  final int value;
  const git_diff_flag_t(this.value);

  static git_diff_flag_t fromValue(int value) => switch (value) {
        1 => GIT_DIFF_FLAG_BINARY,
        2 => GIT_DIFF_FLAG_NOT_BINARY,
        4 => GIT_DIFF_FLAG_VALID_ID,
        8 => GIT_DIFF_FLAG_EXISTS,
        16 => GIT_DIFF_FLAG_VALID_SIZE,
        _ => throw ArgumentError('Unknown value for git_diff_flag_t: $value'),
      };
}

/// What type of change is described by a git_diff_delta?
///
/// `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run
/// `git_diff_find_similar()` on the diff object.
///
/// `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE`
/// in the option flags (otherwise type changes will be split into ADDED /
/// DELETED pairs).
enum git_delta_t {
  /// < no changes
  GIT_DELTA_UNMODIFIED(0),

  /// < entry does not exist in old version
  GIT_DELTA_ADDED(1),

  /// < entry does not exist in new version
  GIT_DELTA_DELETED(2),

  /// < entry content changed between old and new
  GIT_DELTA_MODIFIED(3),

  /// < entry was renamed between old and new
  GIT_DELTA_RENAMED(4),

  /// < entry was copied from another old entry
  GIT_DELTA_COPIED(5),

  /// < entry is ignored item in workdir
  GIT_DELTA_IGNORED(6),

  /// < entry is untracked item in workdir
  GIT_DELTA_UNTRACKED(7),

  /// < type of entry changed between old and new
  GIT_DELTA_TYPECHANGE(8),

  /// < entry is unreadable
  GIT_DELTA_UNREADABLE(9),

  /// < entry in the index is conflicted
  GIT_DELTA_CONFLICTED(10);

  final int value;
  const git_delta_t(this.value);

  static git_delta_t fromValue(int value) => switch (value) {
        0 => GIT_DELTA_UNMODIFIED,
        1 => GIT_DELTA_ADDED,
        2 => GIT_DELTA_DELETED,
        3 => GIT_DELTA_MODIFIED,
        4 => GIT_DELTA_RENAMED,
        5 => GIT_DELTA_COPIED,
        6 => GIT_DELTA_IGNORED,
        7 => GIT_DELTA_UNTRACKED,
        8 => GIT_DELTA_TYPECHANGE,
        9 => GIT_DELTA_UNREADABLE,
        10 => GIT_DELTA_CONFLICTED,
        _ => throw ArgumentError('Unknown value for git_delta_t: $value'),
      };
}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
final class git_diff_file extends ffi.Struct {
  /// The `git_oid` of the item.  If the entry represents an
  /// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
  /// then the oid will be zeroes.
  external git_oid id;

  /// The NUL-terminated path to the entry relative to the working
  /// directory of the repository.
  external ffi.Pointer<ffi.Char> path;

  /// The size of the entry in bytes.
  @git_object_size_t()
  external int size;

  /// A combination of the `git_diff_flag_t` types
  @ffi.Uint32()
  external int flags;

  /// Roughly, the stat() `st_mode` value for the item.  This will
  /// be restricted to one of the `git_filemode_t` values.
  @ffi.Uint16()
  external int mode;

  /// Represents the known length of the `id` field, when
  /// converted to a hex string.  It is generally `GIT_OID_SHA1_HEXSIZE`, unless this
  /// delta was created from reading a patch file, in which case it may be
  /// abbreviated to something reasonable, like 7 characters.
  @ffi.Uint16()
  external int id_abbrev;
}

/// Description of changes to one entry.
///
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
///
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
///
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
///
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
///
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
///
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
///
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
final class git_diff_delta extends ffi.Struct {
  @ffi.UnsignedInt()
  external int statusAsInt;

  git_delta_t get status => git_delta_t.fromValue(statusAsInt);

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;
}

typedef git_diff_notify_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff> diff_so_far,
    ffi.Pointer<git_diff_delta> delta_to_add,
    ffi.Pointer<ffi.Char> matched_pathspec,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_diff_notify_cbFunction = int Function(
    ffi.Pointer<git_diff> diff_so_far,
    ffi.Pointer<git_diff_delta> delta_to_add,
    ffi.Pointer<ffi.Char> matched_pathspec,
    ffi.Pointer<ffi.Void> payload);

/// Diff notification callback function.
///
/// The callback will be called for each file, just before the `git_diff_delta`
/// gets inserted into the diff.
///
/// When the callback:
/// - returns < 0, the diff process will be aborted.
/// - returns > 0, the delta will not be inserted into the diff, but the
/// diff process continues.
/// - returns 0, the delta is inserted into the diff, and the diff process
/// continues.
///
/// @param diff_so_far the diff structure as it currently exists
/// @param delta_to_add the delta that is to be added
/// @param matched_pathspec the pathspec
/// @param payload the user-specified callback payload
/// @return 0 on success, 1 to skip this delta, or an error code
typedef git_diff_notify_cb
    = ffi.Pointer<ffi.NativeFunction<git_diff_notify_cbFunction>>;
typedef git_diff_progress_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff> diff_so_far,
    ffi.Pointer<ffi.Char> old_path,
    ffi.Pointer<ffi.Char> new_path,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_diff_progress_cbFunction = int Function(
    ffi.Pointer<git_diff> diff_so_far,
    ffi.Pointer<ffi.Char> old_path,
    ffi.Pointer<ffi.Char> new_path,
    ffi.Pointer<ffi.Void> payload);

/// Diff progress callback.
///
/// Called before each file comparison.
///
/// @param diff_so_far The diff being generated.
/// @param old_path The path to the old file or NULL.
/// @param new_path The path to the new file or NULL.
/// @param payload the user-specified callback payload
/// @return 0 or an error code
typedef git_diff_progress_cb
    = ffi.Pointer<ffi.NativeFunction<git_diff_progress_cbFunction>>;

/// Structure describing options about how the diff should be executed.
///
/// Setting all values of the structure to zero will yield the default
/// values.  Similarly, passing NULL for the options structure will
/// give the defaults.  The default values are marked below.
final class git_diff_options extends ffi.Struct {
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_diff_option_t` values above.
  /// Defaults to GIT_DIFF_NORMAL
  @ffi.Uint32()
  external int flags;

  /// Overrides the submodule ignore setting for all submodules in the diff.
  @ffi.Int()
  external int ignore_submodulesAsInt;

  git_submodule_ignore_t get ignore_submodules =>
      git_submodule_ignore_t.fromValue(ignore_submodulesAsInt);

  /// An array of paths / fnmatch patterns to constrain diff.
  /// All paths are included by default.
  external git_strarray pathspec;

  /// An optional callback function, notifying the consumer of changes to
  /// the diff as new deltas are added.
  external git_diff_notify_cb notify_cb;

  /// An optional callback function, notifying the consumer of which files
  /// are being examined as the diff is generated.
  external git_diff_progress_cb progress_cb;

  /// The payload to pass to the callback functions.
  external ffi.Pointer<ffi.Void> payload;

  /// The number of unchanged lines that define the boundary of a hunk
  /// (and to display before and after). Defaults to 3.
  @ffi.Uint32()
  external int context_lines;

  /// The maximum number of unchanged lines between hunk boundaries before
  /// the hunks will be merged into one. Defaults to 0.
  @ffi.Uint32()
  external int interhunk_lines;

  /// The object ID type to emit in diffs; this is used by functions
  /// that operate without a repository - namely `git_diff_buffers`,
  /// or `git_diff_blobs` and `git_diff_blob_to_buffer` when one blob
  /// is `NULL`.
  ///
  /// This may be omitted (set to `0`). If a repository is available,
  /// the object ID format of the repository will be used. If no
  /// repository is available then the default is `GIT_OID_SHA`.
  ///
  /// If this is specified and a repository is available, then the
  /// specified `oid_type` must match the repository's object ID
  /// format.
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

  /// The abbreviation length to use when formatting object ids.
  /// Defaults to the value of 'core.abbrev' from the config, or 7 if unset.
  @ffi.Uint16()
  external int id_abbrev;

  /// A size (in bytes) above which a blob will be marked as binary
  /// automatically; pass a negative value to disable.
  /// Defaults to 512MB.
  @git_off_t()
  external int max_size;

  /// The virtual "directory" prefix for old file names in hunk headers.
  /// Default is "a".
  external ffi.Pointer<ffi.Char> old_prefix;

  /// The virtual "directory" prefix for new file names in hunk headers.
  /// Defaults to "b".
  external ffi.Pointer<ffi.Char> new_prefix;
}

typedef git_diff_file_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Float progress,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_diff_file_cbFunction = int Function(
    ffi.Pointer<git_diff_delta> delta,
    double progress,
    ffi.Pointer<ffi.Void> payload);

/// When iterating over a diff, callback that will be made per file.
///
/// @param delta A pointer to the delta data for the file
/// @param progress Goes from 0 to 1 over the diff
/// @param payload User-specified pointer from foreach function
/// @return 0 or an error code
typedef git_diff_file_cb
    = ffi.Pointer<ffi.NativeFunction<git_diff_file_cbFunction>>;

/// When producing a binary diff, the binary data returned will be
/// either the deflated full ("literal") contents of the file, or
/// the deflated binary delta between the two sides (whichever is
/// smaller).
enum git_diff_binary_t {
  /// There is no binary delta.
  GIT_DIFF_BINARY_NONE(0),

  /// The binary data is the literal contents of the file.
  GIT_DIFF_BINARY_LITERAL(1),

  /// The binary data is the delta from one side to the other.
  GIT_DIFF_BINARY_DELTA(2);

  final int value;
  const git_diff_binary_t(this.value);

  static git_diff_binary_t fromValue(int value) => switch (value) {
        0 => GIT_DIFF_BINARY_NONE,
        1 => GIT_DIFF_BINARY_LITERAL,
        2 => GIT_DIFF_BINARY_DELTA,
        _ => throw ArgumentError('Unknown value for git_diff_binary_t: $value'),
      };
}

/// The contents of one of the files in a binary diff.
final class git_diff_binary_file extends ffi.Struct {
  /// The type of binary data for this file.
  @ffi.UnsignedInt()
  external int typeAsInt;

  git_diff_binary_t get type => git_diff_binary_t.fromValue(typeAsInt);

  /// The binary data, deflated.
  external ffi.Pointer<ffi.Char> data;

  /// The length of the binary data.
  @ffi.Size()
  external int datalen;

  /// The length of the binary data after inflation.
  @ffi.Size()
  external int inflatedlen;
}

/// Structure describing the binary contents of a diff.
///
/// A `binary` file / delta is a file (or pair) for which no text diffs
/// should be generated. A diff can contain delta entries that are
/// binary, but no diff content will be output for those files. There is
/// a base heuristic for binary detection and you can further tune the
/// behavior with git attributes or diff flags and option settings.
final class git_diff_binary extends ffi.Struct {
  /// Whether there is data in this binary structure or not.
  ///
  /// If this is `1`, then this was produced and included binary content.
  /// If this is `0` then this was generated knowing only that a binary
  /// file changed but without providing the data, probably from a patch
  /// that said `Binary files a/file.txt and b/file.txt differ`.
  @ffi.UnsignedInt()
  external int contains_data;

  /// < The contents of the old file.
  external git_diff_binary_file old_file;

  /// < The contents of the new file.
  external git_diff_binary_file new_file;
}

typedef git_diff_binary_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_binary> binary,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_diff_binary_cbFunction = int Function(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_binary> binary,
    ffi.Pointer<ffi.Void> payload);

/// When iterating over a diff, callback that will be made for
/// binary content within the diff.
///
/// @param delta the delta
/// @param binary the binary content
/// @param payload the user-specified callback payload
/// @return 0 or an error code
typedef git_diff_binary_cb
    = ffi.Pointer<ffi.NativeFunction<git_diff_binary_cbFunction>>;

/// Structure describing a hunk of a diff.
///
/// A `hunk` is a span of modified lines in a delta along with some stable
/// surrounding context. You can configure the amount of context and other
/// properties of how hunks are generated. Each hunk also comes with a
/// header that described where it starts and ends in both the old and new
/// versions in the delta.
final class git_diff_hunk extends ffi.Struct {
  /// < Starting line number in old_file
  @ffi.Int()
  external int old_start;

  /// < Number of lines in old_file
  @ffi.Int()
  external int old_lines;

  /// < Starting line number in new_file
  @ffi.Int()
  external int new_start;

  /// < Number of lines in new_file
  @ffi.Int()
  external int new_lines;

  /// < Number of bytes in header text
  @ffi.Size()
  external int header_len;

  /// < Header text, NUL-byte terminated
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> header;
}

typedef git_diff_hunk_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_hunk> hunk,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_diff_hunk_cbFunction = int Function(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_hunk> hunk,
    ffi.Pointer<ffi.Void> payload);

/// When iterating over a diff, callback that will be made per hunk.
///
/// @param delta the delta
/// @param hunk the hunk
/// @param payload the user-specified callback payload
/// @return 0 or an error code
typedef git_diff_hunk_cb
    = ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cbFunction>>;

/// Line origin constants.
///
/// These values describe where a line came from and will be passed to
/// the git_diff_line_cb when iterating over a diff.  There are some
/// special origin constants at the end that are used for the text
/// output callbacks to demarcate lines that are actually part of
/// the file or hunk headers.
enum git_diff_line_t {
  /// These values will be sent to `git_diff_line_cb` along with the line
  GIT_DIFF_LINE_CONTEXT(32),
  GIT_DIFF_LINE_ADDITION(43),
  GIT_DIFF_LINE_DELETION(45),

  /// < Both files have no LF at end
  GIT_DIFF_LINE_CONTEXT_EOFNL(61),

  /// < Old has no LF at end, new does
  GIT_DIFF_LINE_ADD_EOFNL(62),

  /// < Old has LF at end, new does not
  GIT_DIFF_LINE_DEL_EOFNL(60),

  /// The following values will only be sent to a `git_diff_line_cb` when
  /// the content of a diff is being formatted through `git_diff_print`.
  GIT_DIFF_LINE_FILE_HDR(70),
  GIT_DIFF_LINE_HUNK_HDR(72),

  /// < For "Binary files x and y differ"
  GIT_DIFF_LINE_BINARY(66);

  final int value;
  const git_diff_line_t(this.value);

  static git_diff_line_t fromValue(int value) => switch (value) {
        32 => GIT_DIFF_LINE_CONTEXT,
        43 => GIT_DIFF_LINE_ADDITION,
        45 => GIT_DIFF_LINE_DELETION,
        61 => GIT_DIFF_LINE_CONTEXT_EOFNL,
        62 => GIT_DIFF_LINE_ADD_EOFNL,
        60 => GIT_DIFF_LINE_DEL_EOFNL,
        70 => GIT_DIFF_LINE_FILE_HDR,
        72 => GIT_DIFF_LINE_HUNK_HDR,
        66 => GIT_DIFF_LINE_BINARY,
        _ => throw ArgumentError('Unknown value for git_diff_line_t: $value'),
      };
}

/// Structure describing a line (or data span) of a diff.
///
/// A `line` is a range of characters inside a hunk.  It could be a context
/// line (i.e. in both old and new versions), an added line (i.e. only in
/// the new version), or a removed line (i.e. only in the old version).
/// Unfortunately, we don't know anything about the encoding of data in the
/// file being diffed, so we cannot tell you much about the line content.
/// Line data will not be NUL-byte terminated, however, because it will be
/// just a span of bytes inside the larger file.
final class git_diff_line extends ffi.Struct {
  /// < A git_diff_line_t value
  @ffi.Char()
  external int origin;

  /// < Line number in old file or -1 for added line
  @ffi.Int()
  external int old_lineno;

  /// < Line number in new file or -1 for deleted line
  @ffi.Int()
  external int new_lineno;

  /// < Number of newline characters in content
  @ffi.Int()
  external int num_lines;

  /// < Number of bytes of data
  @ffi.Size()
  external int content_len;

  /// < Offset in the original file to the content
  @git_off_t()
  external int content_offset;

  /// < Pointer to diff text, not NUL-byte terminated
  external ffi.Pointer<ffi.Char> content;
}

typedef git_diff_line_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_hunk> hunk,
    ffi.Pointer<git_diff_line> line,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_diff_line_cbFunction = int Function(
    ffi.Pointer<git_diff_delta> delta,
    ffi.Pointer<git_diff_hunk> hunk,
    ffi.Pointer<git_diff_line> line,
    ffi.Pointer<ffi.Void> payload);

/// When iterating over a diff, callback that will be made per text diff
/// line. In this context, the provided range will be NULL.
///
/// When printing a diff, callback that will be made to output each line
/// of text.  This uses some extra GIT_DIFF_LINE_... constants for output
/// of lines of file and hunk headers.
///
/// @param delta the delta that contains the line
/// @param hunk the hunk that contains the line
/// @param line the line in the diff
/// @param payload the user-specified callback payload
/// @return 0 or an error code
typedef git_diff_line_cb
    = ffi.Pointer<ffi.NativeFunction<git_diff_line_cbFunction>>;

/// Flags to control the behavior of diff rename/copy detection.
enum git_diff_find_t {
  /// Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag.
  GIT_DIFF_FIND_BY_CONFIG(0),

  /// Look for renames? (`--find-renames`)
  GIT_DIFF_FIND_RENAMES(1),

  /// Consider old side of MODIFIED for renames? (`--break-rewrites=N`)
  GIT_DIFF_FIND_RENAMES_FROM_REWRITES(2),

  /// Look for copies? (a la `--find-copies`).
  GIT_DIFF_FIND_COPIES(4),

  /// Consider UNMODIFIED as copy sources? (`--find-copies-harder`).
  ///
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNMODIFIED when
  /// the initial `git_diff` is being generated.
  GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED(8),

  /// Mark significant rewrites for split (`--break-rewrites=/M`)
  GIT_DIFF_FIND_REWRITES(16),

  /// Actually split large rewrites into delete/add pairs
  GIT_DIFF_BREAK_REWRITES(32),

  /// Mark rewrites for split and break into delete/add pairs
  GIT_DIFF_FIND_AND_BREAK_REWRITES(48),

  /// Find renames/copies for UNTRACKED items in working directory.
  ///
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNTRACKED when the
  /// initial `git_diff` is being generated (and obviously the diff must
  /// be against the working directory for this to make sense).
  GIT_DIFF_FIND_FOR_UNTRACKED(64),

  /// Turn on all finding features.
  GIT_DIFF_FIND_ALL(255),

  /// Measure similarity ignoring all whitespace
  GIT_DIFF_FIND_IGNORE_WHITESPACE(4096),

  /// Measure similarity including all data
  GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE(8192),

  /// Measure similarity only by comparing SHAs (fast and cheap)
  GIT_DIFF_FIND_EXACT_MATCH_ONLY(16384),

  /// Do not break rewrites unless they contribute to a rename.
  ///
  /// Normally, GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-
  /// similarity of modified files and split the ones that have changed a
  /// lot into a DELETE / ADD pair.  Then the sides of that pair will be
  /// considered candidates for rename and copy detection.
  ///
  /// If you add this flag in and the split pair is *not* used for an
  /// actual rename or copy, then the modified record will be restored to
  /// a regular MODIFIED record instead of being split.
  GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY(32768),

  /// Remove any UNMODIFIED deltas after find_similar is done.
  ///
  /// Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the
  /// --find-copies-harder behavior requires building a diff with the
  /// GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED
  /// records in the final result, pass this flag to have them removed.
  GIT_DIFF_FIND_REMOVE_UNMODIFIED(65536);

  /// Measure similarity ignoring leading whitespace (default)
  static const GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE =
      GIT_DIFF_FIND_BY_CONFIG;

  final int value;
  const git_diff_find_t(this.value);

  static git_diff_find_t fromValue(int value) => switch (value) {
        0 => GIT_DIFF_FIND_BY_CONFIG,
        1 => GIT_DIFF_FIND_RENAMES,
        2 => GIT_DIFF_FIND_RENAMES_FROM_REWRITES,
        4 => GIT_DIFF_FIND_COPIES,
        8 => GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED,
        16 => GIT_DIFF_FIND_REWRITES,
        32 => GIT_DIFF_BREAK_REWRITES,
        48 => GIT_DIFF_FIND_AND_BREAK_REWRITES,
        64 => GIT_DIFF_FIND_FOR_UNTRACKED,
        255 => GIT_DIFF_FIND_ALL,
        4096 => GIT_DIFF_FIND_IGNORE_WHITESPACE,
        8192 => GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE,
        16384 => GIT_DIFF_FIND_EXACT_MATCH_ONLY,
        32768 => GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY,
        65536 => GIT_DIFF_FIND_REMOVE_UNMODIFIED,
        _ => throw ArgumentError('Unknown value for git_diff_find_t: $value'),
      };

  @override
  String toString() {
    if (this == GIT_DIFF_FIND_BY_CONFIG)
      return "git_diff_find_t.GIT_DIFF_FIND_BY_CONFIG, git_diff_find_t.GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE";
    return super.toString();
  }
}

/// Pluggable similarity metric
final class git_diff_similarity_metric extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>> out,
              ffi.Pointer<git_diff_file> file,
              ffi.Pointer<ffi.Char> fullpath,
              ffi.Pointer<ffi.Void> payload)>> file_signature;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>> out,
              ffi.Pointer<git_diff_file> file,
              ffi.Pointer<ffi.Char> buf,
              ffi.Size buflen,
              ffi.Pointer<ffi.Void> payload)>> buffer_signature;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> sig, ffi.Pointer<ffi.Void> payload)>>
      free_signature;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int> score,
              ffi.Pointer<ffi.Void> siga,
              ffi.Pointer<ffi.Void> sigb,
              ffi.Pointer<ffi.Void> payload)>> similarity;

  external ffi.Pointer<ffi.Void> payload;
}

/// Control behavior of rename and copy detection
///
/// These options mostly mimic parameters that can be passed to git-diff.
final class git_diff_find_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).
  /// NOTE: if you don't explicitly set this, `diff.renames` could be set
  /// to false, resulting in `git_diff_find_similar` doing nothing.
  @ffi.Uint32()
  external int flags;

  /// Threshold above which similar files will be considered renames.
  /// This is equivalent to the -M option. Defaults to 50.
  @ffi.Uint16()
  external int rename_threshold;

  /// Threshold below which similar files will be eligible to be a rename source.
  /// This is equivalent to the first part of the -B option. Defaults to 50.
  @ffi.Uint16()
  external int rename_from_rewrite_threshold;

  /// Threshold above which similar files will be considered copies.
  /// This is equivalent to the -C option. Defaults to 50.
  @ffi.Uint16()
  external int copy_threshold;

  /// Threshold below which similar files will be split into a delete/add pair.
  /// This is equivalent to the last part of the -B option. Defaults to 60.
  @ffi.Uint16()
  external int break_rewrite_threshold;

  /// Maximum number of matches to consider for a particular file.
  ///
  /// This is a little different from the `-l` option from Git because we
  /// will still process up to this many matches before abandoning the search.
  /// Defaults to 1000.
  @ffi.Size()
  external int rename_limit;

  /// The `metric` option allows you to plug in a custom similarity metric.
  ///
  /// Set it to NULL to use the default internal metric.
  ///
  /// The default metric is based on sampling hashes of ranges of data in
  /// the file, which is a pretty good similarity approximation that should
  /// work fairly well for both text and binary data while still being
  /// pretty fast with a fixed memory overhead.
  external ffi.Pointer<git_diff_similarity_metric> metric;
}

/// Possible output formats for diff data
enum git_diff_format_t {
  /// < full git diff
  GIT_DIFF_FORMAT_PATCH(1),

  /// < just the file headers of patch
  GIT_DIFF_FORMAT_PATCH_HEADER(2),

  /// < like git diff --raw
  GIT_DIFF_FORMAT_RAW(3),

  /// < like git diff --name-only
  GIT_DIFF_FORMAT_NAME_ONLY(4),

  /// < like git diff --name-status
  GIT_DIFF_FORMAT_NAME_STATUS(5),

  /// < git diff as used by git patch-id
  GIT_DIFF_FORMAT_PATCH_ID(6);

  final int value;
  const git_diff_format_t(this.value);

  static git_diff_format_t fromValue(int value) => switch (value) {
        1 => GIT_DIFF_FORMAT_PATCH,
        2 => GIT_DIFF_FORMAT_PATCH_HEADER,
        3 => GIT_DIFF_FORMAT_RAW,
        4 => GIT_DIFF_FORMAT_NAME_ONLY,
        5 => GIT_DIFF_FORMAT_NAME_STATUS,
        6 => GIT_DIFF_FORMAT_PATCH_ID,
        _ => throw ArgumentError('Unknown value for git_diff_format_t: $value'),
      };
}

/// Options for parsing a diff / patch file.
final class git_diff_parse_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

final class git_diff_stats extends ffi.Opaque {}

/// Formatting options for diff stats
enum git_diff_stats_format_t {
  /// No stats
  GIT_DIFF_STATS_NONE(0),

  /// Full statistics, equivalent of `--stat`
  GIT_DIFF_STATS_FULL(1),

  /// Short statistics, equivalent of `--shortstat`
  GIT_DIFF_STATS_SHORT(2),

  /// Number statistics, equivalent of `--numstat`
  GIT_DIFF_STATS_NUMBER(4),

  /// Extended header information such as creations, renames and mode changes, equivalent of `--summary`
  GIT_DIFF_STATS_INCLUDE_SUMMARY(8);

  final int value;
  const git_diff_stats_format_t(this.value);

  static git_diff_stats_format_t fromValue(int value) => switch (value) {
        0 => GIT_DIFF_STATS_NONE,
        1 => GIT_DIFF_STATS_FULL,
        2 => GIT_DIFF_STATS_SHORT,
        4 => GIT_DIFF_STATS_NUMBER,
        8 => GIT_DIFF_STATS_INCLUDE_SUMMARY,
        _ => throw ArgumentError(
            'Unknown value for git_diff_stats_format_t: $value'),
      };
}

/// Patch ID options structure
///
/// Initialize with `GIT_PATCHID_OPTIONS_INIT`. Alternatively, you can
/// use `git_diff_patchid_options_init`.
final class git_diff_patchid_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;
}

typedef git_apply_delta_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff_delta> delta, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_apply_delta_cbFunction = int Function(
    ffi.Pointer<git_diff_delta> delta, ffi.Pointer<ffi.Void> payload);

/// When applying a patch, callback that will be made per delta (file).
///
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the delta will not be applied, but the apply process
/// continues
/// - returns 0, the delta is applied, and the apply process continues.
///
/// @param delta The delta to be applied
/// @param payload User-specified payload
/// @return 0 if the delta is applied, < 0 if the apply process will be aborted
/// or > 0 if the delta will not be applied.
typedef git_apply_delta_cb
    = ffi.Pointer<ffi.NativeFunction<git_apply_delta_cbFunction>>;
typedef git_apply_hunk_cbFunction = ffi.Int Function(
    ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_apply_hunk_cbFunction = int Function(
    ffi.Pointer<git_diff_hunk> hunk, ffi.Pointer<ffi.Void> payload);

/// When applying a patch, callback that will be made per hunk.
///
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the hunk will not be applied, but the apply process
/// continues
/// - returns 0, the hunk is applied, and the apply process continues.
///
/// @param hunk The hunk to be applied
/// @param payload User-specified payload
/// @return 0 if the hunk is applied, < 0 if the apply process will be aborted
/// or > 0 if the hunk will not be applied.
typedef git_apply_hunk_cb
    = ffi.Pointer<ffi.NativeFunction<git_apply_hunk_cbFunction>>;

/// Flags controlling the behavior of `git_apply`.
///
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the hunk will not be applied, but the apply process
/// continues
/// - returns 0, the hunk is applied, and the apply process continues.
enum git_apply_flags_t {
  /// Don't actually make changes, just test that the patch applies.
  /// This is the equivalent of `git apply --check`.
  GIT_APPLY_CHECK(1);

  final int value;
  const git_apply_flags_t(this.value);

  static git_apply_flags_t fromValue(int value) => switch (value) {
        1 => GIT_APPLY_CHECK,
        _ => throw ArgumentError('Unknown value for git_apply_flags_t: $value'),
      };
}

/// Apply options structure.
///
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the hunk will not be applied, but the apply process
/// continues
/// - returns 0, the hunk is applied, and the apply process continues.
///
/// Initialize with `GIT_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_apply_options_init`.
///
/// @see git_apply_to_tree
/// @see git_apply
final class git_apply_options extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// When applying a patch, callback that will be made per delta (file).
  external git_apply_delta_cb delta_cb;

  /// When applying a patch, callback that will be made per hunk.
  external git_apply_hunk_cb hunk_cb;

  /// Payload passed to both `delta_cb` & `hunk_cb`.
  external ffi.Pointer<ffi.Void> payload;

  /// Bitmask of `git_apply_flags_t`
  @ffi.UnsignedInt()
  external int flags;
}

/// Possible application locations for git_apply
enum git_apply_location_t {
  /// Apply the patch to the workdir, leaving the index untouched.
  /// This is the equivalent of `git apply` with no location argument.
  GIT_APPLY_LOCATION_WORKDIR(0),

  /// Apply the patch to the index, leaving the working directory
  /// untouched.  This is the equivalent of `git apply --cached`.
  GIT_APPLY_LOCATION_INDEX(1),

  /// Apply the patch to both the working directory and the index.
  /// This is the equivalent of `git apply --index`.
  GIT_APPLY_LOCATION_BOTH(2);

  final int value;
  const git_apply_location_t(this.value);

  static git_apply_location_t fromValue(int value) => switch (value) {
        0 => GIT_APPLY_LOCATION_WORKDIR,
        1 => GIT_APPLY_LOCATION_INDEX,
        2 => GIT_APPLY_LOCATION_BOTH,
        _ =>
          throw ArgumentError('Unknown value for git_apply_location_t: $value'),
      };
}

/// Possible states for an attribute
enum git_attr_value_t {
  /// < The attribute has been left unspecified
  GIT_ATTR_VALUE_UNSPECIFIED(0),

  /// < The attribute has been set
  GIT_ATTR_VALUE_TRUE(1),

  /// < The attribute has been unset
  GIT_ATTR_VALUE_FALSE(2),

  /// < This attribute has a value
  GIT_ATTR_VALUE_STRING(3);

  final int value;
  const git_attr_value_t(this.value);

  static git_attr_value_t fromValue(int value) => switch (value) {
        0 => GIT_ATTR_VALUE_UNSPECIFIED,
        1 => GIT_ATTR_VALUE_TRUE,
        2 => GIT_ATTR_VALUE_FALSE,
        3 => GIT_ATTR_VALUE_STRING,
        _ => throw ArgumentError('Unknown value for git_attr_value_t: $value'),
      };
}

/// An options structure for querying attributes.
final class git_attr_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// A combination of GIT_ATTR_CHECK flags
  @ffi.UnsignedInt()
  external int flags;

  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_ATTR_CHECK_INCLUDE_COMMIT` is specified.
  external git_oid attr_commit_id;
}

typedef git_attr_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_attr_foreach_cbFunction = int Function(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
    ffi.Pointer<ffi.Void> payload);

/// The callback used with git_attr_foreach.
///
/// This callback will be invoked only once per attribute name, even if there
/// are multiple rules for a given file. The highest priority rule will be
/// used.
///
/// @see git_attr_foreach.
///
/// @param name The attribute name.
/// @param value The attribute value. May be NULL if the attribute is explicitly
/// set to UNSPECIFIED using the '!' sign.
/// @param payload A user-specified pointer.
/// @return 0 to continue looping, non-zero to stop. This value will be returned
/// from git_attr_foreach.
typedef git_attr_foreach_cb
    = ffi.Pointer<ffi.NativeFunction<git_attr_foreach_cbFunction>>;

/// Flags to control the functionality of `git_blob_filter`.
///
/// @flags
enum git_blob_filter_flag_t {
  /// When set, filters will not be applied to binary files.
  GIT_BLOB_FILTER_CHECK_FOR_BINARY(1),

  /// When set, filters will not load configuration from the
  /// system-wide `gitattributes` in `/etc` (or system equivalent).
  GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES(2),

  /// When set, filters will be loaded from a `.gitattributes` file
  /// in the HEAD commit.
  GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD(4),

  /// When set, filters will be loaded from a `.gitattributes` file
  /// in the specified commit.
  GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT(8);

  final int value;
  const git_blob_filter_flag_t(this.value);

  static git_blob_filter_flag_t fromValue(int value) => switch (value) {
        1 => GIT_BLOB_FILTER_CHECK_FOR_BINARY,
        2 => GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES,
        4 => GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD,
        8 => GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT,
        _ => throw ArgumentError(
            'Unknown value for git_blob_filter_flag_t: $value'),
      };
}

/// The options used when applying filter options to a file.
///
/// Initialize with `GIT_BLOB_FILTER_OPTIONS_INIT`. Alternatively, you can
/// use `git_blob_filter_options_init`.
///
/// @options[version] GIT_BLOB_FILTER_OPTIONS_VERSION
/// @options[init_macro] GIT_BLOB_FILTER_OPTIONS_INIT
/// @options[init_function] git_blob_filter_options_init
final class git_blob_filter_options extends ffi.Struct {
  /// Version number of the options structure.
  @ffi.Int()
  external int version;

  /// Flags to control the filtering process, see `git_blob_filter_flag_t` above.
  ///
  /// @type[flags] git_blob_filter_flag_t
  @ffi.Uint32()
  external int flags;

  /// This value is unused and reserved for API compatibility.
  ///
  /// @deprecated this value should not be set
  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
  external git_oid attr_commit_id;
}

/// Flags for indicating option behavior for git_blame APIs.
enum git_blame_flag_t {
  /// Normal blame, the default
  GIT_BLAME_NORMAL(0),

  /// Track lines that have moved within a file (like `git blame -M`).
  ///
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_SAME_FILE(1),

  /// Track lines that have moved across files in the same commit
  /// (like `git blame -C`).
  ///
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES(2),

  /// Track lines that have been copied from another file that exists
  /// in the same commit (like `git blame -CC`).  Implies SAME_FILE.
  ///
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES(4),

  /// Track lines that have been copied from another file that exists in
  /// *any* commit (like `git blame -CCC`).  Implies SAME_COMMIT_COPIES.
  ///
  /// This is not yet implemented and reserved for future use.
  GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES(8),

  /// Restrict the search of commits to those reachable following only
  /// the first parents.
  GIT_BLAME_FIRST_PARENT(16),

  /// Use mailmap file to map author and committer names and email
  /// addresses to canonical real names and email addresses. The
  /// mailmap will be read from the working directory, or HEAD in a
  /// bare repository.
  GIT_BLAME_USE_MAILMAP(32),

  /// Ignore whitespace differences
  GIT_BLAME_IGNORE_WHITESPACE(64);

  final int value;
  const git_blame_flag_t(this.value);

  static git_blame_flag_t fromValue(int value) => switch (value) {
        0 => GIT_BLAME_NORMAL,
        1 => GIT_BLAME_TRACK_COPIES_SAME_FILE,
        2 => GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES,
        4 => GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES,
        8 => GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES,
        16 => GIT_BLAME_FIRST_PARENT,
        32 => GIT_BLAME_USE_MAILMAP,
        64 => GIT_BLAME_IGNORE_WHITESPACE,
        _ => throw ArgumentError('Unknown value for git_blame_flag_t: $value'),
      };
}

/// Blame options structure
///
/// Initialize with `GIT_BLAME_OPTIONS_INIT`. Alternatively, you can
/// use `git_blame_options_init`.
final class git_blame_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_blame_flag_t`
  @ffi.UnsignedInt()
  external int flags;

  /// The lower bound on the number of alphanumeric characters that
  /// must be detected as moving/copying within a file for it to
  /// associate those lines with the parent commit. The default value
  /// is 20.
  ///
  /// This value only takes effect if any of the `GIT_BLAME_TRACK_COPIES_*`
  /// flags are specified.
  @ffi.Uint16()
  external int min_match_characters;

  /// The id of the newest commit to consider. The default is HEAD.
  external git_oid newest_commit;

  /// The id of the oldest commit to consider.
  /// The default is the first commit encountered with a NULL parent.
  external git_oid oldest_commit;

  /// The first line in the file to blame.
  /// The default is 1 (line numbers start with 1).
  @ffi.Size()
  external int min_line;

  /// The last line in the file to blame.
  /// The default is the last line of the file.
  @ffi.Size()
  external int max_line;
}

/// Structure that represents a blame hunk.
final class git_blame_hunk extends ffi.Struct {
  /// The number of lines in this hunk.
  @ffi.Size()
  external int lines_in_hunk;

  /// The OID of the commit where this line was last changed.
  external git_oid final_commit_id;

  /// The 1-based line number where this hunk begins, in the final version
  /// of the file.
  @ffi.Size()
  external int final_start_line_number;

  /// The author of `final_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been
  /// specified, it will contain the canonical real name and email address.
  external ffi.Pointer<git_signature> final_signature;

  /// The committer of `final_commit_id`. If `GIT_BLAME_USE_MAILMAP` has
  /// been specified, it will contain the canonical real name and email
  /// address.
  external ffi.Pointer<git_signature> final_committer;

  /// The OID of the commit where this hunk was found.
  /// This will usually be the same as `final_commit_id`, except when
  /// `GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES` has been specified.
  external git_oid orig_commit_id;

  /// The path to the file where this hunk originated, as of the commit
  /// specified by `orig_commit_id`.
  external ffi.Pointer<ffi.Char> orig_path;

  /// The 1-based line number where this hunk begins in the file named by
  /// `orig_path` in the commit specified by `orig_commit_id`.
  @ffi.Size()
  external int orig_start_line_number;

  /// The author of `orig_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been
  /// specified, it will contain the canonical real name and email address.
  external ffi.Pointer<git_signature> orig_signature;

  /// The committer of `orig_commit_id`. If `GIT_BLAME_USE_MAILMAP` has
  /// been specified, it will contain the canonical real name and email
  /// address.
  external ffi.Pointer<git_signature> orig_committer;

  /// The summary of the commit.
  external ffi.Pointer<ffi.Char> summary;

  /// The 1 iff the hunk has been tracked to a boundary commit (the root,
  /// or the commit specified in git_blame_options.oldest_commit)
  @ffi.Char()
  external int boundary;
}

/// Structure that represents a line in a blamed file.
final class git_blame_line extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ptr;

  @ffi.Size()
  external int len;
}

final class git_blame extends ffi.Opaque {}

final class git_branch_iterator extends ffi.Opaque {}

/// Type of SSH host fingerprint
enum git_cert_ssh_t {
  /// MD5 is available
  GIT_CERT_SSH_MD5(1),

  /// SHA-1 is available
  GIT_CERT_SSH_SHA1(2),

  /// SHA-256 is available
  GIT_CERT_SSH_SHA256(4),

  /// Raw hostkey is available
  GIT_CERT_SSH_RAW(8);

  final int value;
  const git_cert_ssh_t(this.value);

  static git_cert_ssh_t fromValue(int value) => switch (value) {
        1 => GIT_CERT_SSH_MD5,
        2 => GIT_CERT_SSH_SHA1,
        4 => GIT_CERT_SSH_SHA256,
        8 => GIT_CERT_SSH_RAW,
        _ => throw ArgumentError('Unknown value for git_cert_ssh_t: $value'),
      };
}

enum git_cert_ssh_raw_type_t {
  /// The raw key is of an unknown type.
  GIT_CERT_SSH_RAW_TYPE_UNKNOWN(0),

  /// The raw key is an RSA key.
  GIT_CERT_SSH_RAW_TYPE_RSA(1),

  /// The raw key is a DSS key.
  GIT_CERT_SSH_RAW_TYPE_DSS(2),

  /// The raw key is a ECDSA 256 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256(3),

  /// The raw key is a ECDSA 384 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384(4),

  /// The raw key is a ECDSA 521 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521(5),

  /// The raw key is a ED25519 key.
  GIT_CERT_SSH_RAW_TYPE_KEY_ED25519(6);

  final int value;
  const git_cert_ssh_raw_type_t(this.value);

  static git_cert_ssh_raw_type_t fromValue(int value) => switch (value) {
        0 => GIT_CERT_SSH_RAW_TYPE_UNKNOWN,
        1 => GIT_CERT_SSH_RAW_TYPE_RSA,
        2 => GIT_CERT_SSH_RAW_TYPE_DSS,
        3 => GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256,
        4 => GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384,
        5 => GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521,
        6 => GIT_CERT_SSH_RAW_TYPE_KEY_ED25519,
        _ => throw ArgumentError(
            'Unknown value for git_cert_ssh_raw_type_t: $value'),
      };
}

/// Hostkey information taken from libssh2
final class git_cert_hostkey extends ffi.Struct {
  /// < The parent cert
  external git_cert parent;

  /// A bitmask containing the available fields.
  @ffi.UnsignedInt()
  external int typeAsInt;

  git_cert_ssh_t get type => git_cert_ssh_t.fromValue(typeAsInt);

  /// Hostkey hash. If `type` has `GIT_CERT_SSH_MD5` set, this will
  /// have the MD5 hash of the hostkey.
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> hash_md5;

  /// Hostkey hash. If `type` has `GIT_CERT_SSH_SHA1` set, this will
  /// have the SHA-1 hash of the hostkey.
  @ffi.Array.multi([20])
  external ffi.Array<ffi.UnsignedChar> hash_sha1;

  /// Hostkey hash. If `type` has `GIT_CERT_SSH_SHA256` set, this will
  /// have the SHA-256 hash of the hostkey.
  @ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedChar> hash_sha256;

  /// Raw hostkey type. If `type` has `GIT_CERT_SSH_RAW` set, this will
  /// have the type of the raw hostkey.
  @ffi.UnsignedInt()
  external int raw_typeAsInt;

  git_cert_ssh_raw_type_t get raw_type =>
      git_cert_ssh_raw_type_t.fromValue(raw_typeAsInt);

  /// Pointer to the raw hostkey. If `type` has `GIT_CERT_SSH_RAW` set,
  /// this will have the raw contents of the hostkey.
  external ffi.Pointer<ffi.Char> hostkey;

  /// Raw hostkey length. If `type` has `GIT_CERT_SSH_RAW` set, this will
  /// have the length of the raw contents of the hostkey.
  @ffi.Size()
  external int hostkey_len;
}

/// X.509 certificate information
final class git_cert_x509 extends ffi.Struct {
  /// < The parent cert
  external git_cert parent;

  /// Pointer to the X.509 certificate data
  external ffi.Pointer<ffi.Void> data;

  /// Length of the memory block pointed to by `data`.
  @ffi.Size()
  external int len;
}

/// Checkout behavior flags
///
/// In libgit2, checkout is used to update the working directory and index
/// to match a target tree.  Unlike git checkout, it does not move the HEAD
/// commit for you - use `git_repository_set_head` or the like to do that.
///
/// Checkout looks at (up to) four things: the "target" tree you want to
/// check out, the "baseline" tree of what was checked out previously, the
/// working directory for actual files, and the index for staged changes.
///
/// You give checkout one of two strategies for update:
///
/// - `GIT_CHECKOUT_SAFE` is the default, and similar to git's default,
/// which will make modifications that will not lose changes in the
/// working directory.
///
/// |  target == baseline   |  target != baseline  |
/// ---------------------|-----------------------|----------------------|
/// workdir == baseline |       no action       |  create, update, or  |
/// |                       |     delete file      |
/// ---------------------|-----------------------|----------------------|
/// workdir exists and  |       no action       |   conflict (notify   |
/// is != baseline    | notify dirty MODIFIED | and cancel checkout) |
/// ---------------------|-----------------------|----------------------|
/// workdir missing,   | notify dirty DELETED  |     create file      |
/// baseline present   |                       |                      |
/// ---------------------|-----------------------|----------------------|
///
/// - `GIT_CHECKOUT_FORCE` will take any action to make the working
/// directory match the target (including potentially discarding
/// modified files).
///
/// To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
/// notification callback (see below) that displays information about dirty
/// files.  The default behavior will cancel checkout on conflicts.
///
/// To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
/// notification callback that cancels the operation if a dirty-but-existing
/// file is found in the working directory.  This core git command isn't
/// quite "force" but is sensitive about some types of changes.
///
/// To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.
///
///
/// There are some additional flags to modify the behavior of checkout:
///
/// - `GIT_CHECKOUT_DRY_RUN` is a dry-run strategy that checks for conflicts,
/// etc., but doesn't make any actual changes.
///
/// - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
/// even if there are conflicts (instead of cancelling the checkout).
///
/// - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
/// in target, baseline, or index, and not ignored) from the working dir.
///
/// - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
/// untracked) from the working directory as well.
///
/// - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
/// already exist.  Files will not be created nor deleted.  This just skips
/// applying adds, deletes, and typechanges.
///
/// - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
/// updated files' information to the index.
///
/// - Normally, checkout will reload the index and git attributes from disk
/// before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.
///
/// - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
/// files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
/// GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
/// stage 2 ("ours") or stage 3 ("theirs") version of files in the index.
///
/// - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
/// overwritten.  Normally, files that are ignored in the working directory
/// are not considered "precious" and may be overwritten if the checkout
/// target contains that file.
///
/// - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
/// files or folders that fold to the same name on case insensitive
/// filesystems.  This can cause files to retain their existing names
/// and write through existing symbolic links.
///
/// @flags
enum git_checkout_strategy_t {
  /// Allow safe updates that cannot overwrite uncommitted data.
  /// If the uncommitted changes don't conflict with the checked
  /// out files, the checkout will still proceed, leaving the
  /// changes intact.
  GIT_CHECKOUT_SAFE(0),

  /// Allow all updates to force working directory to look like
  /// the index, potentially losing data in the process.
  GIT_CHECKOUT_FORCE(2),

  /// Allow checkout to recreate missing files
  GIT_CHECKOUT_RECREATE_MISSING(4),

  /// Allow checkout to make safe updates even if conflicts are found
  GIT_CHECKOUT_ALLOW_CONFLICTS(16),

  /// Remove untracked files not in index (that are not ignored)
  GIT_CHECKOUT_REMOVE_UNTRACKED(32),

  /// Remove ignored files not in index
  GIT_CHECKOUT_REMOVE_IGNORED(64),

  /// Only update existing files, don't create new ones
  GIT_CHECKOUT_UPDATE_ONLY(128),

  /// Normally checkout updates index entries as it goes; this stops that.
  /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
  GIT_CHECKOUT_DONT_UPDATE_INDEX(256),

  /// Don't refresh index/config/etc before doing checkout
  GIT_CHECKOUT_NO_REFRESH(512),

  /// Allow checkout to skip unmerged files
  GIT_CHECKOUT_SKIP_UNMERGED(1024),

  /// For unmerged files, checkout stage 2 from index
  GIT_CHECKOUT_USE_OURS(2048),

  /// For unmerged files, checkout stage 3 from index
  GIT_CHECKOUT_USE_THEIRS(4096),

  /// Treat pathspec as simple list of exact match file paths
  GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH(8192),

  /// Ignore directories in use, they will be left empty
  GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES(262144),

  /// Don't overwrite ignored files that exist in the checkout target
  GIT_CHECKOUT_DONT_OVERWRITE_IGNORED(524288),

  /// Write normal merge files for conflicts
  GIT_CHECKOUT_CONFLICT_STYLE_MERGE(1048576),

  /// Include common ancestor data in diff3 format files for conflicts
  GIT_CHECKOUT_CONFLICT_STYLE_DIFF3(2097152),

  /// Don't overwrite existing files or folders
  GIT_CHECKOUT_DONT_REMOVE_EXISTING(4194304),

  /// Normally checkout writes the index upon completion; this prevents that.
  GIT_CHECKOUT_DONT_WRITE_INDEX(8388608),

  /// Perform a "dry run", reporting what _would_ be done but
  /// without actually making changes in the working directory
  /// or the index.
  GIT_CHECKOUT_DRY_RUN(16777216),

  /// Include common ancestor data in zdiff3 format for conflicts
  GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3(33554432),

  /// Do not do a checkout and do not fire callbacks; this is primarily
  /// useful only for internal functions that will perform the
  /// checkout themselves but need to pass checkout options into
  /// another function, for example, `git_clone`.
  GIT_CHECKOUT_NONE(1073741824),

  /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
  GIT_CHECKOUT_UPDATE_SUBMODULES(65536),

  /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
  GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED(131072);

  final int value;
  const git_checkout_strategy_t(this.value);

  static git_checkout_strategy_t fromValue(int value) => switch (value) {
        0 => GIT_CHECKOUT_SAFE,
        2 => GIT_CHECKOUT_FORCE,
        4 => GIT_CHECKOUT_RECREATE_MISSING,
        16 => GIT_CHECKOUT_ALLOW_CONFLICTS,
        32 => GIT_CHECKOUT_REMOVE_UNTRACKED,
        64 => GIT_CHECKOUT_REMOVE_IGNORED,
        128 => GIT_CHECKOUT_UPDATE_ONLY,
        256 => GIT_CHECKOUT_DONT_UPDATE_INDEX,
        512 => GIT_CHECKOUT_NO_REFRESH,
        1024 => GIT_CHECKOUT_SKIP_UNMERGED,
        2048 => GIT_CHECKOUT_USE_OURS,
        4096 => GIT_CHECKOUT_USE_THEIRS,
        8192 => GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH,
        262144 => GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES,
        524288 => GIT_CHECKOUT_DONT_OVERWRITE_IGNORED,
        1048576 => GIT_CHECKOUT_CONFLICT_STYLE_MERGE,
        2097152 => GIT_CHECKOUT_CONFLICT_STYLE_DIFF3,
        4194304 => GIT_CHECKOUT_DONT_REMOVE_EXISTING,
        8388608 => GIT_CHECKOUT_DONT_WRITE_INDEX,
        16777216 => GIT_CHECKOUT_DRY_RUN,
        33554432 => GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3,
        1073741824 => GIT_CHECKOUT_NONE,
        65536 => GIT_CHECKOUT_UPDATE_SUBMODULES,
        131072 => GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED,
        _ => throw ArgumentError(
            'Unknown value for git_checkout_strategy_t: $value'),
      };
}

/// Checkout notification flags
///
/// Checkout will invoke an options notification callback (`notify_cb`) for
/// certain cases - you pick which ones via `notify_flags`:
///
/// Returning a non-zero value from this callback will cancel the checkout.
/// The non-zero return value will be propagated back and returned by the
/// git_checkout_... call.
///
/// Notification callbacks are made prior to modifying any files on disk,
/// so canceling on any notification will still happen prior to any files
/// being modified.
///
/// @flags
enum git_checkout_notify_t {
  GIT_CHECKOUT_NOTIFY_NONE(0),

  /// Invokes checkout on conflicting paths.
  GIT_CHECKOUT_NOTIFY_CONFLICT(1),

  /// Notifies about "dirty" files, i.e. those that do not need an update
  /// but no longer match the baseline.  Core git displays these files when
  /// checkout runs, but won't stop the checkout.
  GIT_CHECKOUT_NOTIFY_DIRTY(2),

  /// Sends notification for any file changed.
  GIT_CHECKOUT_NOTIFY_UPDATED(4),

  /// Notifies about untracked files.
  GIT_CHECKOUT_NOTIFY_UNTRACKED(8),

  /// Notifies about ignored files.
  GIT_CHECKOUT_NOTIFY_IGNORED(16),
  GIT_CHECKOUT_NOTIFY_ALL(65535);

  final int value;
  const git_checkout_notify_t(this.value);

  static git_checkout_notify_t fromValue(int value) => switch (value) {
        0 => GIT_CHECKOUT_NOTIFY_NONE,
        1 => GIT_CHECKOUT_NOTIFY_CONFLICT,
        2 => GIT_CHECKOUT_NOTIFY_DIRTY,
        4 => GIT_CHECKOUT_NOTIFY_UPDATED,
        8 => GIT_CHECKOUT_NOTIFY_UNTRACKED,
        16 => GIT_CHECKOUT_NOTIFY_IGNORED,
        65535 => GIT_CHECKOUT_NOTIFY_ALL,
        _ => throw ArgumentError(
            'Unknown value for git_checkout_notify_t: $value'),
      };
}

/// Checkout performance-reporting structure
final class git_checkout_perfdata extends ffi.Struct {
  @ffi.Size()
  external int mkdir_calls;

  @ffi.Size()
  external int stat_calls;

  @ffi.Size()
  external int chmod_calls;
}

typedef git_checkout_notify_cbFunction = ffi.Int Function(
    ffi.UnsignedInt why,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_diff_file> baseline,
    ffi.Pointer<git_diff_file> target,
    ffi.Pointer<git_diff_file> workdir,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_checkout_notify_cbFunction = int Function(
    git_checkout_notify_t why,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_diff_file> baseline,
    ffi.Pointer<git_diff_file> target,
    ffi.Pointer<git_diff_file> workdir,
    ffi.Pointer<ffi.Void> payload);

/// Checkout notification callback function.
///
/// @param why the notification reason
/// @param path the path to the file being checked out
/// @param baseline the baseline's diff file information
/// @param target the checkout target diff file information
/// @param workdir the working directory diff file information
/// @param payload the user-supplied callback payload
/// @return 0 on success, or an error code
typedef git_checkout_notify_cb
    = ffi.Pointer<ffi.NativeFunction<git_checkout_notify_cbFunction>>;
typedef git_checkout_progress_cbFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> path,
    ffi.Size completed_steps,
    ffi.Size total_steps,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_checkout_progress_cbFunction = void Function(
    ffi.Pointer<ffi.Char> path,
    int completed_steps,
    int total_steps,
    ffi.Pointer<ffi.Void> payload);

/// Checkout progress notification function.
///
/// @param path the path to the file being checked out
/// @param completed_steps number of checkout steps completed
/// @param total_steps number of total steps in the checkout process
/// @param payload the user-supplied callback payload
typedef git_checkout_progress_cb
    = ffi.Pointer<ffi.NativeFunction<git_checkout_progress_cbFunction>>;
typedef git_checkout_perfdata_cbFunction = ffi.Void Function(
    ffi.Pointer<git_checkout_perfdata> perfdata, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_checkout_perfdata_cbFunction = void Function(
    ffi.Pointer<git_checkout_perfdata> perfdata, ffi.Pointer<ffi.Void> payload);

/// Checkout performance data reporting function.
///
/// @param perfdata the performance data for the checkout
/// @param payload the user-supplied callback payload
typedef git_checkout_perfdata_cb
    = ffi.Pointer<ffi.NativeFunction<git_checkout_perfdata_cbFunction>>;

/// Checkout options structure
///
/// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
/// use `git_checkout_options_init`.
///
/// @options[version] GIT_CHECKOUT_OPTIONS_VERSION
/// @options[init_macro] GIT_CHECKOUT_OPTIONS_INIT
/// @options[init_function] git_checkout_options_init
final class git_checkout_options extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// < default will be a safe checkout
  @ffi.UnsignedInt()
  external int checkout_strategy;

  /// < don't apply filters like CRLF conversion
  @ffi.Int()
  external int disable_filters;

  /// < default is 0755
  @ffi.UnsignedInt()
  external int dir_mode;

  /// < default is 0644 or 0755 as dictated by blob
  @ffi.UnsignedInt()
  external int file_mode;

  /// < default is O_CREAT | O_TRUNC | O_WRONLY
  @ffi.Int()
  external int file_open_flags;

  /// Checkout notification flags specify what operations the notify
  /// callback is invoked for.
  ///
  /// @type[flags] git_checkout_notify_t
  @ffi.UnsignedInt()
  external int notify_flags;

  /// Optional callback to get notifications on specific file states.
  /// @see git_checkout_notify_t
  external git_checkout_notify_cb notify_cb;

  /// Payload passed to notify_cb
  external ffi.Pointer<ffi.Void> notify_payload;

  /// Optional callback to notify the consumer of checkout progress.
  external git_checkout_progress_cb progress_cb;

  /// Payload passed to progress_cb
  external ffi.Pointer<ffi.Void> progress_payload;

  /// A list of wildmatch patterns or paths.
  ///
  /// By default, all paths are processed. If you pass an array of wildmatch
  /// patterns, those will be used to filter which paths should be taken into
  /// account.
  ///
  /// Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
  external git_strarray paths;

  /// The expected content of the working directory; defaults to HEAD.
  ///
  /// If the working directory does not match this baseline information,
  /// that will produce a checkout conflict.
  external ffi.Pointer<git_tree> baseline;

  /// Like `baseline` above, though expressed as an index.  This
  /// option overrides `baseline`.
  external ffi.Pointer<git_index> baseline_index;

  /// < alternative checkout path to workdir
  external ffi.Pointer<ffi.Char> target_directory;

  /// < the name of the common ancestor side of conflicts
  external ffi.Pointer<ffi.Char> ancestor_label;

  /// < the name of the "our" side of conflicts
  external ffi.Pointer<ffi.Char> our_label;

  /// < the name of the "their" side of conflicts
  external ffi.Pointer<ffi.Char> their_label;

  /// Optional callback to notify the consumer of performance data.
  external git_checkout_perfdata_cb perfdata_cb;

  /// Payload passed to perfdata_cb
  external ffi.Pointer<ffi.Void> perfdata_payload;
}

/// Time structure used in a git index entry
final class git_index_time extends ffi.Struct {
  @ffi.Int32()
  external int seconds;

  /// nsec should not be stored as time_t compatible
  @ffi.Uint32()
  external int nanoseconds;
}

/// In-memory representation of a file entry in the index.
///
/// This is a public structure that represents a file entry in the index.
/// The meaning of the fields corresponds to core Git's documentation (in
/// "Documentation/technical/index-format.txt").
///
/// The `flags` field consists of a number of bit fields which can be
/// accessed via the first set of `GIT_INDEX_ENTRY_...` bitmasks below.
/// These flags are all read from and persisted to disk.
///
/// The `flags_extended` field also has a number of bit fields which can be
/// accessed via the later `GIT_INDEX_ENTRY_...` bitmasks below.  Some of
/// these flags are read from and written to disk, but some are set aside
/// for in-memory only reference.
///
/// Note that the time and size fields are truncated to 32 bits. This
/// is enough to detect changes, which is enough for the index to
/// function as a cache, but it should not be taken as an authoritative
/// source for that data.
final class git_index_entry extends ffi.Struct {
  external git_index_time ctime;

  external git_index_time mtime;

  @ffi.Uint32()
  external int dev;

  @ffi.Uint32()
  external int ino;

  @ffi.Uint32()
  external int mode;

  @ffi.Uint32()
  external int uid;

  @ffi.Uint32()
  external int gid;

  @ffi.Uint32()
  external int file_size;

  external git_oid id;

  @ffi.Uint16()
  external int flags;

  @ffi.Uint16()
  external int flags_extended;

  external ffi.Pointer<ffi.Char> path;
}

/// Flags for index entries
enum git_index_entry_flag_t {
  GIT_INDEX_ENTRY_EXTENDED(16384),
  GIT_INDEX_ENTRY_VALID(32768);

  final int value;
  const git_index_entry_flag_t(this.value);

  static git_index_entry_flag_t fromValue(int value) => switch (value) {
        16384 => GIT_INDEX_ENTRY_EXTENDED,
        32768 => GIT_INDEX_ENTRY_VALID,
        _ => throw ArgumentError(
            'Unknown value for git_index_entry_flag_t: $value'),
      };
}

/// Bitmasks for on-disk fields of `git_index_entry`'s `flags_extended`
///
/// In memory, the `flags_extended` fields are divided into two parts: the
/// fields that are read from and written to disk, and other fields that
/// in-memory only and used by libgit2.  Only the flags in
/// `GIT_INDEX_ENTRY_EXTENDED_FLAGS` will get saved on-disk.
///
/// Thee first three bitmasks match the three fields in the
/// `git_index_entry` `flags_extended` value that belong on disk.  You
/// can use them to interpret the data in the `flags_extended`.
///
/// The rest of the bitmasks match the other fields in the `git_index_entry`
/// `flags_extended` value that are only used in-memory by libgit2.
/// You can use them to interpret the data in the `flags_extended`.
enum git_index_entry_extended_flag_t {
  GIT_INDEX_ENTRY_INTENT_TO_ADD(8192),
  GIT_INDEX_ENTRY_SKIP_WORKTREE(16384),
  GIT_INDEX_ENTRY_EXTENDED_FLAGS(24576),
  GIT_INDEX_ENTRY_UPTODATE(4);

  final int value;
  const git_index_entry_extended_flag_t(this.value);

  static git_index_entry_extended_flag_t fromValue(int value) =>
      switch (value) {
        8192 => GIT_INDEX_ENTRY_INTENT_TO_ADD,
        16384 => GIT_INDEX_ENTRY_SKIP_WORKTREE,
        24576 => GIT_INDEX_ENTRY_EXTENDED_FLAGS,
        4 => GIT_INDEX_ENTRY_UPTODATE,
        _ => throw ArgumentError(
            'Unknown value for git_index_entry_extended_flag_t: $value'),
      };
}

/// Capabilities of system that affect index actions.
enum git_index_capability_t {
  GIT_INDEX_CAPABILITY_IGNORE_CASE(1),
  GIT_INDEX_CAPABILITY_NO_FILEMODE(2),
  GIT_INDEX_CAPABILITY_NO_SYMLINKS(4),
  GIT_INDEX_CAPABILITY_FROM_OWNER(-1);

  final int value;
  const git_index_capability_t(this.value);

  static git_index_capability_t fromValue(int value) => switch (value) {
        1 => GIT_INDEX_CAPABILITY_IGNORE_CASE,
        2 => GIT_INDEX_CAPABILITY_NO_FILEMODE,
        4 => GIT_INDEX_CAPABILITY_NO_SYMLINKS,
        -1 => GIT_INDEX_CAPABILITY_FROM_OWNER,
        _ => throw ArgumentError(
            'Unknown value for git_index_capability_t: $value'),
      };
}

typedef git_index_matched_path_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> matched_pathspec,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_index_matched_path_cbFunction = int Function(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> matched_pathspec,
    ffi.Pointer<ffi.Void> payload);

/// Callback for APIs that add/remove/update files matching pathspec
///
/// @param path the path
/// @param matched_pathspec the given pathspec
/// @param payload the user-specified payload
/// @return 0 to continue with the index operation, positive number to         skip this file for the index operation, negative number on failure
typedef git_index_matched_path_cb
    = ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cbFunction>>;

/// Flags for APIs that add files matching pathspec
enum git_index_add_option_t {
  GIT_INDEX_ADD_DEFAULT(0),
  GIT_INDEX_ADD_FORCE(1),
  GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH(2),
  GIT_INDEX_ADD_CHECK_PATHSPEC(4);

  final int value;
  const git_index_add_option_t(this.value);

  static git_index_add_option_t fromValue(int value) => switch (value) {
        0 => GIT_INDEX_ADD_DEFAULT,
        1 => GIT_INDEX_ADD_FORCE,
        2 => GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH,
        4 => GIT_INDEX_ADD_CHECK_PATHSPEC,
        _ => throw ArgumentError(
            'Unknown value for git_index_add_option_t: $value'),
      };
}

/// Git index stage states
enum git_index_stage_t {
  /// Match any index stage.
  ///
  /// Some index APIs take a stage to match; pass this value to match
  /// any entry matching the path regardless of stage.
  GIT_INDEX_STAGE_ANY(-1),

  /// A normal staged file in the index.
  GIT_INDEX_STAGE_NORMAL(0),

  /// The ancestor side of a conflict.
  GIT_INDEX_STAGE_ANCESTOR(1),

  /// The "ours" side of a conflict.
  GIT_INDEX_STAGE_OURS(2),

  /// The "theirs" side of a conflict.
  GIT_INDEX_STAGE_THEIRS(3);

  final int value;
  const git_index_stage_t(this.value);

  static git_index_stage_t fromValue(int value) => switch (value) {
        -1 => GIT_INDEX_STAGE_ANY,
        0 => GIT_INDEX_STAGE_NORMAL,
        1 => GIT_INDEX_STAGE_ANCESTOR,
        2 => GIT_INDEX_STAGE_OURS,
        3 => GIT_INDEX_STAGE_THEIRS,
        _ => throw ArgumentError('Unknown value for git_index_stage_t: $value'),
      };
}

/// The options for opening or creating an index.
///
/// Initialize with `GIT_INDEX_OPTIONS_INIT`. Alternatively, you can
/// use `git_index_options_init`.
///
/// @options[version] GIT_INDEX_OPTIONS_VERSION
/// @options[init_macro] GIT_INDEX_OPTIONS_INIT
/// @options[init_function] git_index_options_init
final class git_index_options extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// The object ID type for the object IDs that exist in the index.
  ///
  /// If this is not specified, this defaults to `GIT_OID_SHA1`.
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

/// The file inputs to `git_merge_file`.  Callers should populate the
/// `git_merge_file_input` structure with descriptions of the files in
/// each side of the conflict for use in producing the merge file.
final class git_merge_file_input extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Pointer to the contents of the file.
  external ffi.Pointer<ffi.Char> ptr;

  /// Size of the contents pointed to in `ptr`.
  @ffi.Size()
  external int size;

  /// File name of the conflicted file, or `NULL` to not merge the path.
  external ffi.Pointer<ffi.Char> path;

  /// File mode of the conflicted file, or `0` to not merge the mode.
  @ffi.UnsignedInt()
  external int mode;
}

/// Flags for `git_merge` options.  A combination of these flags can be
/// passed in via the `flags` value in the `git_merge_options`.
enum git_merge_flag_t {
  /// Detect renames that occur between the common ancestor and the "ours"
  /// side or the common ancestor and the "theirs" side.  This will enable
  /// the ability to merge between a modified and renamed file.
  GIT_MERGE_FIND_RENAMES(1),

  /// If a conflict occurs, exit immediately instead of attempting to
  /// continue resolving conflicts.  The merge operation will fail with
  /// GIT_EMERGECONFLICT and no index will be returned.
  GIT_MERGE_FAIL_ON_CONFLICT(2),

  /// Do not write the REUC extension on the generated index
  GIT_MERGE_SKIP_REUC(4),

  /// If the commits being merged have multiple merge bases, do not build
  /// a recursive merge base (by merging the multiple merge bases),
  /// instead simply use the first base.  This flag provides a similar
  /// merge base to `git-merge-resolve`.
  GIT_MERGE_NO_RECURSIVE(8),

  /// Treat this merge as if it is to produce the virtual base
  /// of a recursive merge.  This will ensure that there are
  /// no conflicts, any conflicting regions will keep conflict
  /// markers in the merge result.
  GIT_MERGE_VIRTUAL_BASE(16);

  final int value;
  const git_merge_flag_t(this.value);

  static git_merge_flag_t fromValue(int value) => switch (value) {
        1 => GIT_MERGE_FIND_RENAMES,
        2 => GIT_MERGE_FAIL_ON_CONFLICT,
        4 => GIT_MERGE_SKIP_REUC,
        8 => GIT_MERGE_NO_RECURSIVE,
        16 => GIT_MERGE_VIRTUAL_BASE,
        _ => throw ArgumentError('Unknown value for git_merge_flag_t: $value'),
      };
}

/// Merge file favor options for `git_merge_options` instruct the file-level
/// merging functionality how to deal with conflicting regions of the files.
enum git_merge_file_favor_t {
  /// When a region of a file is changed in both branches, a conflict
  /// will be recorded in the index so that `git_checkout` can produce
  /// a merge file with conflict markers in the working directory.
  /// This is the default.
  GIT_MERGE_FILE_FAVOR_NORMAL(0),

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "ours" side of any conflicting
  /// region.  The index will not record a conflict.
  GIT_MERGE_FILE_FAVOR_OURS(1),

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "theirs" side of any conflicting
  /// region.  The index will not record a conflict.
  GIT_MERGE_FILE_FAVOR_THEIRS(2),

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain each unique line from each side,
  /// which has the result of combining both files.  The index will not
  /// record a conflict.
  GIT_MERGE_FILE_FAVOR_UNION(3);

  final int value;
  const git_merge_file_favor_t(this.value);

  static git_merge_file_favor_t fromValue(int value) => switch (value) {
        0 => GIT_MERGE_FILE_FAVOR_NORMAL,
        1 => GIT_MERGE_FILE_FAVOR_OURS,
        2 => GIT_MERGE_FILE_FAVOR_THEIRS,
        3 => GIT_MERGE_FILE_FAVOR_UNION,
        _ => throw ArgumentError(
            'Unknown value for git_merge_file_favor_t: $value'),
      };
}

/// File merging flags
enum git_merge_file_flag_t {
  /// Defaults
  GIT_MERGE_FILE_DEFAULT(0),

  /// Create standard conflicted merge files
  GIT_MERGE_FILE_STYLE_MERGE(1),

  /// Create diff3-style files
  GIT_MERGE_FILE_STYLE_DIFF3(2),

  /// Condense non-alphanumeric regions for simplified diff file
  GIT_MERGE_FILE_SIMPLIFY_ALNUM(4),

  /// Ignore all whitespace
  GIT_MERGE_FILE_IGNORE_WHITESPACE(8),

  /// Ignore changes in amount of whitespace
  GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE(16),

  /// Ignore whitespace at end of line
  GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL(32),

  /// Use the "patience diff" algorithm
  GIT_MERGE_FILE_DIFF_PATIENCE(64),

  /// Take extra time to find minimal diff
  GIT_MERGE_FILE_DIFF_MINIMAL(128),

  /// Create zdiff3 ("zealous diff3")-style files
  GIT_MERGE_FILE_STYLE_ZDIFF3(256),

  /// Do not produce file conflicts when common regions have
  /// changed; keep the conflict markers in the file and accept
  /// that as the merge result.
  GIT_MERGE_FILE_ACCEPT_CONFLICTS(512);

  final int value;
  const git_merge_file_flag_t(this.value);

  static git_merge_file_flag_t fromValue(int value) => switch (value) {
        0 => GIT_MERGE_FILE_DEFAULT,
        1 => GIT_MERGE_FILE_STYLE_MERGE,
        2 => GIT_MERGE_FILE_STYLE_DIFF3,
        4 => GIT_MERGE_FILE_SIMPLIFY_ALNUM,
        8 => GIT_MERGE_FILE_IGNORE_WHITESPACE,
        16 => GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE,
        32 => GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL,
        64 => GIT_MERGE_FILE_DIFF_PATIENCE,
        128 => GIT_MERGE_FILE_DIFF_MINIMAL,
        256 => GIT_MERGE_FILE_STYLE_ZDIFF3,
        512 => GIT_MERGE_FILE_ACCEPT_CONFLICTS,
        _ => throw ArgumentError(
            'Unknown value for git_merge_file_flag_t: $value'),
      };
}

/// Options for merging a file
final class git_merge_file_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Label for the ancestor file side of the conflict which will be prepended
  /// to labels in diff3-format merge files.
  external ffi.Pointer<ffi.Char> ancestor_label;

  /// Label for our file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Char> our_label;

  /// Label for their file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Char> their_label;

  /// The file to favor in region conflicts.
  @ffi.UnsignedInt()
  external int favorAsInt;

  git_merge_file_favor_t get favor =>
      git_merge_file_favor_t.fromValue(favorAsInt);

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// The size of conflict markers (eg, "<<<<<<<").  Default is
  /// GIT_MERGE_CONFLICT_MARKER_SIZE.
  @ffi.UnsignedShort()
  external int marker_size;
}

/// Information about file-level merging
final class git_merge_file_result extends ffi.Struct {
  /// True if the output was automerged, false if the output contains
  /// conflict markers.
  @ffi.UnsignedInt()
  external int automergeable;

  /// The path that the resultant merge file should use, or NULL if a
  /// filename conflict would occur.
  external ffi.Pointer<ffi.Char> path;

  /// The mode that the resultant merge file should use.
  @ffi.UnsignedInt()
  external int mode;

  /// The contents of the merge.
  external ffi.Pointer<ffi.Char> ptr;

  /// The length of the merge contents.
  @ffi.Size()
  external int len;
}

/// Merging options
final class git_merge_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// See `git_merge_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// Similarity to consider a file renamed (default 50).  If
  /// `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
  /// with deleted files to determine their similarity.  Files that are
  /// more similar than the rename threshold (percentage-wise) will be
  /// treated as a rename.
  @ffi.UnsignedInt()
  external int rename_threshold;

  /// Maximum similarity sources to examine for renames (default 200).
  /// If the number of rename candidates (add / delete pairs) is greater
  /// than this value, inexact rename detection is aborted.
  ///
  /// This setting overrides the `merge.renameLimit` configuration value.
  @ffi.UnsignedInt()
  external int target_limit;

  /// Pluggable similarity metric; pass NULL to use internal metric
  external ffi.Pointer<git_diff_similarity_metric> metric;

  /// Maximum number of times to merge common ancestors to build a
  /// virtual merge base when faced with criss-cross merges.  When this
  /// limit is reached, the next ancestor will simply be used instead of
  /// attempting to merge it.  The default is unlimited.
  @ffi.UnsignedInt()
  external int recursion_limit;

  /// Default merge driver to be used when both sides of a merge have
  /// changed.  The default is the `text` driver.
  external ffi.Pointer<ffi.Char> default_driver;

  /// Flags for handling conflicting content, to be used with the standard
  /// (`text`) merge driver.
  @ffi.UnsignedInt()
  external int file_favorAsInt;

  git_merge_file_favor_t get file_favor =>
      git_merge_file_favor_t.fromValue(file_favorAsInt);

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int file_flags;
}

/// The results of `git_merge_analysis` indicate the merge opportunities.
enum git_merge_analysis_t {
  /// No merge is possible.  (Unused.)
  GIT_MERGE_ANALYSIS_NONE(0),

  /// A "normal" merge; both HEAD and the given merge input have diverged
  /// from their common ancestor.  The divergent commits must be merged.
  GIT_MERGE_ANALYSIS_NORMAL(1),

  /// All given merge inputs are reachable from HEAD, meaning the
  /// repository is up-to-date and no merge needs to be performed.
  GIT_MERGE_ANALYSIS_UP_TO_DATE(2),

  /// The given merge input is a fast-forward from HEAD and no merge
  /// needs to be performed.  Instead, the client can check out the
  /// given merge input.
  GIT_MERGE_ANALYSIS_FASTFORWARD(4),

  /// The HEAD of the current repository is "unborn" and does not point to
  /// a valid commit.  No merge can be performed, but the caller may wish
  /// to simply set HEAD to the target commit(s).
  GIT_MERGE_ANALYSIS_UNBORN(8);

  final int value;
  const git_merge_analysis_t(this.value);

  static git_merge_analysis_t fromValue(int value) => switch (value) {
        0 => GIT_MERGE_ANALYSIS_NONE,
        1 => GIT_MERGE_ANALYSIS_NORMAL,
        2 => GIT_MERGE_ANALYSIS_UP_TO_DATE,
        4 => GIT_MERGE_ANALYSIS_FASTFORWARD,
        8 => GIT_MERGE_ANALYSIS_UNBORN,
        _ =>
          throw ArgumentError('Unknown value for git_merge_analysis_t: $value'),
      };
}

/// The user's stated preference for merges.
enum git_merge_preference_t {
  /// No configuration was found that suggests a preferred behavior for
  /// merge.
  GIT_MERGE_PREFERENCE_NONE(0),

  /// There is a `merge.ff=false` configuration setting, suggesting that
  /// the user does not want to allow a fast-forward merge.
  GIT_MERGE_PREFERENCE_NO_FASTFORWARD(1),

  /// There is a `merge.ff=only` configuration setting, suggesting that
  /// the user only wants fast-forward merges.
  GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY(2);

  final int value;
  const git_merge_preference_t(this.value);

  static git_merge_preference_t fromValue(int value) => switch (value) {
        0 => GIT_MERGE_PREFERENCE_NONE,
        1 => GIT_MERGE_PREFERENCE_NO_FASTFORWARD,
        2 => GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY,
        _ => throw ArgumentError(
            'Unknown value for git_merge_preference_t: $value'),
      };
}

/// Cherry-pick options
final class git_cherrypick_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.UnsignedInt()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;
}

/// Direction of the connection.
///
/// We need this because we need to know whether we should call
/// git-upload-pack or git-receive-pack on the remote end when get_refs
/// gets called.
enum git_direction {
  GIT_DIRECTION_FETCH(0),
  GIT_DIRECTION_PUSH(1);

  final int value;
  const git_direction(this.value);

  static git_direction fromValue(int value) => switch (value) {
        0 => GIT_DIRECTION_FETCH,
        1 => GIT_DIRECTION_PUSH,
        _ => throw ArgumentError('Unknown value for git_direction: $value'),
      };
}

/// A plaintext username and password
final class git_credential_userpass_plaintext extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The password to use
  external ffi.Pointer<ffi.Char> password;
}

/// Username-only credential information
final class git_credential_username extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> username;
}

/// A key for NTLM/Kerberos "default" credentials
typedef git_credential_default = git_credential;

/// A ssh key from disk
final class git_credential_ssh_key extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The path to a public key
  external ffi.Pointer<ffi.Char> publickey;

  /// < The path to a private key
  external ffi.Pointer<ffi.Char> privatekey;

  /// < Passphrase to decrypt the private key
  external ffi.Pointer<ffi.Char> passphrase;
}

final class _LIBSSH2_USERAUTH_KBDINT_PROMPT extends ffi.Opaque {}

typedef LIBSSH2_USERAUTH_KBDINT_PROMPT = _LIBSSH2_USERAUTH_KBDINT_PROMPT;

final class _LIBSSH2_USERAUTH_KBDINT_RESPONSE extends ffi.Opaque {}

typedef LIBSSH2_USERAUTH_KBDINT_RESPONSE = _LIBSSH2_USERAUTH_KBDINT_RESPONSE;
typedef git_credential_ssh_interactive_cbFunction = ffi.Void Function(
    ffi.Pointer<ffi.Char> name,
    ffi.Int name_len,
    ffi.Pointer<ffi.Char> instruction,
    ffi.Int instruction_len,
    ffi.Int num_prompts,
    ffi.Pointer<LIBSSH2_USERAUTH_KBDINT_PROMPT> prompts,
    ffi.Pointer<LIBSSH2_USERAUTH_KBDINT_RESPONSE> responses,
    ffi.Pointer<ffi.Pointer<ffi.Void>> abstract$);
typedef Dartgit_credential_ssh_interactive_cbFunction = void Function(
    ffi.Pointer<ffi.Char> name,
    int name_len,
    ffi.Pointer<ffi.Char> instruction,
    int instruction_len,
    int num_prompts,
    ffi.Pointer<LIBSSH2_USERAUTH_KBDINT_PROMPT> prompts,
    ffi.Pointer<LIBSSH2_USERAUTH_KBDINT_RESPONSE> responses,
    ffi.Pointer<ffi.Pointer<ffi.Void>> abstract$);

/// Callback for interactive SSH credentials.
///
/// @param name the name
/// @param name_len the length of the name
/// @param instruction the authentication instruction
/// @param instruction_len the length of the instruction
/// @param num_prompts the number of prompts
/// @param prompts the prompts
/// @param responses the responses
/// @param abstract the abstract
typedef git_credential_ssh_interactive_cb = ffi
    .Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cbFunction>>;

/// Keyboard-interactive based ssh authentication
final class git_credential_ssh_interactive extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// Callback used for authentication.
  external git_credential_ssh_interactive_cb prompt_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;
}

final class _LIBSSH2_SESSION extends ffi.Opaque {}

typedef LIBSSH2_SESSION = _LIBSSH2_SESSION;
typedef git_credential_sign_cbFunction = ffi.Int Function(
    ffi.Pointer<LIBSSH2_SESSION> session,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> sig,
    ffi.Pointer<ffi.Size> sig_len,
    ffi.Pointer<ffi.UnsignedChar> data,
    ffi.Size data_len,
    ffi.Pointer<ffi.Pointer<ffi.Void>> abstract$);
typedef Dartgit_credential_sign_cbFunction = int Function(
    ffi.Pointer<LIBSSH2_SESSION> session,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> sig,
    ffi.Pointer<ffi.Size> sig_len,
    ffi.Pointer<ffi.UnsignedChar> data,
    int data_len,
    ffi.Pointer<ffi.Pointer<ffi.Void>> abstract$);

/// Callback for credential signing.
///
/// @param session the libssh2 session
/// @param sig the signature
/// @param sig_len the length of the signature
/// @param data the data
/// @param data_len the length of the data
/// @param abstract the abstract
/// @return 0 for success, < 0 to indicate an error, > 0 to indicate
/// no credential was acquired
typedef git_credential_sign_cb
    = ffi.Pointer<ffi.NativeFunction<git_credential_sign_cbFunction>>;

/// A key with a custom signature function
final class git_credential_ssh_custom extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The public key data
  external ffi.Pointer<ffi.Char> publickey;

  /// < Length of the public key
  @ffi.Size()
  external int publickey_len;

  /// Callback used to sign the data.
  external git_credential_sign_cb sign_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;
}

/// Stages that are reported by the packbuilder progress callback.
enum git_packbuilder_stage_t {
  GIT_PACKBUILDER_ADDING_OBJECTS(0),
  GIT_PACKBUILDER_DELTAFICATION(1);

  final int value;
  const git_packbuilder_stage_t(this.value);

  static git_packbuilder_stage_t fromValue(int value) => switch (value) {
        0 => GIT_PACKBUILDER_ADDING_OBJECTS,
        1 => GIT_PACKBUILDER_DELTAFICATION,
        _ => throw ArgumentError(
            'Unknown value for git_packbuilder_stage_t: $value'),
      };
}

typedef git_packbuilder_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Void> buf, ffi.Size size, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_packbuilder_foreach_cbFunction = int Function(
    ffi.Pointer<ffi.Void> buf, int size, ffi.Pointer<ffi.Void> payload);

/// Callback used to iterate over packed objects
///
/// @see git_packbuilder_foreach
///
/// @param buf A pointer to the object's data
/// @param size The size of the underlying object
/// @param payload Payload passed to git_packbuilder_foreach
/// @return non-zero to terminate the iteration
typedef git_packbuilder_foreach_cb
    = ffi.Pointer<ffi.NativeFunction<git_packbuilder_foreach_cbFunction>>;

/// Remote creation options flags
enum git_remote_create_flags {
  /// Ignore the repository apply.insteadOf configuration
  GIT_REMOTE_CREATE_SKIP_INSTEADOF(1),

  /// Don't build a fetchspec from the name if none is set
  GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC(2);

  final int value;
  const git_remote_create_flags(this.value);

  static git_remote_create_flags fromValue(int value) => switch (value) {
        1 => GIT_REMOTE_CREATE_SKIP_INSTEADOF,
        2 => GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC,
        _ => throw ArgumentError(
            'Unknown value for git_remote_create_flags: $value'),
      };
}

/// How to handle reference updates.
enum git_remote_update_flags {
  /// Write the fetch results to FETCH_HEAD.
  GIT_REMOTE_UPDATE_FETCHHEAD(1),

  /// Report unchanged tips in the update_refs callback.
  GIT_REMOTE_UPDATE_REPORT_UNCHANGED(2);

  final int value;
  const git_remote_update_flags(this.value);

  static git_remote_update_flags fromValue(int value) => switch (value) {
        1 => GIT_REMOTE_UPDATE_FETCHHEAD,
        2 => GIT_REMOTE_UPDATE_REPORT_UNCHANGED,
        _ => throw ArgumentError(
            'Unknown value for git_remote_update_flags: $value'),
      };
}

/// Remote creation options structure
///
/// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_remote_create_options_init`.
final class git_remote_create_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The repository that should own the remote.
  /// Setting this to NULL results in a detached remote.
  external ffi.Pointer<git_repository> repository;

  /// The remote's name.
  /// Setting this to NULL results in an in-memory/anonymous remote.
  external ffi.Pointer<ffi.Char> name;

  /// The fetchspec the remote should use.
  external ffi.Pointer<ffi.Char> fetchspec;

  /// Additional flags for the remote. See git_remote_create_flags.
  @ffi.UnsignedInt()
  external int flags;
}

/// Acceptable prune settings when fetching
enum git_fetch_prune_t {
  /// Use the setting from the configuration
  GIT_FETCH_PRUNE_UNSPECIFIED(0),

  /// Force pruning on
  GIT_FETCH_PRUNE(1),

  /// Force pruning off
  GIT_FETCH_NO_PRUNE(2);

  final int value;
  const git_fetch_prune_t(this.value);

  static git_fetch_prune_t fromValue(int value) => switch (value) {
        0 => GIT_FETCH_PRUNE_UNSPECIFIED,
        1 => GIT_FETCH_PRUNE,
        2 => GIT_FETCH_NO_PRUNE,
        _ => throw ArgumentError('Unknown value for git_fetch_prune_t: $value'),
      };
}

/// Automatic tag following option
///
/// Lets us select the --tags option to use.
enum git_remote_autotag_option_t {
  /// Use the setting from the configuration.
  GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED(0),

  /// Ask the server for tags pointing to objects we're already
  /// downloading.
  GIT_REMOTE_DOWNLOAD_TAGS_AUTO(1),

  /// Don't ask for any tags beyond the refspecs.
  GIT_REMOTE_DOWNLOAD_TAGS_NONE(2),

  /// Ask for the all the tags.
  GIT_REMOTE_DOWNLOAD_TAGS_ALL(3);

  final int value;
  const git_remote_autotag_option_t(this.value);

  static git_remote_autotag_option_t fromValue(int value) => switch (value) {
        0 => GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED,
        1 => GIT_REMOTE_DOWNLOAD_TAGS_AUTO,
        2 => GIT_REMOTE_DOWNLOAD_TAGS_NONE,
        3 => GIT_REMOTE_DOWNLOAD_TAGS_ALL,
        _ => throw ArgumentError(
            'Unknown value for git_remote_autotag_option_t: $value'),
      };
}

/// Constants for fetch depth (shallowness of fetch).
enum git_fetch_depth_t {
  /// The fetch is "full" (not shallow). This is the default.
  GIT_FETCH_DEPTH_FULL(0),

  /// The fetch should "unshallow" and fetch missing data.
  GIT_FETCH_DEPTH_UNSHALLOW(2147483647);

  final int value;
  const git_fetch_depth_t(this.value);

  static git_fetch_depth_t fromValue(int value) => switch (value) {
        0 => GIT_FETCH_DEPTH_FULL,
        2147483647 => GIT_FETCH_DEPTH_UNSHALLOW,
        _ => throw ArgumentError('Unknown value for git_fetch_depth_t: $value'),
      };
}

/// Fetch options structure.
///
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
///
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
final class git_fetch_options extends ffi.Struct {
  @ffi.Int()
  external int version;

  /// Callbacks to use for this fetch operation
  external git_remote_callbacks callbacks;

  /// Whether to perform a prune after the fetch
  @ffi.UnsignedInt()
  external int pruneAsInt;

  git_fetch_prune_t get prune => git_fetch_prune_t.fromValue(pruneAsInt);

  /// How to handle reference updates; see `git_remote_update_flags`.
  @ffi.UnsignedInt()
  external int update_fetchhead;

  /// Determines how to behave regarding tags on the remote, such
  /// as auto-downloading tags for objects we're downloading or
  /// downloading all of them.
  ///
  /// The default is to auto-follow tags.
  @ffi.UnsignedInt()
  external int download_tagsAsInt;

  git_remote_autotag_option_t get download_tags =>
      git_remote_autotag_option_t.fromValue(download_tagsAsInt);

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Depth of the fetch to perform, or `GIT_FETCH_DEPTH_FULL`
  /// (or `0`) for full history, or `GIT_FETCH_DEPTH_UNSHALLOW`
  /// to "unshallow" a shallow repository.
  ///
  /// The default is full (`GIT_FETCH_DEPTH_FULL` or `0`).
  @ffi.Int()
  external int depth;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.UnsignedInt()
  external int follow_redirectsAsInt;

  git_remote_redirect_t get follow_redirects =>
      git_remote_redirect_t.fromValue(follow_redirectsAsInt);

  /// Extra headers for this fetch operation
  external git_strarray custom_headers;
}

/// Controls the behavior of a git_push object.
final class git_push_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// If the transport being used to push to the remote requires the creation
  /// of a pack file, this controls the number of worker threads used by
  /// the packbuilder when creating that pack file to be sent to the remote.
  ///
  /// If set to 0, the packbuilder will auto-detect the number of threads
  /// to create. The default value is 1.
  @ffi.UnsignedInt()
  external int pb_parallelism;

  /// Callbacks to use for this push operation
  external git_remote_callbacks callbacks;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.UnsignedInt()
  external int follow_redirectsAsInt;

  git_remote_redirect_t get follow_redirects =>
      git_remote_redirect_t.fromValue(follow_redirectsAsInt);

  /// Extra headers for this push operation
  external git_strarray custom_headers;

  /// "Push options" to deliver to the remote.
  external git_strarray remote_push_options;
}

/// Options for bypassing the git-aware transport on clone. Bypassing
/// it means that instead of a fetch, libgit2 will copy the object
/// database directory instead of figuring out what it needs, which is
/// faster. If possible, it will hardlink the files to save space.
enum git_clone_local_t {
  /// Auto-detect (default), libgit2 will bypass the git-aware
  /// transport for local paths, but use a normal fetch for
  /// `file://` urls.
  GIT_CLONE_LOCAL_AUTO(0),

  /// Bypass the git-aware transport even for a `file://` url.
  GIT_CLONE_LOCAL(1),

  /// Do no bypass the git-aware transport
  GIT_CLONE_NO_LOCAL(2),

  /// Bypass the git-aware transport, but do not try to use
  /// hardlinks.
  GIT_CLONE_LOCAL_NO_LINKS(3);

  final int value;
  const git_clone_local_t(this.value);

  static git_clone_local_t fromValue(int value) => switch (value) {
        0 => GIT_CLONE_LOCAL_AUTO,
        1 => GIT_CLONE_LOCAL,
        2 => GIT_CLONE_NO_LOCAL,
        3 => GIT_CLONE_LOCAL_NO_LINKS,
        _ => throw ArgumentError('Unknown value for git_clone_local_t: $value'),
      };
}

typedef git_remote_create_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_remote_create_cbFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Void> payload);

/// The signature of a function matching git_remote_create, with an additional
/// void* as a callback payload.
///
/// Callers of git_clone may provide a function matching this signature to override
/// the remote creation and customization process during a clone operation.
///
/// @param[out] out the resulting remote
/// @param repo the repository in which to create the remote
/// @param name the remote's name
/// @param url the remote's url
/// @param payload an opaque payload
/// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
typedef git_remote_create_cb
    = ffi.Pointer<ffi.NativeFunction<git_remote_create_cbFunction>>;
typedef git_repository_create_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
    ffi.Int bare,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_repository_create_cbFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
    int bare,
    ffi.Pointer<ffi.Void> payload);

/// The signature of a function matching git_repository_init, with an
/// additional void * as callback payload.
///
/// Callers of git_clone my provide a function matching this signature
/// to override the repository creation and customization process
/// during a clone operation.
///
/// @param[out] out the resulting repository
/// @param path path in which to create the repository
/// @param bare whether the repository is bare. This is the value from the clone options
/// @param payload payload specified by the options
/// @return 0, or a negative value to indicate error
typedef git_repository_create_cb
    = ffi.Pointer<ffi.NativeFunction<git_repository_create_cbFunction>>;

/// Clone options structure
///
/// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
/// use `git_clone_options_init`.
///
/// @options[version] GIT_CLONE_OPTIONS_VERSION
/// @options[init_macro] GIT_CLONE_OPTIONS_INIT
/// @options[init_function] git_clone_options_init
final class git_clone_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to `GIT_CHECKOUT_NONE`
  /// or `GIT_CHECKOUT_DRY_RUN`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks are used for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Set to zero (false) to create a standard repo, or non-zero
  /// for a bare repo
  @ffi.Int()
  external int bare;

  /// Whether to use a fetch or copy the object database.
  @ffi.UnsignedInt()
  external int localAsInt;

  git_clone_local_t get local => git_clone_local_t.fromValue(localAsInt);

  /// The name of the branch to checkout. NULL means use the
  /// remote's default branch.
  external ffi.Pointer<ffi.Char> checkout_branch;

  /// A callback used to create the new repository into which to
  /// clone. If NULL, the 'bare' field will be used to determine
  /// whether to create a bare repository.
  external git_repository_create_cb repository_cb;

  /// An opaque payload to pass to the git_repository creation callback.
  /// This parameter is ignored unless repository_cb is non-NULL.
  external ffi.Pointer<ffi.Void> repository_cb_payload;

  /// A callback used to create the git_remote, prior to its being
  /// used to perform the clone operation. See the documentation for
  /// git_remote_create_cb for details. This parameter may be NULL,
  /// indicating that git_clone should provide default behavior.
  external git_remote_create_cb remote_cb;

  /// An opaque payload to pass to the git_remote creation callback.
  /// This parameter is ignored unless remote_cb is non-NULL.
  external ffi.Pointer<ffi.Void> remote_cb_payload;
}

typedef git_config_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_config_foreach_cbFunction = int Function(
    ffi.Pointer<git_config_entry> entry, ffi.Pointer<ffi.Void> payload);

/// A config enumeration callback.
///
/// @param entry the entry currently being enumerated
/// @param payload a user-specified pointer
/// @return non-zero to terminate the iteration.
typedef git_config_foreach_cb
    = ffi.Pointer<ffi.NativeFunction<git_config_foreach_cbFunction>>;

/// Config var type
enum git_configmap_t {
  GIT_CONFIGMAP_FALSE(0),
  GIT_CONFIGMAP_TRUE(1),
  GIT_CONFIGMAP_INT32(2),
  GIT_CONFIGMAP_STRING(3);

  final int value;
  const git_configmap_t(this.value);

  static git_configmap_t fromValue(int value) => switch (value) {
        0 => GIT_CONFIGMAP_FALSE,
        1 => GIT_CONFIGMAP_TRUE,
        2 => GIT_CONFIGMAP_INT32,
        3 => GIT_CONFIGMAP_STRING,
        _ => throw ArgumentError('Unknown value for git_configmap_t: $value'),
      };
}

/// Mapping from config variables to values.
final class git_configmap extends ffi.Struct {
  @ffi.UnsignedInt()
  external int typeAsInt;

  git_configmap_t get type => git_configmap_t.fromValue(typeAsInt);

  external ffi.Pointer<ffi.Char> str_match;

  @ffi.Int()
  external int map_value;
}

/// Reference lookup strategy
///
/// These behave like the --tags and --all options to git-describe,
/// namely they say to look for any reference in either refs/tags/ or
/// refs/ respectively.
enum git_describe_strategy_t {
  GIT_DESCRIBE_DEFAULT(0),
  GIT_DESCRIBE_TAGS(1),
  GIT_DESCRIBE_ALL(2);

  final int value;
  const git_describe_strategy_t(this.value);

  static git_describe_strategy_t fromValue(int value) => switch (value) {
        0 => GIT_DESCRIBE_DEFAULT,
        1 => GIT_DESCRIBE_TAGS,
        2 => GIT_DESCRIBE_ALL,
        _ => throw ArgumentError(
            'Unknown value for git_describe_strategy_t: $value'),
      };
}

/// Describe options structure
///
/// Initialize with `GIT_DESCRIBE_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_options_init`.
final class git_describe_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// < default: 10
  @ffi.UnsignedInt()
  external int max_candidates_tags;

  /// < default: GIT_DESCRIBE_DEFAULT
  @ffi.UnsignedInt()
  external int describe_strategy;

  external ffi.Pointer<ffi.Char> pattern;

  /// When calculating the distance from the matching tag or
  /// reference, only walk down the first-parent ancestry.
  @ffi.Int()
  external int only_follow_first_parent;

  /// If no matching tag or reference is found, the describe
  /// operation would normally fail. If this option is set, it
  /// will instead fall back to showing the full id of the
  /// commit.
  @ffi.Int()
  external int show_commit_oid_as_fallback;
}

/// Describe format options structure
///
/// Initialize with `GIT_DESCRIBE_FORMAT_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_format_options_init`.
final class git_describe_format_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Size of the abbreviated commit id to use. This value is the
  /// lower bound for the length of the abbreviated string. The
  /// default is 7.
  @ffi.UnsignedInt()
  external int abbreviated_size;

  /// Set to use the long format even when a shorter name could be used.
  @ffi.Int()
  external int always_use_long_format;

  /// If the workdir is dirty and this is set, this string will
  /// be appended to the description string.
  external ffi.Pointer<ffi.Char> dirty_suffix;
}

final class git_describe_result extends ffi.Opaque {}

/// Formatting options for diff e-mail generation
enum git_email_create_flags_t {
  /// Normal patch, the default
  GIT_EMAIL_CREATE_DEFAULT(0),

  /// Do not include patch numbers in the subject prefix.
  GIT_EMAIL_CREATE_OMIT_NUMBERS(1),

  /// Include numbers in the subject prefix even when the
  /// patch is for a single commit (1/1).
  GIT_EMAIL_CREATE_ALWAYS_NUMBER(2),

  /// Do not perform rename or similarity detection.
  GIT_EMAIL_CREATE_NO_RENAMES(4);

  final int value;
  const git_email_create_flags_t(this.value);

  static git_email_create_flags_t fromValue(int value) => switch (value) {
        0 => GIT_EMAIL_CREATE_DEFAULT,
        1 => GIT_EMAIL_CREATE_OMIT_NUMBERS,
        2 => GIT_EMAIL_CREATE_ALWAYS_NUMBER,
        4 => GIT_EMAIL_CREATE_NO_RENAMES,
        _ => throw ArgumentError(
            'Unknown value for git_email_create_flags_t: $value'),
      };
}

/// Options for controlling the formatting of the generated e-mail.
final class git_email_create_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// see `git_email_create_flags_t` above
  @ffi.Uint32()
  external int flags;

  /// Options to use when creating diffs
  external git_diff_options diff_opts;

  /// Options for finding similarities within diffs
  external git_diff_find_options diff_find_opts;

  /// The subject prefix, by default "PATCH".  If set to an empty
  /// string ("") then only the patch numbers will be shown in the
  /// prefix.  If the subject_prefix is empty and patch numbers
  /// are not being shown, the prefix will be omitted entirely.
  external ffi.Pointer<ffi.Char> subject_prefix;

  /// The starting patch number; this cannot be 0.  By default,
  /// this is 1.
  @ffi.Size()
  external int start_number;

  /// The "re-roll" number.  By default, there is no re-roll.
  @ffi.Size()
  external int reroll_number;
}

/// Generic return codes
enum git_error_code {
  /// No error occurred; the call was successful.
  GIT_OK(0),

  /// An error occurred; call `git_error_last` for more information.
  GIT_ERROR(-1),

  /// < Requested object could not be found.
  GIT_ENOTFOUND(-3),

  /// < Object exists preventing operation.
  GIT_EEXISTS(-4),

  /// < More than one object matches.
  GIT_EAMBIGUOUS(-5),

  /// < Output buffer too short to hold data.
  GIT_EBUFS(-6),

  /// GIT_EUSER is a special error that is never generated by libgit2
  /// code.  You can return it from a callback (e.g to stop an iteration)
  /// to know that it was generated by the callback and not by libgit2.
  GIT_EUSER(-7),

  /// < Operation not allowed on bare repository.
  GIT_EBAREREPO(-8),

  /// < HEAD refers to branch with no commits.
  GIT_EUNBORNBRANCH(-9),

  /// < Merge in progress prevented operation
  GIT_EUNMERGED(-10),

  /// < Reference was not fast-forwardable
  GIT_ENONFASTFORWARD(-11),

  /// < Name/ref spec was not in a valid format
  GIT_EINVALIDSPEC(-12),

  /// < Checkout conflicts prevented operation
  GIT_ECONFLICT(-13),

  /// < Lock file prevented operation
  GIT_ELOCKED(-14),

  /// < Reference value does not match expected
  GIT_EMODIFIED(-15),

  /// < Authentication error
  GIT_EAUTH(-16),

  /// < Server certificate is invalid
  GIT_ECERTIFICATE(-17),

  /// < Patch/merge has already been applied
  GIT_EAPPLIED(-18),

  /// < The requested peel operation is not possible
  GIT_EPEEL(-19),

  /// < Unexpected EOF
  GIT_EEOF(-20),

  /// < Invalid operation or input
  GIT_EINVALID(-21),

  /// < Uncommitted changes in index prevented operation
  GIT_EUNCOMMITTED(-22),

  /// < The operation is not valid for a directory
  GIT_EDIRECTORY(-23),

  /// < A merge conflict exists and cannot continue
  GIT_EMERGECONFLICT(-24),

  /// < A user-configured callback refused to act
  GIT_PASSTHROUGH(-30),

  /// < Signals end of iteration with iterator
  GIT_ITEROVER(-31),

  /// < Internal only
  GIT_RETRY(-32),

  /// < Hashsum mismatch in object
  GIT_EMISMATCH(-33),

  /// < Unsaved changes in the index would be overwritten
  GIT_EINDEXDIRTY(-34),

  /// < Patch application failed
  GIT_EAPPLYFAIL(-35),

  /// < The object is not owned by the current user
  GIT_EOWNER(-36),

  /// < The operation timed out
  GIT_TIMEOUT(-37),

  /// < There were no changes
  GIT_EUNCHANGED(-38),

  /// < An option is not supported
  GIT_ENOTSUPPORTED(-39),

  /// < The subject is read-only
  GIT_EREADONLY(-40);

  final int value;
  const git_error_code(this.value);

  static git_error_code fromValue(int value) => switch (value) {
        0 => GIT_OK,
        -1 => GIT_ERROR,
        -3 => GIT_ENOTFOUND,
        -4 => GIT_EEXISTS,
        -5 => GIT_EAMBIGUOUS,
        -6 => GIT_EBUFS,
        -7 => GIT_EUSER,
        -8 => GIT_EBAREREPO,
        -9 => GIT_EUNBORNBRANCH,
        -10 => GIT_EUNMERGED,
        -11 => GIT_ENONFASTFORWARD,
        -12 => GIT_EINVALIDSPEC,
        -13 => GIT_ECONFLICT,
        -14 => GIT_ELOCKED,
        -15 => GIT_EMODIFIED,
        -16 => GIT_EAUTH,
        -17 => GIT_ECERTIFICATE,
        -18 => GIT_EAPPLIED,
        -19 => GIT_EPEEL,
        -20 => GIT_EEOF,
        -21 => GIT_EINVALID,
        -22 => GIT_EUNCOMMITTED,
        -23 => GIT_EDIRECTORY,
        -24 => GIT_EMERGECONFLICT,
        -30 => GIT_PASSTHROUGH,
        -31 => GIT_ITEROVER,
        -32 => GIT_RETRY,
        -33 => GIT_EMISMATCH,
        -34 => GIT_EINDEXDIRTY,
        -35 => GIT_EAPPLYFAIL,
        -36 => GIT_EOWNER,
        -37 => GIT_TIMEOUT,
        -38 => GIT_EUNCHANGED,
        -39 => GIT_ENOTSUPPORTED,
        -40 => GIT_EREADONLY,
        _ => throw ArgumentError('Unknown value for git_error_code: $value'),
      };
}

/// Error classes are the category of error. They reflect the area of the
/// code where an error occurred.
enum git_error_t {
  GIT_ERROR_NONE(0),
  GIT_ERROR_NOMEMORY(1),
  GIT_ERROR_OS(2),
  GIT_ERROR_INVALID(3),
  GIT_ERROR_REFERENCE(4),
  GIT_ERROR_ZLIB(5),
  GIT_ERROR_REPOSITORY(6),
  GIT_ERROR_CONFIG(7),
  GIT_ERROR_REGEX(8),
  GIT_ERROR_ODB(9),
  GIT_ERROR_INDEX(10),
  GIT_ERROR_OBJECT(11),
  GIT_ERROR_NET(12),
  GIT_ERROR_TAG(13),
  GIT_ERROR_TREE(14),
  GIT_ERROR_INDEXER(15),
  GIT_ERROR_SSL(16),
  GIT_ERROR_SUBMODULE(17),
  GIT_ERROR_THREAD(18),
  GIT_ERROR_STASH(19),
  GIT_ERROR_CHECKOUT(20),
  GIT_ERROR_FETCHHEAD(21),
  GIT_ERROR_MERGE(22),
  GIT_ERROR_SSH(23),
  GIT_ERROR_FILTER(24),
  GIT_ERROR_REVERT(25),
  GIT_ERROR_CALLBACK(26),
  GIT_ERROR_CHERRYPICK(27),
  GIT_ERROR_DESCRIBE(28),
  GIT_ERROR_REBASE(29),
  GIT_ERROR_FILESYSTEM(30),
  GIT_ERROR_PATCH(31),
  GIT_ERROR_WORKTREE(32),
  GIT_ERROR_SHA(33),
  GIT_ERROR_HTTP(34),
  GIT_ERROR_INTERNAL(35),
  GIT_ERROR_GRAFTS(36);

  final int value;
  const git_error_t(this.value);

  static git_error_t fromValue(int value) => switch (value) {
        0 => GIT_ERROR_NONE,
        1 => GIT_ERROR_NOMEMORY,
        2 => GIT_ERROR_OS,
        3 => GIT_ERROR_INVALID,
        4 => GIT_ERROR_REFERENCE,
        5 => GIT_ERROR_ZLIB,
        6 => GIT_ERROR_REPOSITORY,
        7 => GIT_ERROR_CONFIG,
        8 => GIT_ERROR_REGEX,
        9 => GIT_ERROR_ODB,
        10 => GIT_ERROR_INDEX,
        11 => GIT_ERROR_OBJECT,
        12 => GIT_ERROR_NET,
        13 => GIT_ERROR_TAG,
        14 => GIT_ERROR_TREE,
        15 => GIT_ERROR_INDEXER,
        16 => GIT_ERROR_SSL,
        17 => GIT_ERROR_SUBMODULE,
        18 => GIT_ERROR_THREAD,
        19 => GIT_ERROR_STASH,
        20 => GIT_ERROR_CHECKOUT,
        21 => GIT_ERROR_FETCHHEAD,
        22 => GIT_ERROR_MERGE,
        23 => GIT_ERROR_SSH,
        24 => GIT_ERROR_FILTER,
        25 => GIT_ERROR_REVERT,
        26 => GIT_ERROR_CALLBACK,
        27 => GIT_ERROR_CHERRYPICK,
        28 => GIT_ERROR_DESCRIBE,
        29 => GIT_ERROR_REBASE,
        30 => GIT_ERROR_FILESYSTEM,
        31 => GIT_ERROR_PATCH,
        32 => GIT_ERROR_WORKTREE,
        33 => GIT_ERROR_SHA,
        34 => GIT_ERROR_HTTP,
        35 => GIT_ERROR_INTERNAL,
        36 => GIT_ERROR_GRAFTS,
        _ => throw ArgumentError('Unknown value for git_error_t: $value'),
      };
}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
final class git_error extends ffi.Struct {
  /// < The error message for the last error.
  external ffi.Pointer<ffi.Char> message;

  /// < The category of the last error. @type git_error_t
  @ffi.Int()
  external int klass;
}

/// Filters are applied in one of two directions: smudging - which is
/// exporting a file from the Git object database to the working directory,
/// and cleaning - which is importing a file from the working directory to
/// the Git object database.  These values control which direction of
/// change is being applied.
enum git_filter_mode_t {
  GIT_FILTER_TO_WORKTREE(0),
  GIT_FILTER_TO_ODB(1);

  static const GIT_FILTER_SMUDGE = GIT_FILTER_TO_WORKTREE;
  static const GIT_FILTER_CLEAN = GIT_FILTER_TO_ODB;

  final int value;
  const git_filter_mode_t(this.value);

  static git_filter_mode_t fromValue(int value) => switch (value) {
        0 => GIT_FILTER_TO_WORKTREE,
        1 => GIT_FILTER_TO_ODB,
        _ => throw ArgumentError('Unknown value for git_filter_mode_t: $value'),
      };

  @override
  String toString() {
    if (this == GIT_FILTER_TO_WORKTREE)
      return "git_filter_mode_t.GIT_FILTER_TO_WORKTREE, git_filter_mode_t.GIT_FILTER_SMUDGE";
    if (this == GIT_FILTER_TO_ODB)
      return "git_filter_mode_t.GIT_FILTER_TO_ODB, git_filter_mode_t.GIT_FILTER_CLEAN";
    return super.toString();
  }
}

/// Filter option flags.
enum git_filter_flag_t {
  GIT_FILTER_DEFAULT(0),

  /// Don't error for `safecrlf` violations, allow them to continue.
  GIT_FILTER_ALLOW_UNSAFE(1),

  /// Don't load `/etc/gitattributes` (or the system equivalent)
  GIT_FILTER_NO_SYSTEM_ATTRIBUTES(2),

  /// Load attributes from `.gitattributes` in the root of HEAD
  GIT_FILTER_ATTRIBUTES_FROM_HEAD(4),

  /// Load attributes from `.gitattributes` in a given commit.
  /// This can only be specified in a `git_filter_options`.
  GIT_FILTER_ATTRIBUTES_FROM_COMMIT(8);

  final int value;
  const git_filter_flag_t(this.value);

  static git_filter_flag_t fromValue(int value) => switch (value) {
        0 => GIT_FILTER_DEFAULT,
        1 => GIT_FILTER_ALLOW_UNSAFE,
        2 => GIT_FILTER_NO_SYSTEM_ATTRIBUTES,
        4 => GIT_FILTER_ATTRIBUTES_FROM_HEAD,
        8 => GIT_FILTER_ATTRIBUTES_FROM_COMMIT,
        _ => throw ArgumentError('Unknown value for git_filter_flag_t: $value'),
      };
}

/// Filtering options
final class git_filter_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// See `git_filter_flag_t` above
  @ffi.Uint32()
  external int flags;

  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
  external git_oid attr_commit_id;
}

typedef git_filter_init_fnFunction = ffi.Int Function(
    ffi.Pointer<git_filter> self);
typedef Dartgit_filter_init_fnFunction = int Function(
    ffi.Pointer<git_filter> self);

/// Initialize callback on filter
///
/// Specified as `filter.initialize`, this is an optional callback invoked
/// before a filter is first used.  It will be called once at most.
///
/// If non-NULL, the filter's `initialize` callback will be invoked right
/// before the first use of the filter, so you can defer expensive
/// initialization operations (in case libgit2 is being used in a way that
/// doesn't need the filter).
///
/// @param self the filter to initialize
/// @return 0 on success, negative number on failure
typedef git_filter_init_fn
    = ffi.Pointer<ffi.NativeFunction<git_filter_init_fnFunction>>;
typedef git_filter_shutdown_fnFunction = ffi.Void Function(
    ffi.Pointer<git_filter> self);
typedef Dartgit_filter_shutdown_fnFunction = void Function(
    ffi.Pointer<git_filter> self);

/// Shutdown callback on filter
///
/// Specified as `filter.shutdown`, this is an optional callback invoked
/// when the filter is unregistered or when libgit2 is shutting down.  It
/// will be called once at most and should release resources as needed.
/// This may be called even if the `initialize` callback was not made.
///
/// Typically this function will free the `git_filter` object itself.
///
/// @param self the filter to shutdown
typedef git_filter_shutdown_fn
    = ffi.Pointer<ffi.NativeFunction<git_filter_shutdown_fnFunction>>;

final class git_filter_source extends ffi.Opaque {}

typedef git_filter_check_fnFunction = ffi.Int Function(
    ffi.Pointer<git_filter> self,
    ffi.Pointer<ffi.Pointer<ffi.Void>> payload,
    ffi.Pointer<git_filter_source> src,
    ffi.Pointer<ffi.Pointer<ffi.Char>> attr_values);
typedef Dartgit_filter_check_fnFunction = int Function(
    ffi.Pointer<git_filter> self,
    ffi.Pointer<ffi.Pointer<ffi.Void>> payload,
    ffi.Pointer<git_filter_source> src,
    ffi.Pointer<ffi.Pointer<ffi.Char>> attr_values);

/// Callback to decide if a given source needs this filter
///
/// Specified as `filter.check`, this is an optional callback that checks
/// if filtering is needed for a given source.
///
/// It should return 0 if the filter should be applied (i.e. success),
/// GIT_PASSTHROUGH if the filter should not be applied, or an error code
/// to fail out of the filter processing pipeline and return to the caller.
///
/// The `attr_values` will be set to the values of any attributes given in
/// the filter definition.  See `git_filter` below for more detail.
///
/// The `payload` will be a pointer to a reference payload for the filter.
/// This will start as NULL, but `check` can assign to this pointer for
/// later use by the `stream` callback.  Note that the value should be heap
/// allocated (not stack), so that it doesn't go away before the `stream`
/// callback can use it.  If a filter allocates and assigns a value to the
/// `payload`, it will need a `cleanup` callback to free the payload.
///
/// @param self the filter check
/// @param payload a data for future filter functions
/// @param src the filter source
/// @param attr_values the attribute values
/// @return 0 on success or a negative value on error
typedef git_filter_check_fn
    = ffi.Pointer<ffi.NativeFunction<git_filter_check_fnFunction>>;
typedef git_filter_apply_fnFunction = ffi.Int Function(
    ffi.Pointer<git_filter> self,
    ffi.Pointer<ffi.Pointer<ffi.Void>> payload,
    ffi.Pointer<git_buf> to,
    ffi.Pointer<git_buf> from,
    ffi.Pointer<git_filter_source> src);
typedef Dartgit_filter_apply_fnFunction = int Function(
    ffi.Pointer<git_filter> self,
    ffi.Pointer<ffi.Pointer<ffi.Void>> payload,
    ffi.Pointer<git_buf> to,
    ffi.Pointer<git_buf> from,
    ffi.Pointer<git_filter_source> src);

/// Callback to actually perform the data filtering
///
/// Specified as `filter.apply`, this is the callback that actually filters
/// data.  If it successfully writes the output, it should return 0.  Like
/// `check`, it can return GIT_PASSTHROUGH to indicate that the filter
/// doesn't want to run.  Other error codes will stop filter processing and
/// return to the caller.
///
/// The `payload` value will refer to any payload that was set by the
/// `check` callback.  It may be read from or written to as needed.
///
/// @param self the filter check
/// @param payload a data for future filter functions
/// @param to the input buffer
/// @param from the output buffer
/// @param src the filter source
/// @return 0 on success or a negative value on error
/// @deprecated use git_filter_stream_fn
typedef git_filter_apply_fn
    = ffi.Pointer<ffi.NativeFunction<git_filter_apply_fnFunction>>;
typedef git_filter_stream_fnFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_writestream>> out,
    ffi.Pointer<git_filter> self,
    ffi.Pointer<ffi.Pointer<ffi.Void>> payload,
    ffi.Pointer<git_filter_source> src,
    ffi.Pointer<git_writestream> next);
typedef Dartgit_filter_stream_fnFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_writestream>> out,
    ffi.Pointer<git_filter> self,
    ffi.Pointer<ffi.Pointer<ffi.Void>> payload,
    ffi.Pointer<git_filter_source> src,
    ffi.Pointer<git_writestream> next);

/// Callback to perform the data filtering.
///
/// Specified as `filter.stream`, this is a callback that filters data
/// in a streaming manner.  This function will provide a
/// `git_writestream` that will the original data will be written to;
/// with that data, the `git_writestream` will then perform the filter
/// translation and stream the filtered data out to the `next` location.
///
/// @param out the write stream
/// @param self the filter
/// @param payload a data for future filter functions
/// @param src the filter source
/// @param next the output stream
/// @return 0 on success or a negative value on error
typedef git_filter_stream_fn
    = ffi.Pointer<ffi.NativeFunction<git_filter_stream_fnFunction>>;
typedef git_filter_cleanup_fnFunction = ffi.Void Function(
    ffi.Pointer<git_filter> self, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_filter_cleanup_fnFunction = void Function(
    ffi.Pointer<git_filter> self, ffi.Pointer<ffi.Void> payload);

/// Callback to clean up after filtering has been applied
///
/// Specified as `filter.cleanup`, this is an optional callback invoked
/// after the filter has been applied.  If the `check`, `apply`, or
/// `stream` callbacks allocated a `payload` to keep per-source filter
/// state, use this callback to free that payload and release resources
/// as required.
///
/// @param self the filter
/// @param payload a data for future filter functions
typedef git_filter_cleanup_fn
    = ffi.Pointer<ffi.NativeFunction<git_filter_cleanup_fnFunction>>;

/// Filter structure used to register custom filters.
///
/// To associate extra data with a filter, allocate extra data and put the
/// `git_filter` struct at the start of your data buffer, then cast the
/// `self` pointer to your larger structure when your callback is invoked.
final class git_filter extends ffi.Struct {
  /// The `version` field should be set to `GIT_FILTER_VERSION`.
  @ffi.UnsignedInt()
  external int version;

  /// A whitespace-separated list of attribute names to check for this
  /// filter (e.g. "eol crlf text").  If the attribute name is bare, it
  /// will be simply loaded and passed to the `check` callback.  If it
  /// has a value (i.e. "name=value"), the attribute must match that
  /// value for the filter to be applied.  The value may be a wildcard
  /// (eg, "name=*"), in which case the filter will be invoked for any
  /// value for the given attribute name.  See the attribute parameter
  /// of the `check` callback for the attribute value that was specified.
  external ffi.Pointer<ffi.Char> attributes;

  /// Called when the filter is first used for any file.
  external git_filter_init_fn initialize;

  /// Called when the filter is removed or unregistered from the system.
  external git_filter_shutdown_fn shutdown;

  /// Called to determine whether the filter should be invoked for a
  /// given file.  If this function returns `GIT_PASSTHROUGH` then the
  /// `stream` or `apply` functions will not be invoked and the
  /// contents will be passed through unmodified.
  external git_filter_check_fn check;

  /// Provided for backward compatibility; this will apply the
  /// filter to the given contents in a `git_buf`.  Callers should
  /// provide a `stream` function instead.
  external git_filter_apply_fn apply;

  /// Called to apply the filter, this function will provide a
  /// `git_writestream` that will the original data will be
  /// written to; with that data, the `git_writestream` will then
  /// perform the filter translation and stream the filtered data
  /// out to the `next` location.
  external git_filter_stream_fn stream;

  /// Called when the system is done filtering for a file.
  external git_filter_cleanup_fn cleanup;
}

final class git_filter_list extends ffi.Opaque {}

/// Represents a single git message trailer.
final class git_message_trailer extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}

/// Represents an array of git message trailers.
///
/// Struct members under the private comment are private, subject to change
/// and should not be used by callers.
final class git_message_trailer_array extends ffi.Struct {
  external ffi.Pointer<git_message_trailer> trailers;

  @ffi.Size()
  external int count;

  /// private
  external ffi.Pointer<ffi.Char> _trailer_block;
}

typedef git_note_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<git_oid> blob_id,
    ffi.Pointer<git_oid> annotated_object_id,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_note_foreach_cbFunction = int Function(
    ffi.Pointer<git_oid> blob_id,
    ffi.Pointer<git_oid> annotated_object_id,
    ffi.Pointer<ffi.Void> payload);

/// Callback for git_note_foreach.
///
/// @param blob_id object id of the blob containing the message
/// @param annotated_object_id the id of the object being annotated
/// @param payload user-specified data to the foreach function
/// @return 0 on success, or a negative number on failure
typedef git_note_foreach_cb
    = ffi.Pointer<ffi.NativeFunction<git_note_foreach_cbFunction>>;

final class git_iterator extends ffi.Opaque {}

/// note iterator
typedef git_note_iterator = git_iterator;

/// Options for configuring a packfile object backend.
final class git_odb_backend_pack_options extends ffi.Struct {
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// Type of object IDs to use for this object database, or
  /// 0 for default (currently SHA1).
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

enum git_odb_backend_loose_flag_t {
  GIT_ODB_BACKEND_LOOSE_FSYNC(1);

  final int value;
  const git_odb_backend_loose_flag_t(this.value);

  static git_odb_backend_loose_flag_t fromValue(int value) => switch (value) {
        1 => GIT_ODB_BACKEND_LOOSE_FSYNC,
        _ => throw ArgumentError(
            'Unknown value for git_odb_backend_loose_flag_t: $value'),
      };
}

/// Options for configuring a loose object backend.
final class git_odb_backend_loose_options extends ffi.Struct {
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// A combination of the `git_odb_backend_loose_flag_t` types.
  @ffi.Uint32()
  external int flags;

  /// zlib compression level to use (0-9), where 1 is the fastest
  /// at the expense of larger files, and 9 produces the best
  /// compression at the expense of speed.  0 indicates that no
  /// compression should be performed.  -1 is the default (currently
  /// optimizing for speed).
  @ffi.Int()
  external int compression_level;

  /// Permissions to use creating a directory or 0 for defaults
  @ffi.UnsignedInt()
  external int dir_mode;

  /// Permissions to use creating a file or 0 for defaults
  @ffi.UnsignedInt()
  external int file_mode;

  /// Type of object IDs to use for this object database, or
  /// 0 for default (currently SHA1).
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

/// Streaming mode
enum git_odb_stream_t {
  GIT_STREAM_RDONLY(2),
  GIT_STREAM_WRONLY(4),
  GIT_STREAM_RW(6);

  final int value;
  const git_odb_stream_t(this.value);

  static git_odb_stream_t fromValue(int value) => switch (value) {
        2 => GIT_STREAM_RDONLY,
        4 => GIT_STREAM_WRONLY,
        6 => GIT_STREAM_RW,
        _ => throw ArgumentError('Unknown value for git_odb_stream_t: $value'),
      };
}

final class git_patch extends ffi.Opaque {}

final class git_pathspec extends ffi.Opaque {}

final class git_pathspec_match_list extends ffi.Opaque {}

/// Options controlling how pathspec match should be executed
enum git_pathspec_flag_t {
  GIT_PATHSPEC_DEFAULT(0),

  /// GIT_PATHSPEC_IGNORE_CASE forces match to ignore case; otherwise
  /// match will use native case sensitivity of platform filesystem
  GIT_PATHSPEC_IGNORE_CASE(1),

  /// GIT_PATHSPEC_USE_CASE forces case sensitive match; otherwise
  /// match will use native case sensitivity of platform filesystem
  GIT_PATHSPEC_USE_CASE(2),

  /// GIT_PATHSPEC_NO_GLOB disables glob patterns and just uses simple
  /// string comparison for matching
  GIT_PATHSPEC_NO_GLOB(4),

  /// GIT_PATHSPEC_NO_MATCH_ERROR means the match functions return error
  /// code GIT_ENOTFOUND if no matches are found; otherwise no matches is
  /// still success (return 0) but `git_pathspec_match_list_entrycount`
  /// will indicate 0 matches.
  GIT_PATHSPEC_NO_MATCH_ERROR(8),

  /// GIT_PATHSPEC_FIND_FAILURES means that the `git_pathspec_match_list`
  /// should track which patterns matched which files so that at the end of
  /// the match we can identify patterns that did not match any files.
  GIT_PATHSPEC_FIND_FAILURES(16),

  /// GIT_PATHSPEC_FAILURES_ONLY means that the `git_pathspec_match_list`
  /// does not need to keep the actual matching filenames.  Use this to
  /// just test if there were any matches at all or in combination with
  /// GIT_PATHSPEC_FIND_FAILURES to validate a pathspec.
  GIT_PATHSPEC_FAILURES_ONLY(32);

  final int value;
  const git_pathspec_flag_t(this.value);

  static git_pathspec_flag_t fromValue(int value) => switch (value) {
        0 => GIT_PATHSPEC_DEFAULT,
        1 => GIT_PATHSPEC_IGNORE_CASE,
        2 => GIT_PATHSPEC_USE_CASE,
        4 => GIT_PATHSPEC_NO_GLOB,
        8 => GIT_PATHSPEC_NO_MATCH_ERROR,
        16 => GIT_PATHSPEC_FIND_FAILURES,
        32 => GIT_PATHSPEC_FAILURES_ONLY,
        _ =>
          throw ArgumentError('Unknown value for git_pathspec_flag_t: $value'),
      };
}

/// Rebase options
///
/// Use to tell the rebase machinery how to operate.
final class git_rebase_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Used by `git_rebase_init`, this will instruct other clients working
  /// on this rebase that you want a quiet rebase experience, which they
  /// may choose to provide in an application-specific manner.  This has no
  /// effect upon libgit2 directly, but is provided for interoperability
  /// between Git tools.
  @ffi.Int()
  external int quiet;

  /// Used by `git_rebase_init`, this will begin an in-memory rebase,
  /// which will allow callers to step through the rebase operations and
  /// commit the rebased changes, but will not rewind HEAD or update the
  /// repository to be in a rebasing state.  This will not interfere with
  /// the working directory (if there is one).
  @ffi.Int()
  external int inmemory;

  /// Used by `git_rebase_finish`, this is the name of the notes reference
  /// used to rewrite notes for rebased commits when finishing the rebase;
  /// if NULL, the contents of the configuration option `notes.rewriteRef`
  /// is examined, unless the configuration option `notes.rewrite.rebase`
  /// is set to false.  If `notes.rewriteRef` is also NULL, notes will
  /// not be rewritten.
  external ffi.Pointer<ffi.Char> rewrite_notes_ref;

  /// Options to control how trees are merged during `git_rebase_next`.
  external git_merge_options merge_options;

  /// Options to control how files are written during `git_rebase_init`,
  /// `git_rebase_next` and `git_rebase_abort`.  Note that during
  /// `abort`, these options will add an implied `GIT_CHECKOUT_FORCE`
  /// to match git semantics.
  external git_checkout_options checkout_options;

  /// Optional callback that allows users to override commit
  /// creation in `git_rebase_commit`.  If specified, users can
  /// create their own commit and provide the commit ID, which
  /// may be useful for signing commits or otherwise customizing
  /// the commit creation.
  ///
  /// If this callback returns `GIT_PASSTHROUGH`, then
  /// `git_rebase_commit` will continue to create the commit.
  external git_commit_create_cb commit_create_cb;

  /// If provided, this will be called with the commit content, allowing
  /// a signature to be added to the rebase commit. Can be skipped with
  /// GIT_PASSTHROUGH. If GIT_PASSTHROUGH is returned, a commit will be made
  /// without a signature.
  ///
  /// This field is only used when performing git_rebase_commit.
  ///
  /// This callback is not invoked if a `git_commit_create_cb` is
  /// specified.
  ///
  /// This callback is deprecated; users should provide a
  /// creation callback as `commit_create_cb` that produces a
  /// commit buffer, signs it, and commits it.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_buf>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>> signing_cb;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;
}

/// Type of rebase operation in-progress after calling `git_rebase_next`.
enum git_rebase_operation_t {
  /// The given commit is to be cherry-picked.  The client should commit
  /// the changes and continue if there are no conflicts.
  GIT_REBASE_OPERATION_PICK(0),

  /// The given commit is to be cherry-picked, but the client should prompt
  /// the user to provide an updated commit message.
  GIT_REBASE_OPERATION_REWORD(1),

  /// The given commit is to be cherry-picked, but the client should stop
  /// to allow the user to edit the changes before committing them.
  GIT_REBASE_OPERATION_EDIT(2),

  /// The given commit is to be squashed into the previous commit.  The
  /// commit message will be merged with the previous message.
  GIT_REBASE_OPERATION_SQUASH(3),

  /// The given commit is to be squashed into the previous commit.  The
  /// commit message from this commit will be discarded.
  GIT_REBASE_OPERATION_FIXUP(4),

  /// No commit will be cherry-picked.  The client should run the given
  /// command and (if successful) continue.
  GIT_REBASE_OPERATION_EXEC(5);

  final int value;
  const git_rebase_operation_t(this.value);

  static git_rebase_operation_t fromValue(int value) => switch (value) {
        0 => GIT_REBASE_OPERATION_PICK,
        1 => GIT_REBASE_OPERATION_REWORD,
        2 => GIT_REBASE_OPERATION_EDIT,
        3 => GIT_REBASE_OPERATION_SQUASH,
        4 => GIT_REBASE_OPERATION_FIXUP,
        5 => GIT_REBASE_OPERATION_EXEC,
        _ => throw ArgumentError(
            'Unknown value for git_rebase_operation_t: $value'),
      };
}

/// A rebase operation
///
/// Describes a single instruction/operation to be performed during the
/// rebase.
final class git_rebase_operation extends ffi.Struct {
  /// The type of rebase operation.
  @ffi.UnsignedInt()
  external int typeAsInt;

  git_rebase_operation_t get type =>
      git_rebase_operation_t.fromValue(typeAsInt);

  /// The commit ID being cherry-picked.  This will be populated for
  /// all operations except those of type `GIT_REBASE_OPERATION_EXEC`.
  external git_oid id;

  /// The executable the user has requested be run.  This will only
  /// be populated for operations of type `GIT_REBASE_OPERATION_EXEC`.
  external ffi.Pointer<ffi.Char> exec;
}

/// Kinds of reset operation
enum git_reset_t {
  /// < Move the head to the given commit
  GIT_RESET_SOFT(1),

  /// < SOFT plus reset index to the commit
  GIT_RESET_MIXED(2),

  /// < MIXED plus changes in working tree discarded
  GIT_RESET_HARD(3);

  final int value;
  const git_reset_t(this.value);

  static git_reset_t fromValue(int value) => switch (value) {
        1 => GIT_RESET_SOFT,
        2 => GIT_RESET_MIXED,
        3 => GIT_RESET_HARD,
        _ => throw ArgumentError('Unknown value for git_reset_t: $value'),
      };
}

/// Options for revert
final class git_revert_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.UnsignedInt()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;
}

/// Revparse flags.  These indicate the intended behavior of the spec passed to
/// git_revparse.
enum git_revspec_t {
  /// The spec targeted a single object.
  GIT_REVSPEC_SINGLE(1),

  /// The spec targeted a range of commits.
  GIT_REVSPEC_RANGE(2),

  /// The spec used the '...' operator, which invokes special semantics.
  GIT_REVSPEC_MERGE_BASE(4);

  final int value;
  const git_revspec_t(this.value);

  static git_revspec_t fromValue(int value) => switch (value) {
        1 => GIT_REVSPEC_SINGLE,
        2 => GIT_REVSPEC_RANGE,
        4 => GIT_REVSPEC_MERGE_BASE,
        _ => throw ArgumentError('Unknown value for git_revspec_t: $value'),
      };
}

/// Git Revision Spec: output of a `git_revparse` operation
final class git_revspec extends ffi.Struct {
  /// The left element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> from;

  /// The right element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> to;

  /// The intent of the revspec (i.e. `git_revspec_mode_t` flags)
  @ffi.UnsignedInt()
  external int flags;
}

/// Flags to specify the sorting which a revwalk should perform.
enum git_sort_t {
  /// Sort the output with the same default method from `git`: reverse
  /// chronological order. This is the default sorting for new walkers.
  GIT_SORT_NONE(0),

  /// Sort the repository contents in topological order (no parents before
  /// all of its children are shown); this sorting mode can be combined
  /// with time sorting to produce `git`'s `--date-order``.
  GIT_SORT_TOPOLOGICAL(1),

  /// Sort the repository contents by commit time;
  /// this sorting mode can be combined with
  /// topological sorting.
  GIT_SORT_TIME(2),

  /// Iterate through the repository contents in reverse
  /// order; this sorting mode can be combined with
  /// any of the above.
  GIT_SORT_REVERSE(4);

  final int value;
  const git_sort_t(this.value);

  static git_sort_t fromValue(int value) => switch (value) {
        0 => GIT_SORT_NONE,
        1 => GIT_SORT_TOPOLOGICAL,
        2 => GIT_SORT_TIME,
        4 => GIT_SORT_REVERSE,
        _ => throw ArgumentError('Unknown value for git_sort_t: $value'),
      };
}

typedef git_revwalk_hide_cbFunction = ffi.Int Function(
    ffi.Pointer<git_oid> commit_id, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_revwalk_hide_cbFunction = int Function(
    ffi.Pointer<git_oid> commit_id, ffi.Pointer<ffi.Void> payload);

/// This is a callback function that user can provide to hide a
/// commit and its parents. If the callback function returns non-zero value,
/// then this commit and its parents will be hidden.
///
/// @param commit_id oid of Commit
/// @param payload User-specified pointer to data to be passed as data payload
/// @return non-zero to hide the commmit and it parent.
typedef git_revwalk_hide_cb
    = ffi.Pointer<ffi.NativeFunction<git_revwalk_hide_cbFunction>>;

/// Stash flags
enum git_stash_flags {
  /// No option, default
  GIT_STASH_DEFAULT(0),

  /// All changes already added to the index are left intact in
  /// the working directory
  GIT_STASH_KEEP_INDEX(1),

  /// All untracked files are also stashed and then cleaned up
  /// from the working directory
  GIT_STASH_INCLUDE_UNTRACKED(2),

  /// All ignored files are also stashed and then cleaned up from
  /// the working directory
  GIT_STASH_INCLUDE_IGNORED(4),

  /// All changes in the index and working directory are left intact
  GIT_STASH_KEEP_ALL(8);

  final int value;
  const git_stash_flags(this.value);

  static git_stash_flags fromValue(int value) => switch (value) {
        0 => GIT_STASH_DEFAULT,
        1 => GIT_STASH_KEEP_INDEX,
        2 => GIT_STASH_INCLUDE_UNTRACKED,
        4 => GIT_STASH_INCLUDE_IGNORED,
        8 => GIT_STASH_KEEP_ALL,
        _ => throw ArgumentError('Unknown value for git_stash_flags: $value'),
      };
}

/// Stash save options structure
///
/// Initialize with `GIT_STASH_SAVE_OPTIONS_INIT`. Alternatively, you can
/// use `git_stash_save_options_init`.
final class git_stash_save_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Flags to control the stashing process. (see GIT_STASH_* above)
  @ffi.Uint32()
  external int flags;

  /// The identity of the person performing the stashing.
  external ffi.Pointer<git_signature> stasher;

  /// Optional description along with the stashed state.
  external ffi.Pointer<ffi.Char> message;

  /// Optional paths that control which files are stashed.
  external git_strarray paths;
}

/// Stash application flags.
enum git_stash_apply_flags {
  GIT_STASH_APPLY_DEFAULT(0),

  /// Try to reinstate not only the working tree's changes,
  /// but also the index's changes.
  GIT_STASH_APPLY_REINSTATE_INDEX(1);

  final int value;
  const git_stash_apply_flags(this.value);

  static git_stash_apply_flags fromValue(int value) => switch (value) {
        0 => GIT_STASH_APPLY_DEFAULT,
        1 => GIT_STASH_APPLY_REINSTATE_INDEX,
        _ => throw ArgumentError(
            'Unknown value for git_stash_apply_flags: $value'),
      };
}

/// Stash apply progression states
enum git_stash_apply_progress_t {
  GIT_STASH_APPLY_PROGRESS_NONE(0),

  /// Loading the stashed data from the object database.
  GIT_STASH_APPLY_PROGRESS_LOADING_STASH(1),

  /// The stored index is being analyzed.
  GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX(2),

  /// The modified files are being analyzed.
  GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED(3),

  /// The untracked and ignored files are being analyzed.
  GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED(4),

  /// The untracked files are being written to disk.
  GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED(5),

  /// The modified files are being written to disk.
  GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED(6),

  /// The stash was applied successfully.
  GIT_STASH_APPLY_PROGRESS_DONE(7);

  final int value;
  const git_stash_apply_progress_t(this.value);

  static git_stash_apply_progress_t fromValue(int value) => switch (value) {
        0 => GIT_STASH_APPLY_PROGRESS_NONE,
        1 => GIT_STASH_APPLY_PROGRESS_LOADING_STASH,
        2 => GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX,
        3 => GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED,
        4 => GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED,
        5 => GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED,
        6 => GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED,
        7 => GIT_STASH_APPLY_PROGRESS_DONE,
        _ => throw ArgumentError(
            'Unknown value for git_stash_apply_progress_t: $value'),
      };
}

typedef git_stash_apply_progress_cbFunction = ffi.Int Function(
    ffi.UnsignedInt progress, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_stash_apply_progress_cbFunction = int Function(
    git_stash_apply_progress_t progress, ffi.Pointer<ffi.Void> payload);

/// Stash application progress notification function.
/// Return 0 to continue processing, or a negative value to
/// abort the stash application.
///
/// @param progress the progress information
/// @param payload the user-specified payload to the apply function
/// @return 0 on success, -1 on error
typedef git_stash_apply_progress_cb
    = ffi.Pointer<ffi.NativeFunction<git_stash_apply_progress_cbFunction>>;

/// Stash application options structure
///
/// Initialize with `GIT_STASH_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_stash_apply_options_init`.
final class git_stash_apply_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// See `git_stash_apply_flags`, above.
  @ffi.Uint32()
  external int flags;

  /// Options to use when writing files to the working directory.
  external git_checkout_options checkout_options;

  /// Optional callback to notify the consumer of application progress.
  external git_stash_apply_progress_cb progress_cb;

  external ffi.Pointer<ffi.Void> progress_payload;
}

typedef git_stash_cbFunction = ffi.Int Function(
    ffi.Size index,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_oid> stash_id,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_stash_cbFunction = int Function(
    int index,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_oid> stash_id,
    ffi.Pointer<ffi.Void> payload);

/// This is a callback function you can provide to iterate over all the
/// stashed states that will be invoked per entry.
///
/// @param index The position within the stash list. 0 points to the
/// most recent stashed state.
/// @param message The stash message.
/// @param stash_id The commit oid of the stashed state.
/// @param payload Extra parameter to callback function.
/// @return 0 to continue iterating or non-zero to stop.
typedef git_stash_cb = ffi.Pointer<ffi.NativeFunction<git_stash_cbFunction>>;

/// Status flags for a single file.
///
/// A combination of these values will be returned to indicate the status of
/// a file.  Status compares the working directory, the index, and the
/// current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags
/// represents the status of file in the index relative to the HEAD, and the
/// `GIT_STATUS_WT` set of flags represent the status of the file in the
/// working directory relative to the index.
enum git_status_t {
  GIT_STATUS_CURRENT(0),
  GIT_STATUS_INDEX_NEW(1),
  GIT_STATUS_INDEX_MODIFIED(2),
  GIT_STATUS_INDEX_DELETED(4),
  GIT_STATUS_INDEX_RENAMED(8),
  GIT_STATUS_INDEX_TYPECHANGE(16),
  GIT_STATUS_WT_NEW(128),
  GIT_STATUS_WT_MODIFIED(256),
  GIT_STATUS_WT_DELETED(512),
  GIT_STATUS_WT_TYPECHANGE(1024),
  GIT_STATUS_WT_RENAMED(2048),
  GIT_STATUS_WT_UNREADABLE(4096),
  GIT_STATUS_IGNORED(16384),
  GIT_STATUS_CONFLICTED(32768);

  final int value;
  const git_status_t(this.value);

  static git_status_t fromValue(int value) => switch (value) {
        0 => GIT_STATUS_CURRENT,
        1 => GIT_STATUS_INDEX_NEW,
        2 => GIT_STATUS_INDEX_MODIFIED,
        4 => GIT_STATUS_INDEX_DELETED,
        8 => GIT_STATUS_INDEX_RENAMED,
        16 => GIT_STATUS_INDEX_TYPECHANGE,
        128 => GIT_STATUS_WT_NEW,
        256 => GIT_STATUS_WT_MODIFIED,
        512 => GIT_STATUS_WT_DELETED,
        1024 => GIT_STATUS_WT_TYPECHANGE,
        2048 => GIT_STATUS_WT_RENAMED,
        4096 => GIT_STATUS_WT_UNREADABLE,
        16384 => GIT_STATUS_IGNORED,
        32768 => GIT_STATUS_CONFLICTED,
        _ => throw ArgumentError('Unknown value for git_status_t: $value'),
      };
}

typedef git_status_cbFunction = ffi.Int Function(ffi.Pointer<ffi.Char> path,
    ffi.UnsignedInt status_flags, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_status_cbFunction = int Function(ffi.Pointer<ffi.Char> path,
    int status_flags, ffi.Pointer<ffi.Void> payload);

/// Function pointer to receive status on individual files
///
/// @param path is the path to the file
/// @param status_flags the `git_status_t` values for file's status
/// @param payload the user-specified payload to the foreach function
/// @return 0 on success, or a negative number on failure
typedef git_status_cb = ffi.Pointer<ffi.NativeFunction<git_status_cbFunction>>;

/// Select the files on which to report status.
///
/// With `git_status_foreach_ext`, this will control which changes get
/// callbacks.  With `git_status_list_new`, these will control which
/// changes are included in the list.
enum git_status_show_t {
  /// The default. This roughly matches `git status --porcelain` regarding
  /// which files are included and in what order.
  GIT_STATUS_SHOW_INDEX_AND_WORKDIR(0),

  /// Only gives status based on HEAD to index comparison, not looking at
  /// working directory changes.
  GIT_STATUS_SHOW_INDEX_ONLY(1),

  /// Only gives status based on index to working directory comparison,
  /// not comparing the index to the HEAD.
  GIT_STATUS_SHOW_WORKDIR_ONLY(2);

  final int value;
  const git_status_show_t(this.value);

  static git_status_show_t fromValue(int value) => switch (value) {
        0 => GIT_STATUS_SHOW_INDEX_AND_WORKDIR,
        1 => GIT_STATUS_SHOW_INDEX_ONLY,
        2 => GIT_STATUS_SHOW_WORKDIR_ONLY,
        _ => throw ArgumentError('Unknown value for git_status_show_t: $value'),
      };
}

/// Flags to control status callbacks
///
/// Calling `git_status_foreach()` is like calling the extended version
/// with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
/// and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
/// together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.
enum git_status_opt_t {
  /// Says that callbacks should be made on untracked files.
  /// These will only be made if the workdir files are included in the status
  /// "show" option.
  GIT_STATUS_OPT_INCLUDE_UNTRACKED(1),

  /// Says that ignored files get callbacks.
  /// Again, these callbacks will only be made if the workdir files are
  /// included in the status "show" option.
  GIT_STATUS_OPT_INCLUDE_IGNORED(2),

  /// Indicates that callback should be made even on unmodified files.
  GIT_STATUS_OPT_INCLUDE_UNMODIFIED(4),

  /// Indicates that submodules should be skipped.
  /// This only applies if there are no pending typechanges to the submodule
  /// (either from or to another type).
  GIT_STATUS_OPT_EXCLUDE_SUBMODULES(8),

  /// Indicates that all files in untracked directories should be included.
  /// Normally if an entire directory is new, then just the top-level
  /// directory is included (with a trailing slash on the entry name).
  /// This flag says to include all of the individual files in the directory
  /// instead.
  GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS(16),

  /// Indicates that the given path should be treated as a literal path,
  /// and not as a pathspec pattern.
  GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH(32),

  /// Indicates that the contents of ignored directories should be included
  /// in the status. This is like doing `git ls-files -o -i --exclude-standard`
  /// with core git.
  GIT_STATUS_OPT_RECURSE_IGNORED_DIRS(64),

  /// Indicates that rename detection should be processed between the head and
  /// the index and enables the GIT_STATUS_INDEX_RENAMED as a possible status
  /// flag.
  GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX(128),

  /// Indicates that rename detection should be run between the index and the
  /// working directory and enabled GIT_STATUS_WT_RENAMED as a possible status
  /// flag.
  GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR(256),

  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-sensitive order.
  GIT_STATUS_OPT_SORT_CASE_SENSITIVELY(512),

  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-insensitive order.
  GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY(1024),

  /// Iindicates that rename detection should include rewritten files.
  GIT_STATUS_OPT_RENAMES_FROM_REWRITES(2048),

  /// Bypasses the default status behavior of doing a "soft" index reload
  /// (i.e. reloading the index data if the file on disk has been modified
  /// outside libgit2).
  GIT_STATUS_OPT_NO_REFRESH(4096),

  /// Tells libgit2 to refresh the stat cache in the index for files that are
  /// unchanged but have out of date stat einformation in the index.
  /// It will result in less work being done on subsequent calls to get status.
  /// This is mutually exclusive with the NO_REFRESH option.
  GIT_STATUS_OPT_UPDATE_INDEX(8192),

  /// Normally files that cannot be opened or read are ignored as
  /// these are often transient files; this option will return
  /// unreadable files as `GIT_STATUS_WT_UNREADABLE`.
  GIT_STATUS_OPT_INCLUDE_UNREADABLE(16384),

  /// Unreadable files will be detected and given the status
  /// untracked instead of unreadable.
  GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED(32768);

  final int value;
  const git_status_opt_t(this.value);

  static git_status_opt_t fromValue(int value) => switch (value) {
        1 => GIT_STATUS_OPT_INCLUDE_UNTRACKED,
        2 => GIT_STATUS_OPT_INCLUDE_IGNORED,
        4 => GIT_STATUS_OPT_INCLUDE_UNMODIFIED,
        8 => GIT_STATUS_OPT_EXCLUDE_SUBMODULES,
        16 => GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS,
        32 => GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH,
        64 => GIT_STATUS_OPT_RECURSE_IGNORED_DIRS,
        128 => GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX,
        256 => GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR,
        512 => GIT_STATUS_OPT_SORT_CASE_SENSITIVELY,
        1024 => GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY,
        2048 => GIT_STATUS_OPT_RENAMES_FROM_REWRITES,
        4096 => GIT_STATUS_OPT_NO_REFRESH,
        8192 => GIT_STATUS_OPT_UPDATE_INDEX,
        16384 => GIT_STATUS_OPT_INCLUDE_UNREADABLE,
        32768 => GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED,
        _ => throw ArgumentError('Unknown value for git_status_opt_t: $value'),
      };
}

/// Options to control how `git_status_foreach_ext()` will issue callbacks.
///
/// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
/// use `git_status_options_init`.
final class git_status_options extends ffi.Struct {
  /// The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  @ffi.UnsignedInt()
  external int version;

  /// The `show` value is one of the `git_status_show_t` constants that
  /// control which files to scan and in what order. The default is
  /// `GIT_STATUS_SHOW_INDEX_AND_WORKDIR`.
  @ffi.UnsignedInt()
  external int show$AsInt;

  git_status_show_t get show$ => git_status_show_t.fromValue(show$AsInt);

  /// The `flags` value is an OR'ed combination of the
  /// `git_status_opt_t` values above. The default is
  /// `GIT_STATUS_OPT_DEFAULTS`, which matches git's default
  /// behavior.
  @ffi.UnsignedInt()
  external int flags;

  /// The `pathspec` is an array of path patterns to match (using
  /// fnmatch-style matching), or just an array of paths to match
  /// exactly if `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified
  /// in the flags.
  external git_strarray pathspec;

  /// The `baseline` is the tree to be used for comparison to the
  /// working directory and index; defaults to HEAD.
  external ffi.Pointer<git_tree> baseline;

  /// Threshold above which similar files will be considered renames.
  /// This is equivalent to the -M option. Defaults to 50.
  @ffi.Uint16()
  external int rename_threshold;
}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
///
/// The `status` value provides the status flags for this file.
///
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
///
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
final class git_status_entry extends ffi.Struct {
  @ffi.UnsignedInt()
  external int statusAsInt;

  git_status_t get status => git_status_t.fromValue(statusAsInt);

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;
}

/// Return codes for submodule status.
///
/// A combination of these flags will be returned to describe the status of a
/// submodule.  Depending on the "ignore" property of the submodule, some of
/// the flags may never be returned because they indicate changes that are
/// supposed to be ignored.
///
/// Submodule info is contained in 4 places: the HEAD tree, the index, config
/// files (both .git/config and .gitmodules), and the working directory.  Any
/// or all of those places might be missing information about the submodule
/// depending on what state the repo is in.  We consider all four places to
/// build the combination of status flags.
///
/// There are four values that are not really status, but give basic info
/// about what sources of submodule data are available.  These will be
/// returned even if ignore is set to "ALL".
///
/// * IN_HEAD   - superproject head contains submodule
/// * IN_INDEX  - superproject index contains submodule
/// * IN_CONFIG - superproject gitmodules has submodule
/// * IN_WD     - superproject workdir has submodule
///
/// The following values will be returned so long as ignore is not "ALL".
///
/// * INDEX_ADDED       - in index, not in head
/// * INDEX_DELETED     - in head, not in index
/// * INDEX_MODIFIED    - index and head don't match
/// * WD_UNINITIALIZED  - workdir contains empty directory
/// * WD_ADDED          - in workdir, not index
/// * WD_DELETED        - in index, not workdir
/// * WD_MODIFIED       - index and workdir head don't match
///
/// The following can only be returned if ignore is "NONE" or "UNTRACKED".
///
/// * WD_INDEX_MODIFIED - submodule workdir index is dirty
/// * WD_WD_MODIFIED    - submodule workdir has modified files
///
/// Lastly, the following will only be returned for ignore "NONE".
///
/// * WD_UNTRACKED      - wd contains untracked files
enum git_submodule_status_t {
  GIT_SUBMODULE_STATUS_IN_HEAD(1),
  GIT_SUBMODULE_STATUS_IN_INDEX(2),
  GIT_SUBMODULE_STATUS_IN_CONFIG(4),
  GIT_SUBMODULE_STATUS_IN_WD(8),
  GIT_SUBMODULE_STATUS_INDEX_ADDED(16),
  GIT_SUBMODULE_STATUS_INDEX_DELETED(32),
  GIT_SUBMODULE_STATUS_INDEX_MODIFIED(64),
  GIT_SUBMODULE_STATUS_WD_UNINITIALIZED(128),
  GIT_SUBMODULE_STATUS_WD_ADDED(256),
  GIT_SUBMODULE_STATUS_WD_DELETED(512),
  GIT_SUBMODULE_STATUS_WD_MODIFIED(1024),
  GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED(2048),
  GIT_SUBMODULE_STATUS_WD_WD_MODIFIED(4096),
  GIT_SUBMODULE_STATUS_WD_UNTRACKED(8192);

  final int value;
  const git_submodule_status_t(this.value);

  static git_submodule_status_t fromValue(int value) => switch (value) {
        1 => GIT_SUBMODULE_STATUS_IN_HEAD,
        2 => GIT_SUBMODULE_STATUS_IN_INDEX,
        4 => GIT_SUBMODULE_STATUS_IN_CONFIG,
        8 => GIT_SUBMODULE_STATUS_IN_WD,
        16 => GIT_SUBMODULE_STATUS_INDEX_ADDED,
        32 => GIT_SUBMODULE_STATUS_INDEX_DELETED,
        64 => GIT_SUBMODULE_STATUS_INDEX_MODIFIED,
        128 => GIT_SUBMODULE_STATUS_WD_UNINITIALIZED,
        256 => GIT_SUBMODULE_STATUS_WD_ADDED,
        512 => GIT_SUBMODULE_STATUS_WD_DELETED,
        1024 => GIT_SUBMODULE_STATUS_WD_MODIFIED,
        2048 => GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED,
        4096 => GIT_SUBMODULE_STATUS_WD_WD_MODIFIED,
        8192 => GIT_SUBMODULE_STATUS_WD_UNTRACKED,
        _ => throw ArgumentError(
            'Unknown value for git_submodule_status_t: $value'),
      };
}

typedef git_submodule_cbFunction = ffi.Int Function(
    ffi.Pointer<git_submodule> sm,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_submodule_cbFunction = int Function(
    ffi.Pointer<git_submodule> sm,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Void> payload);

/// Function pointer to receive each submodule
///
/// @param sm git_submodule currently being visited
/// @param name name of the submodule
/// @param payload value you passed to the foreach function as payload
/// @return 0 on success or error code
typedef git_submodule_cb
    = ffi.Pointer<ffi.NativeFunction<git_submodule_cbFunction>>;

/// Submodule update options structure
///
/// Initialize with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_submodule_update_options_init`.
final class git_submodule_update_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to `GIT_CHECKOUT_NONE`
  /// or `GIT_CHECKOUT_DRY_RUN`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks to use for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Allow fetching from the submodule's default remote if the target
  /// commit isn't found. Enabled by default.
  @ffi.Int()
  external int allow_fetch;
}

typedef git_tag_foreach_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Void> payload);
typedef Dartgit_tag_foreach_cbFunction = int Function(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Void> payload);

/// Callback used to iterate over tag names
///
/// @see git_tag_foreach
///
/// @param name The tag name
/// @param oid The tag's OID
/// @param payload Payload passed to git_tag_foreach
/// @return non-zero to terminate the iteration
typedef git_tag_foreach_cb
    = ffi.Pointer<ffi.NativeFunction<git_tag_foreach_cbFunction>>;

/// Worktree add options structure
///
/// Initialize with `GIT_WORKTREE_ADD_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_add_options_init`.
final class git_worktree_add_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// < lock newly created worktree
  @ffi.Int()
  external int lock;

  /// < allow checkout of existing branch matching worktree name
  @ffi.Int()
  external int checkout_existing;

  /// < reference to use for the new worktree HEAD
  external ffi.Pointer<git_reference> ref;

  /// Options for the checkout.
  external git_checkout_options checkout_options;
}

/// Flags which can be passed to git_worktree_prune to alter its
/// behavior.
enum git_worktree_prune_t {
  /// Prune working tree even if working tree is valid
  GIT_WORKTREE_PRUNE_VALID(1),

  /// Prune working tree even if it is locked
  GIT_WORKTREE_PRUNE_LOCKED(2),

  /// Prune checked out working tree
  GIT_WORKTREE_PRUNE_WORKING_TREE(4);

  final int value;
  const git_worktree_prune_t(this.value);

  static git_worktree_prune_t fromValue(int value) => switch (value) {
        1 => GIT_WORKTREE_PRUNE_VALID,
        2 => GIT_WORKTREE_PRUNE_LOCKED,
        4 => GIT_WORKTREE_PRUNE_WORKING_TREE,
        _ =>
          throw ArgumentError('Unknown value for git_worktree_prune_t: $value'),
      };
}

/// Worktree prune options structure
///
/// Initialize with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_prune_options_init`.
final class git_worktree_prune_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_worktree_prune_t`
  @ffi.Uint32()
  external int flags;
}

/// Representation of a rename conflict entry in the index.
final class git_index_name_entry extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ancestor;

  external ffi.Pointer<ffi.Char> ours;

  external ffi.Pointer<ffi.Char> theirs;
}

/// Representation of a resolve undo entry in the index.
final class git_index_reuc_entry extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> mode;

  @ffi.Array.multi([3])
  external ffi.Array<git_oid> oid;

  external ffi.Pointer<ffi.Char> path;
}

/// Options for in-memory configuration backends.
final class git_config_backend_memory_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The type of this backend (eg, "command line"). If this is
  /// NULL, then this will be "in-memory".
  external ffi.Pointer<ffi.Char> backend_type;

  /// The path to the origin; if this is NULL then it will be
  /// left unset in the resulting configuration entries.
  external ffi.Pointer<ffi.Char> origin_path;
}

/// The kinds of git-specific files we know about.
///
/// The order needs to stay the same to not break the `gitfiles`
/// array in path.c
enum git_path_gitfile {
  /// Check for the .gitignore file
  GIT_PATH_GITFILE_GITIGNORE(0),

  /// Check for the .gitmodules file
  GIT_PATH_GITFILE_GITMODULES(1),

  /// Check for the .gitattributes file
  GIT_PATH_GITFILE_GITATTRIBUTES(2);

  final int value;
  const git_path_gitfile(this.value);

  static git_path_gitfile fromValue(int value) => switch (value) {
        0 => GIT_PATH_GITFILE_GITIGNORE,
        1 => GIT_PATH_GITFILE_GITMODULES,
        2 => GIT_PATH_GITFILE_GITATTRIBUTES,
        _ => throw ArgumentError('Unknown value for git_path_gitfile: $value'),
      };
}

/// The kinds of checks to perform according to which filesystem we are trying to
/// protect.
enum git_path_fs {
  /// Do both NTFS- and HFS-specific checks
  GIT_PATH_FS_GENERIC(0),

  /// Do NTFS-specific checks only
  GIT_PATH_FS_NTFS(1),

  /// Do HFS-specific checks only
  GIT_PATH_FS_HFS(2);

  final int value;
  const git_path_fs(this.value);

  static git_path_fs fromValue(int value) => switch (value) {
        0 => GIT_PATH_FS_GENERIC,
        1 => GIT_PATH_FS_NTFS,
        2 => GIT_PATH_FS_HFS,
        _ => throw ArgumentError('Unknown value for git_path_fs: $value'),
      };
}

/// The options for creating an repository from scratch.
///
/// Initialize with `GIT_REPOSITORY_NEW_OPTIONS_INIT`. Alternatively,
/// you can use `git_repository_new_options_init`.
///
/// @options[version] GIT_REPOSITORY_NEW_OPTIONS_VERSION
/// @options[init_macro] GIT_REPOSITORY_NEW_OPTIONS_INIT
/// @options[init_function] git_repository_new_options_init
final class git_repository_new_options extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// The object ID type for the object IDs that exist in the index.
  ///
  /// If this is not specified, this defaults to `GIT_OID_SHA1`.
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

/// Options structure for `git_midx_writer_options`.
///
/// Initialize with `GIT_MIDX_WRITER_OPTIONS_INIT`. Alternatively,
/// you can use `git_midx_writer_options_init`.
final class git_midx_writer_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The object ID type that this commit graph contains.
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

typedef git_merge_driver_init_fnFunction = ffi.Int Function(
    ffi.Pointer<git_merge_driver> self);
typedef Dartgit_merge_driver_init_fnFunction = int Function(
    ffi.Pointer<git_merge_driver> self);

/// Initialize callback on merge driver
///
/// Specified as `driver.initialize`, this is an optional callback invoked
/// before a merge driver is first used.  It will be called once at most
/// per library lifetime.
///
/// If non-NULL, the merge driver's `initialize` callback will be invoked
/// right before the first use of the driver, so you can defer expensive
/// initialization operations (in case libgit2 is being used in a way that
/// doesn't need the merge driver).
///
/// @param self the merge driver to initialize
/// @return 0 on success, or a negative number on failure
typedef git_merge_driver_init_fn
    = ffi.Pointer<ffi.NativeFunction<git_merge_driver_init_fnFunction>>;
typedef git_merge_driver_shutdown_fnFunction = ffi.Void Function(
    ffi.Pointer<git_merge_driver> self);
typedef Dartgit_merge_driver_shutdown_fnFunction = void Function(
    ffi.Pointer<git_merge_driver> self);

/// Shutdown callback on merge driver
///
/// Specified as `driver.shutdown`, this is an optional callback invoked
/// when the merge driver is unregistered or when libgit2 is shutting down.
/// It will be called once at most and should release resources as needed.
/// This may be called even if the `initialize` callback was not made.
///
/// Typically this function will free the `git_merge_driver` object itself.
///
/// @param self the merge driver to shutdown
typedef git_merge_driver_shutdown_fn
    = ffi.Pointer<ffi.NativeFunction<git_merge_driver_shutdown_fnFunction>>;

final class git_merge_driver_source extends ffi.Opaque {}

typedef git_merge_driver_apply_fnFunction = ffi.Int Function(
    ffi.Pointer<git_merge_driver> self,
    ffi.Pointer<ffi.Pointer<ffi.Char>> path_out,
    ffi.Pointer<ffi.Uint32> mode_out,
    ffi.Pointer<git_buf> merged_out,
    ffi.Pointer<ffi.Char> filter_name,
    ffi.Pointer<git_merge_driver_source> src);
typedef Dartgit_merge_driver_apply_fnFunction = int Function(
    ffi.Pointer<git_merge_driver> self,
    ffi.Pointer<ffi.Pointer<ffi.Char>> path_out,
    ffi.Pointer<ffi.Uint32> mode_out,
    ffi.Pointer<git_buf> merged_out,
    ffi.Pointer<ffi.Char> filter_name,
    ffi.Pointer<git_merge_driver_source> src);

/// Callback to perform the merge.
///
/// Specified as `driver.apply`, this is the callback that actually does the
/// merge.  If it can successfully perform a merge, it should populate
/// `path_out` with a pointer to the filename to accept, `mode_out` with
/// the resultant mode, and `merged_out` with the buffer of the merged file
/// and then return 0.  If the driver returns `GIT_PASSTHROUGH`, then the
/// default merge driver should instead be run.  It can also return
/// `GIT_EMERGECONFLICT` if the driver is not able to produce a merge result,
/// and the file will remain conflicted.  Any other errors will fail and
/// return to the caller.
///
/// The `filter_name` contains the name of the filter that was invoked, as
/// specified by the file's attributes.
///
/// The `src` contains the data about the file to be merged.
///
/// @param self the merge driver
/// @param path_out the resolved path
/// @param mode_out the resolved mode
/// @param merged_out the merged output contents
/// @param filter_name the filter that was invoked
/// @param src the data about the unmerged file
/// @return 0 on success, or an error code
typedef git_merge_driver_apply_fn
    = ffi.Pointer<ffi.NativeFunction<git_merge_driver_apply_fnFunction>>;

/// Merge driver structure used to register custom merge drivers.
///
/// To associate extra data with a driver, allocate extra data and put the
/// `git_merge_driver` struct at the start of your data buffer, then cast
/// the `self` pointer to your larger structure when your callback is invoked.
final class git_merge_driver extends ffi.Struct {
  /// The `version` should be set to `GIT_MERGE_DRIVER_VERSION`.
  @ffi.UnsignedInt()
  external int version;

  /// Called when the merge driver is first used for any file.
  external git_merge_driver_init_fn initialize;

  /// Called when the merge driver is unregistered from the system.
  external git_merge_driver_shutdown_fn shutdown;

  /// Called to merge the contents of a conflict.  If this function
  /// returns `GIT_PASSTHROUGH` then the default (`text`) merge driver
  /// will instead be invoked.  If this function returns
  /// `GIT_EMERGECONFLICT` then the file will remain conflicted.
  external git_merge_driver_apply_fn apply;
}

/// Every stream must have this struct as its first element, so the
/// API can talk to it. You'd define your stream as
///
/// struct my_stream {
/// git_stream parent;
/// ...
/// }
///
/// and fill the functions
final class git_stream extends ffi.Opaque {}

final class git_stream_registration extends ffi.Struct {
  /// The `version` field should be set to `GIT_STREAM_VERSION`.
  @ffi.Int()
  external int version;

  /// Called to create a new connection to a given host.
  ///
  /// @param out The created stream
  /// @param host The hostname to connect to; may be a hostname or
  /// IP address
  /// @param port The port to connect to; may be a port number or
  /// service name
  /// @return 0 or an error code
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_stream>> out,
              ffi.Pointer<ffi.Char> host, ffi.Pointer<ffi.Char> port)>> init;

  /// Called to create a new connection on top of the given stream.  If
  /// this is a TLS stream, then this function may be used to proxy a
  /// TLS stream over an HTTP CONNECT session.  If this is unset, then
  /// HTTP CONNECT proxies will not be supported.
  ///
  /// @param out The created stream
  /// @param in An existing stream to add TLS to
  /// @param host The hostname that the stream is connected to,
  /// for certificate validation
  /// @return 0 or an error code
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_stream>> out,
              ffi.Pointer<git_stream> in$, ffi.Pointer<ffi.Char> host)>> wrap;
}

/// The type of stream to register.
enum git_stream_t {
  /// A standard (non-TLS) socket.
  GIT_STREAM_STANDARD(1),

  /// A TLS-encrypted socket.
  GIT_STREAM_TLS(2);

  final int value;
  const git_stream_t(this.value);

  static git_stream_t fromValue(int value) => switch (value) {
        1 => GIT_STREAM_STANDARD,
        2 => GIT_STREAM_TLS,
        _ => throw ArgumentError('Unknown value for git_stream_t: $value'),
      };
}

typedef git_stream_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_stream>> out,
    ffi.Pointer<ffi.Char> host,
    ffi.Pointer<ffi.Char> port);
typedef Dartgit_stream_cbFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_stream>> out,
    ffi.Pointer<ffi.Char> host,
    ffi.Pointer<ffi.Char> port);

/// @deprecated Provide a git_stream_registration to git_stream_register
/// @see git_stream_registration
typedef git_stream_cb = ffi.Pointer<ffi.NativeFunction<git_stream_cbFunction>>;

/// A remote's capabilities.
enum git_remote_capability_t {
  /// Remote supports fetching an advertised object by ID.
  GIT_REMOTE_CAPABILITY_TIP_OID(1),

  /// Remote supports fetching an individual reachable object.
  GIT_REMOTE_CAPABILITY_REACHABLE_OID(2),

  /// Remote supports push options.
  GIT_REMOTE_CAPABILITY_PUSH_OPTIONS(4);

  final int value;
  const git_remote_capability_t(this.value);

  static git_remote_capability_t fromValue(int value) => switch (value) {
        1 => GIT_REMOTE_CAPABILITY_TIP_OID,
        2 => GIT_REMOTE_CAPABILITY_REACHABLE_OID,
        4 => GIT_REMOTE_CAPABILITY_PUSH_OPTIONS,
        _ => throw ArgumentError(
            'Unknown value for git_remote_capability_t: $value'),
      };
}

/// Performance data from diffing
final class git_diff_perfdata extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// < Number of stat() calls performed
  @ffi.Size()
  external int stat_calls;

  /// < Number of ID calculations
  @ffi.Size()
  external int oid_calculations;
}

/// Options structure for `git_commit_graph_open_new`.
///
/// Initialize with `GIT_COMMIT_GRAPH_OPEN_OPTIONS_INIT`. Alternatively,
/// you can use `git_commit_graph_open_options_init`.
final class git_commit_graph_open_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The object ID type that this commit graph contains.
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);
}

/// The strategy to use when adding a new set of commits to a pre-existing
/// commit-graph chain.
enum git_commit_graph_split_strategy_t {
  /// Do not split commit-graph files. The other split strategy-related option
  /// fields are ignored.
  GIT_COMMIT_GRAPH_SPLIT_STRATEGY_SINGLE_FILE(0);

  final int value;
  const git_commit_graph_split_strategy_t(this.value);

  static git_commit_graph_split_strategy_t fromValue(int value) =>
      switch (value) {
        0 => GIT_COMMIT_GRAPH_SPLIT_STRATEGY_SINGLE_FILE,
        _ => throw ArgumentError(
            'Unknown value for git_commit_graph_split_strategy_t: $value'),
      };
}

/// Options structure for `git_commit_graph_writer_new`.
///
/// Initialize with `GIT_COMMIT_GRAPH_WRITER_OPTIONS_INIT`. Alternatively,
/// you can use `git_commit_graph_writer_options_init`.
final class git_commit_graph_writer_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The object ID type that this commit graph contains.
  @ffi.UnsignedInt()
  external int oid_typeAsInt;

  git_oid_t get oid_type => git_oid_t.fromValue(oid_typeAsInt);

  /// The strategy to use when adding new commits to a pre-existing commit-graph
  /// chain.
  @ffi.UnsignedInt()
  external int split_strategyAsInt;

  git_commit_graph_split_strategy_t get split_strategy =>
      git_commit_graph_split_strategy_t.fromValue(split_strategyAsInt);

  /// The number of commits in level N is less than X times the number of
  /// commits in level N + 1. Default is 2.
  @ffi.Float()
  external double size_multiple;

  /// The number of commits in level N + 1 is more than C commits.
  /// Default is 64000.
  @ffi.Size()
  external int max_commits;
}

/// Actions that the smart transport can ask a subtransport to perform
enum git_smart_service_t {
  GIT_SERVICE_UPLOADPACK_LS(1),
  GIT_SERVICE_UPLOADPACK(2),
  GIT_SERVICE_RECEIVEPACK_LS(3),
  GIT_SERVICE_RECEIVEPACK(4);

  final int value;
  const git_smart_service_t(this.value);

  static git_smart_service_t fromValue(int value) => switch (value) {
        1 => GIT_SERVICE_UPLOADPACK_LS,
        2 => GIT_SERVICE_UPLOADPACK,
        3 => GIT_SERVICE_RECEIVEPACK_LS,
        4 => GIT_SERVICE_RECEIVEPACK,
        _ =>
          throw ArgumentError('Unknown value for git_smart_service_t: $value'),
      };
}

/// A stream used by the smart transport to read and write data
/// from a subtransport.
///
/// This provides a customization point in case you need to
/// support some other communication method.
final class git_smart_subtransport_stream extends ffi.Struct {
  /// < The owning subtransport
  external ffi.Pointer<git_smart_subtransport> subtransport;

  /// Read available data from the stream.
  ///
  /// The implementation may read less than requested.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_smart_subtransport_stream> stream,
              ffi.Pointer<ffi.Char> buffer,
              ffi.Size buf_size,
              ffi.Pointer<ffi.Size> bytes_read)>> read;

  /// Write data to the stream
  ///
  /// The implementation must write all data or return an error.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_smart_subtransport_stream> stream,
              ffi.Pointer<ffi.Char> buffer, ffi.Size len)>> write;

  /// Free the stream
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_smart_subtransport_stream> stream)>> free;
}

/// An implementation of a subtransport which carries data for the
/// smart transport
final class git_smart_subtransport extends ffi.Struct {
  /// Setup a subtransport stream for the requested action.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_smart_subtransport_stream>> out,
              ffi.Pointer<git_smart_subtransport> transport,
              ffi.Pointer<ffi.Char> url,
              ffi.UnsignedInt action)>> action;

  /// Close the subtransport.
  ///
  /// Subtransports are guaranteed a call to close() between
  /// calls to action(), except for the following two "natural" progressions
  /// of actions against a constant URL:
  ///
  /// - UPLOADPACK_LS -> UPLOADPACK
  /// - RECEIVEPACK_LS -> RECEIVEPACK
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_smart_subtransport> transport)>>
      close;

  /// Free the subtransport
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_smart_subtransport> transport)>>
      free;
}

typedef git_smart_subtransport_cbFunction = ffi.Int Function(
    ffi.Pointer<ffi.Pointer<git_smart_subtransport>> out,
    ffi.Pointer<git_transport> owner,
    ffi.Pointer<ffi.Void> param);
typedef Dartgit_smart_subtransport_cbFunction = int Function(
    ffi.Pointer<ffi.Pointer<git_smart_subtransport>> out,
    ffi.Pointer<git_transport> owner,
    ffi.Pointer<ffi.Void> param);

/// A function that creates a new subtransport for the smart transport
///
/// @param out the smart subtransport
/// @param owner the transport owner
/// @param param the input parameter
/// @return 0 on success, or an error code
typedef git_smart_subtransport_cb
    = ffi.Pointer<ffi.NativeFunction<git_smart_subtransport_cbFunction>>;

/// Definition for a "subtransport"
///
/// The smart transport knows how to speak the git protocol, but it has no
/// knowledge of how to establish a connection between it and another endpoint,
/// or how to move data back and forth. For this, a subtransport interface is
/// declared, and the smart transport delegates this work to the subtransports.
///
/// Three subtransports are provided by libgit2: ssh, git, http(s).
///
/// Subtransports can either be RPC = 0 (persistent connection) or RPC = 1
/// (request/response). The smart transport handles the differences in its own
/// logic. The git subtransport is RPC = 0, while http is RPC = 1.
final class git_smart_subtransport_definition extends ffi.Struct {
  /// The function to use to create the git_smart_subtransport
  external git_smart_subtransport_cb callback;

  /// True if the protocol is stateless; false otherwise. For example,
  /// http:// is stateless, but git:// is not.
  @ffi.UnsignedInt()
  external int rpc;

  /// User-specified parameter passed to the callback
  external ffi.Pointer<ffi.Void> param;
}

final class git_hashsig extends ffi.Opaque {}

/// Options for hashsig computation
///
/// The options GIT_HASHSIG_NORMAL, GIT_HASHSIG_IGNORE_WHITESPACE,
/// GIT_HASHSIG_SMART_WHITESPACE are exclusive and should not be combined.
enum git_hashsig_option_t {
  /// Use all data
  GIT_HASHSIG_NORMAL(0),

  /// Ignore whitespace
  GIT_HASHSIG_IGNORE_WHITESPACE(1),

  /// Ignore \r and all space after \n
  GIT_HASHSIG_SMART_WHITESPACE(2),

  /// Allow hashing of small files
  GIT_HASHSIG_ALLOW_SMALL_FILES(4);

  final int value;
  const git_hashsig_option_t(this.value);

  static git_hashsig_option_t fromValue(int value) => switch (value) {
        0 => GIT_HASHSIG_NORMAL,
        1 => GIT_HASHSIG_IGNORE_WHITESPACE,
        2 => GIT_HASHSIG_SMART_WHITESPACE,
        4 => GIT_HASHSIG_ALLOW_SMALL_FILES,
        _ =>
          throw ArgumentError('Unknown value for git_hashsig_option_t: $value'),
      };
}

/// An instance for a custom memory allocator
///
/// Setting the pointers of this structure allows the developer to implement
/// custom memory allocators. The global memory allocator can be set by using
/// "GIT_OPT_SET_ALLOCATOR" with the `git_libgit2_opts` function. Keep in mind
/// that all fields need to be set to a proper function.
final class git_allocator extends ffi.Struct {
  /// Allocate `n` bytes of memory
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size n, ffi.Pointer<ffi.Char> file, ffi.Int line)>> gmalloc;

  /// This function shall deallocate the old object `ptr` and return a
  /// pointer to a new object that has the size specified by `size`. In
  /// case `ptr` is `NULL`, a new array shall be allocated.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void> ptr,
              ffi.Size size,
              ffi.Pointer<ffi.Char> file,
              ffi.Int line)>> grealloc;

  /// This function shall free the memory pointed to by `ptr`. In case
  /// `ptr` is `NULL`, this shall be a no-op.
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> ptr)>>
      gfree;
}

typedef git_commit_parent_callbackFunction = ffi.Pointer<git_oid> Function(
    ffi.Size idx, ffi.Pointer<ffi.Void> payload);
typedef Dartgit_commit_parent_callbackFunction = ffi.Pointer<git_oid> Function(
    int idx, ffi.Pointer<ffi.Void> payload);

/// Callback function to return parents for commit.
///
/// This is invoked with the count of the number of parents processed so far
/// along with the user supplied payload.  This should return a git_oid of
/// the next parent or NULL if all parents have been provided.
///
/// @param idx the index of the parent
/// @param payload the user-specified payload
/// @return the object id of the parent, or NULL if there are no further parents
typedef git_commit_parent_callback
    = ffi.Pointer<ffi.NativeFunction<git_commit_parent_callbackFunction>>;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __has_bounds_safety_attributes = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_KERNELKIT = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_13_7 = 130700;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __MAC_14_6 = 140600;

const int __MAC_14_7 = 140700;

const int __MAC_15_0 = 150000;

const int __MAC_15_1 = 150100;

const int __MAC_15_2 = 150200;

const int __MAC_15_3 = 150300;

const int __MAC_15_4 = 150400;

const int __MAC_15_5 = 150500;

const int __MAC_15_6 = 150600;

const int __MAC_16_0 = 160000;

const int __MAC_26_0 = 260000;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __IPHONE_17_6 = 170600;

const int __IPHONE_17_7 = 170700;

const int __IPHONE_18_0 = 180000;

const int __IPHONE_18_1 = 180100;

const int __IPHONE_18_2 = 180200;

const int __IPHONE_18_3 = 180300;

const int __IPHONE_18_4 = 180400;

const int __IPHONE_18_5 = 180500;

const int __IPHONE_18_6 = 180600;

const int __IPHONE_19_0 = 190000;

const int __IPHONE_26_0 = 260000;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __WATCHOS_10_6 = 100600;

const int __WATCHOS_10_7 = 100700;

const int __WATCHOS_11_0 = 110000;

const int __WATCHOS_11_1 = 110100;

const int __WATCHOS_11_2 = 110200;

const int __WATCHOS_11_3 = 110300;

const int __WATCHOS_11_4 = 110400;

const int __WATCHOS_11_5 = 110500;

const int __WATCHOS_11_6 = 110600;

const int __WATCHOS_12_0 = 120000;

const int __WATCHOS_26_0 = 260000;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __TVOS_17_6 = 170600;

const int __TVOS_18_0 = 180000;

const int __TVOS_18_1 = 180100;

const int __TVOS_18_2 = 180200;

const int __TVOS_18_3 = 180300;

const int __TVOS_18_4 = 180400;

const int __TVOS_18_5 = 180500;

const int __TVOS_18_6 = 180600;

const int __TVOS_19_0 = 190000;

const int __TVOS_26_0 = 260000;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __BRIDGEOS_8_6 = 80600;

const int __BRIDGEOS_9_0 = 90000;

const int __BRIDGEOS_9_1 = 90100;

const int __BRIDGEOS_9_2 = 90200;

const int __BRIDGEOS_9_3 = 90300;

const int __BRIDGEOS_9_4 = 90400;

const int __BRIDGEOS_9_5 = 90500;

const int __BRIDGEOS_9_6 = 90600;

const int __BRIDGEOS_10_0 = 100000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __DRIVERKIT_23_6 = 230600;

const int __DRIVERKIT_24_0 = 240000;

const int __DRIVERKIT_24_1 = 240100;

const int __DRIVERKIT_24_2 = 240200;

const int __DRIVERKIT_24_3 = 240300;

const int __DRIVERKIT_24_4 = 240400;

const int __DRIVERKIT_24_5 = 240500;

const int __DRIVERKIT_24_6 = 240600;

const int __DRIVERKIT_25_0 = 250000;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int __VISIONOS_1_3 = 10300;

const int __VISIONOS_2_0 = 20000;

const int __VISIONOS_2_1 = 20100;

const int __VISIONOS_2_2 = 20200;

const int __VISIONOS_2_3 = 20300;

const int __VISIONOS_2_4 = 20400;

const int __VISIONOS_2_5 = 20500;

const int __VISIONOS_2_6 = 20600;

const int __VISIONOS_3_0 = 30000;

const int __VISIONOS_26_0 = 260000;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_13_7 = 130700;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int MAC_OS_VERSION_14_6 = 140600;

const int MAC_OS_VERSION_14_7 = 140700;

const int MAC_OS_VERSION_15_0 = 150000;

const int MAC_OS_VERSION_15_1 = 150100;

const int MAC_OS_VERSION_15_2 = 150200;

const int MAC_OS_VERSION_15_3 = 150300;

const int MAC_OS_VERSION_15_4 = 150400;

const int MAC_OS_VERSION_15_5 = 150500;

const int MAC_OS_VERSION_15_6 = 150600;

const int MAC_OS_VERSION_16_0 = 160000;

const int MAC_OS_VERSION_26_0 = 260000;

const int __AVAILABILITY_VERSIONS_VERSION_HASH = 93585900;

const String __AVAILABILITY_VERSIONS_VERSION_STRING = 'Local';

const String __AVAILABILITY_FILE = 'AvailabilityVersions.h';

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 150000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 260000;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int USER_ADDR_NULL = 0;

const int NULL = 0;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 6;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_MONOTONIC_RAW_APPROX = 5;

const int CLOCK_UPTIME_RAW = 8;

const int CLOCK_UPTIME_RAW_APPROX = 9;

const int CLOCK_PROCESS_CPUTIME_ID = 12;

const int CLOCK_THREAD_CPUTIME_ID = 16;

const int TIME_UTC = 1;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int SIGEV_KEVENT = 4;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_TYPE_VFS_ENTITLED_RESERVE_ACCESS = 14;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE = 2;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int IOPOL_VFS_ENTITLED_RESERVE_ACCESS_OFF = 0;

const int IOPOL_VFS_ENTITLED_RESERVE_ACCESS_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int BYTE_ORDER = 1234;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int _MALLOC_TYPE_MALLOC_BACKDEPLOY_PUBLIC = 1;

const String __PRI_8_LENGTH_MODIFIER__ = 'hh';

const String __PRI_64_LENGTH_MODIFIER__ = 'll';

const String __SCN_64_LENGTH_MODIFIER__ = 'll';

const String __PRI_MAX_LENGTH_MODIFIER__ = 'j';

const String __SCN_MAX_LENGTH_MODIFIER__ = 'j';

const String PRId8 = 'hhd';

const String PRIi8 = 'hhi';

const String PRIo8 = 'hho';

const String PRIu8 = 'hhu';

const String PRIx8 = 'hhx';

const String PRIX8 = 'hhX';

const String PRId16 = 'hd';

const String PRIi16 = 'hi';

const String PRIo16 = 'ho';

const String PRIu16 = 'hu';

const String PRIx16 = 'hx';

const String PRIX16 = 'hX';

const String PRId32 = 'd';

const String PRIi32 = 'i';

const String PRIo32 = 'o';

const String PRIu32 = 'u';

const String PRIx32 = 'x';

const String PRIX32 = 'X';

const String PRId64 = 'lld';

const String PRIi64 = 'lli';

const String PRIo64 = 'llo';

const String PRIu64 = 'llu';

const String PRIx64 = 'llx';

const String PRIX64 = 'llX';

const String PRIdLEAST8 = 'hhd';

const String PRIiLEAST8 = 'hhi';

const String PRIoLEAST8 = 'hho';

const String PRIuLEAST8 = 'hhu';

const String PRIxLEAST8 = 'hhx';

const String PRIXLEAST8 = 'hhX';

const String PRIdLEAST16 = 'hd';

const String PRIiLEAST16 = 'hi';

const String PRIoLEAST16 = 'ho';

const String PRIuLEAST16 = 'hu';

const String PRIxLEAST16 = 'hx';

const String PRIXLEAST16 = 'hX';

const String PRIdLEAST32 = 'd';

const String PRIiLEAST32 = 'i';

const String PRIoLEAST32 = 'o';

const String PRIuLEAST32 = 'u';

const String PRIxLEAST32 = 'x';

const String PRIXLEAST32 = 'X';

const String PRIdLEAST64 = 'lld';

const String PRIiLEAST64 = 'lli';

const String PRIoLEAST64 = 'llo';

const String PRIuLEAST64 = 'llu';

const String PRIxLEAST64 = 'llx';

const String PRIXLEAST64 = 'llX';

const String PRIdFAST8 = 'hhd';

const String PRIiFAST8 = 'hhi';

const String PRIoFAST8 = 'hho';

const String PRIuFAST8 = 'hhu';

const String PRIxFAST8 = 'hhx';

const String PRIXFAST8 = 'hhX';

const String PRIdFAST16 = 'hd';

const String PRIiFAST16 = 'hi';

const String PRIoFAST16 = 'ho';

const String PRIuFAST16 = 'hu';

const String PRIxFAST16 = 'hx';

const String PRIXFAST16 = 'hX';

const String PRIdFAST32 = 'd';

const String PRIiFAST32 = 'i';

const String PRIoFAST32 = 'o';

const String PRIuFAST32 = 'u';

const String PRIxFAST32 = 'x';

const String PRIXFAST32 = 'X';

const String PRIdFAST64 = 'lld';

const String PRIiFAST64 = 'lli';

const String PRIoFAST64 = 'llo';

const String PRIuFAST64 = 'llu';

const String PRIxFAST64 = 'llx';

const String PRIXFAST64 = 'llX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String PRIdMAX = 'jd';

const String PRIiMAX = 'ji';

const String PRIoMAX = 'jo';

const String PRIuMAX = 'ju';

const String PRIxMAX = 'jx';

const String PRIXMAX = 'jX';

const String SCNd8 = 'hhd';

const String SCNi8 = 'hhi';

const String SCNo8 = 'hho';

const String SCNu8 = 'hhu';

const String SCNx8 = 'hhx';

const String SCNd16 = 'hd';

const String SCNi16 = 'hi';

const String SCNo16 = 'ho';

const String SCNu16 = 'hu';

const String SCNx16 = 'hx';

const String SCNd32 = 'd';

const String SCNi32 = 'i';

const String SCNo32 = 'o';

const String SCNu32 = 'u';

const String SCNx32 = 'x';

const String SCNd64 = 'lld';

const String SCNi64 = 'lli';

const String SCNo64 = 'llo';

const String SCNu64 = 'llu';

const String SCNx64 = 'llx';

const String SCNdLEAST8 = 'hhd';

const String SCNiLEAST8 = 'hhi';

const String SCNoLEAST8 = 'hho';

const String SCNuLEAST8 = 'hhu';

const String SCNxLEAST8 = 'hhx';

const String SCNdLEAST16 = 'hd';

const String SCNiLEAST16 = 'hi';

const String SCNoLEAST16 = 'ho';

const String SCNuLEAST16 = 'hu';

const String SCNxLEAST16 = 'hx';

const String SCNdLEAST32 = 'd';

const String SCNiLEAST32 = 'i';

const String SCNoLEAST32 = 'o';

const String SCNuLEAST32 = 'u';

const String SCNxLEAST32 = 'x';

const String SCNdLEAST64 = 'lld';

const String SCNiLEAST64 = 'lli';

const String SCNoLEAST64 = 'llo';

const String SCNuLEAST64 = 'llu';

const String SCNxLEAST64 = 'llx';

const String SCNdFAST8 = 'hhd';

const String SCNiFAST8 = 'hhi';

const String SCNoFAST8 = 'hho';

const String SCNuFAST8 = 'hhu';

const String SCNxFAST8 = 'hhx';

const String SCNdFAST16 = 'hd';

const String SCNiFAST16 = 'hi';

const String SCNoFAST16 = 'ho';

const String SCNuFAST16 = 'hu';

const String SCNxFAST16 = 'hx';

const String SCNdFAST32 = 'd';

const String SCNiFAST32 = 'i';

const String SCNoFAST32 = 'o';

const String SCNuFAST32 = 'u';

const String SCNxFAST32 = 'x';

const String SCNdFAST64 = 'lld';

const String SCNiFAST64 = 'lli';

const String SCNoFAST64 = 'llo';

const String SCNuFAST64 = 'llu';

const String SCNxFAST64 = 'llx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const String SCNdMAX = 'jd';

const String SCNiMAX = 'ji';

const String SCNoMAX = 'jo';

const String SCNuMAX = 'ju';

const String SCNxMAX = 'jx';

const int GIT_PATH_LIST_SEPARATOR = 58;

const int GIT_PATH_MAX = 4096;

const int __DARWIN_FD_SETSIZE = 1024;

const int __DARWIN_NBBY = 8;

const int __DARWIN_NFDBITS = 32;

const int NBBY = 8;

const int NFDBITS = 32;

const int FD_SETSIZE = 1024;

const int GIT_OID_DEFAULT = 1;

const int GIT_OID_SHA1_SIZE = 20;

const int GIT_OID_SHA1_HEXSIZE = 40;

const String GIT_OID_SHA1_HEXZERO = '0000000000000000000000000000000000000000';

const int GIT_OID_SHA256_SIZE = 32;

const int GIT_OID_SHA256_HEXSIZE = 64;

const String GIT_OID_SHA256_HEXZERO =
    '0000000000000000000000000000000000000000000000000000000000000000';

const int GIT_OID_MAX_SIZE = 32;

const int GIT_OID_MAX_HEXSIZE = 64;

const int GIT_OID_MINPREFIXLEN = 4;

const int GIT_INDEXER_OPTIONS_VERSION = 1;

const int GIT_ODB_OPTIONS_VERSION = 1;

const int GIT_OBJECT_SIZE_MAX = -1;

const int GIT_COMMIT_CREATE_OPTIONS_VERSION = 1;

const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;

const int GIT_DIFF_OPTIONS_VERSION = 1;

const int GIT_DIFF_HUNK_HEADER_SIZE = 128;

const int GIT_DIFF_FIND_OPTIONS_VERSION = 1;

const int GIT_DIFF_PARSE_OPTIONS_VERSION = 1;

const int GIT_DIFF_PATCHID_OPTIONS_VERSION = 1;

const int GIT_APPLY_OPTIONS_VERSION = 1;

const int GIT_ATTR_CHECK_FILE_THEN_INDEX = 0;

const int GIT_ATTR_CHECK_INDEX_THEN_FILE = 1;

const int GIT_ATTR_CHECK_INDEX_ONLY = 2;

const int GIT_ATTR_CHECK_NO_SYSTEM = 4;

const int GIT_ATTR_CHECK_INCLUDE_HEAD = 8;

const int GIT_ATTR_CHECK_INCLUDE_COMMIT = 16;

const int GIT_ATTR_OPTIONS_VERSION = 1;

const int GIT_BLOB_FILTER_OPTIONS_VERSION = 1;

const int GIT_BLAME_OPTIONS_VERSION = 1;

const int GIT_CHECKOUT_OPTIONS_VERSION = 1;

const int GIT_INDEX_ENTRY_NAMEMASK = 4095;

const int GIT_INDEX_ENTRY_STAGEMASK = 12288;

const int GIT_INDEX_ENTRY_STAGESHIFT = 12;

const int GIT_INDEX_OPTIONS_VERSION = 1;

const int GIT_MERGE_FILE_INPUT_VERSION = 1;

const int GIT_MERGE_CONFLICT_MARKER_SIZE = 7;

const int GIT_MERGE_FILE_OPTIONS_VERSION = 1;

const int GIT_MERGE_OPTIONS_VERSION = 1;

const int GIT_CHERRYPICK_OPTIONS_VERSION = 1;

const String GIT_DEFAULT_PORT = '9418';

const int GIT_PROXY_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CREATE_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CALLBACKS_VERSION = 1;

const int GIT_FETCH_OPTIONS_VERSION = 1;

const int GIT_PUSH_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CONNECT_OPTIONS_VERSION = 1;

const int GIT_CLONE_OPTIONS_VERSION = 1;

const int GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS = 10;

const int GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE = 7;

const int GIT_DESCRIBE_OPTIONS_VERSION = 1;

const int GIT_DESCRIBE_FORMAT_OPTIONS_VERSION = 1;

const int GIT_EMAIL_CREATE_OPTIONS_VERSION = 1;

const int GIT_FILTER_OPTIONS_VERSION = 1;

const int GIT_ODB_BACKEND_PACK_OPTIONS_VERSION = 1;

const int GIT_ODB_BACKEND_LOOSE_OPTIONS_VERSION = 1;

const int GIT_REBASE_OPTIONS_VERSION = 1;

const int GIT_REBASE_NO_OPERATION = -1;

const int GIT_REVERT_OPTIONS_VERSION = 1;

const int GIT_STASH_SAVE_OPTIONS_VERSION = 1;

const int GIT_STASH_APPLY_OPTIONS_VERSION = 1;

const int GIT_STATUS_OPT_DEFAULTS = 19;

const int GIT_STATUS_OPTIONS_VERSION = 1;

const int GIT_SUBMODULE_STATUS__IN_FLAGS = 15;

const int GIT_SUBMODULE_STATUS__INDEX_FLAGS = 112;

const int GIT_SUBMODULE_STATUS__WD_FLAGS = 16256;

const int GIT_SUBMODULE_UPDATE_OPTIONS_VERSION = 1;

const String LIBGIT2_VERSION = '1.9.1';

const int LIBGIT2_VERSION_MAJOR = 1;

const int LIBGIT2_VERSION_MINOR = 9;

const int LIBGIT2_VERSION_REVISION = 1;

const int LIBGIT2_VERSION_PATCH = 0;

const int LIBGIT2_VERSION_PRERELEASE = 0;

const String LIBGIT2_SOVERSION = '1.9';

const int LIBGIT2_VERSION_NUMBER = 1090100;

const int GIT_WORKTREE_ADD_OPTIONS_VERSION = 1;

const int GIT_WORKTREE_PRUNE_OPTIONS_VERSION = 1;

const int GIT_CONFIG_BACKEND_VERSION = 1;

const int GIT_CONFIG_BACKEND_MEMORY_OPTIONS_VERSION = 1;

const int GIT_REPOSITORY_NEW_OPTIONS_VERSION = 1;

const int GIT_MIDX_WRITER_OPTIONS_VERSION = 1;

const String GIT_MERGE_DRIVER_TEXT = 'text';

const String GIT_MERGE_DRIVER_BINARY = 'binary';

const String GIT_MERGE_DRIVER_UNION = 'union';

const int GIT_MERGE_DRIVER_VERSION = 1;

const int GIT_STREAM_VERSION = 1;

const int GIT_ODB_BACKEND_VERSION = 1;

const int GIT_DIFF_PERFDATA_VERSION = 1;

const int GIT_COMMIT_GRAPH_OPEN_OPTIONS_VERSION = 1;

const int GIT_COMMIT_GRAPH_WRITER_OPTIONS_VERSION = 1;

const int GIT_TRANSPORT_VERSION = 1;

const String GIT_FILTER_CRLF = 'crlf';

const String GIT_FILTER_IDENT = 'ident';

const int GIT_FILTER_CRLF_PRIORITY = 0;

const int GIT_FILTER_IDENT_PRIORITY = 100;

const int GIT_FILTER_DRIVER_PRIORITY = 200;

const int GIT_FILTER_VERSION = 1;

const int GIT_REFDB_BACKEND_VERSION = 1;
